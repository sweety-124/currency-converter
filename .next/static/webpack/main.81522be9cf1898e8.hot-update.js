/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main",{

/***/ "./node_modules/next/dist/compiled/@next/react-dev-overlay/dist/client.js":
/*!********************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/@next/react-dev-overlay/dist/client.js ***!
  \********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){\"use strict\";var e={876:function(e,t){Object.defineProperty(t,\"__esModule\",{value:true});0&&0;function _export(e,t){for(var r in t)Object.defineProperty(e,r,{enumerable:true,get:t[r]})}_export(t,{hydrationErrorWarning:function(){return r},hydrationErrorComponentStack:function(){return n},patchConsoleError:function(){return patchConsoleError}});let r;let n;const a=new Set(['Warning: Text content did not match. Server: \"%s\" Client: \"%s\"%s',\"Warning: Expected server HTML to contain a matching <%s> in <%s>.%s\",'Warning: Expected server HTML to contain a matching text node for \"%s\" in <%s>.%s',\"Warning: Did not expect server HTML to contain a <%s> in <%s>.%s\",'Warning: Did not expect server HTML to contain the text node \"%s\" in <%s>.%s']);function patchConsoleError(){const e=console.error;console.error=function(t,o,i,l){if(a.has(t)){r=t.replace(\"%s\",o).replace(\"%s\",i).replace(\"%s\",\"\");n=l}e.apply(console,arguments)}}if((typeof t.default===\"function\"||typeof t.default===\"object\"&&t.default!==null)&&typeof t.default.__esModule===\"undefined\"){Object.defineProperty(t.default,\"__esModule\",{value:true});Object.assign(t.default,t);e.exports=t.default}},659:function(e,t){Object.defineProperty(t,\"__esModule\",{value:true});Object.defineProperty(t,\"parseComponentStack\",{enumerable:true,get:function(){return parseComponentStack}});function parseComponentStack(e){const t=[];for(const n of e.trim().split(\"\\n\")){const e=/at ([^ ]+)( \\((.*)\\))?/.exec(n);if(e==null?void 0:e[1]){const n=e[1];const a=e[3];if(a==null?void 0:a.includes(\"next/dist\")){break}const o=a==null?void 0:a.replace(/^(webpack-internal:\\/\\/\\/|file:\\/\\/)(\\(.*\\)\\/)?/,\"\");var r;const[i,l,s]=(r=o==null?void 0:o.split(\":\"))!=null?r:[];t.push({component:n,file:i,lineNumber:l?Number(l):undefined,column:s?Number(s):undefined})}}return t}if((typeof t.default===\"function\"||typeof t.default===\"object\"&&t.default!==null)&&typeof t.default.__esModule===\"undefined\"){Object.defineProperty(t.default,\"__esModule\",{value:true});Object.assign(t.default,t);e.exports=t.default}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var a=t[r]={exports:{}};var o=true;try{e[r](a,a.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return a.exports}!function(){__nccwpck_require__.n=function(e){var t=e&&e.__esModule?function(){return e[\"default\"]}:function(){return e};__nccwpck_require__.d(t,{a:t});return t}}();!function(){__nccwpck_require__.d=function(e,t){for(var r in t){if(__nccwpck_require__.o(t,r)&&!__nccwpck_require__.o(e,r)){Object.defineProperty(e,r,{enumerable:true,get:t[r]})}}}}();!function(){__nccwpck_require__.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)}}();!function(){__nccwpck_require__.r=function(e){if(typeof Symbol!==\"undefined\"&&Symbol.toStringTag){Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"})}Object.defineProperty(e,\"__esModule\",{value:true})}}();if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r={};!function(){__nccwpck_require__.r(r);__nccwpck_require__.d(r,{ReactDevOverlay:function(){return Zt},getErrorByType:function(){return getErrorByType},getServerError:function(){return getServerError},onBeforeRefresh:function(){return onBeforeRefresh},onBuildError:function(){return onBuildError},onBuildOk:function(){return onBuildOk},onRefresh:function(){return onRefresh},register:function(){return register},unregister:function(){return unregister}});const e=\"build-ok\";const t=\"build-error\";const n=\"fast-refresh\";const a=\"before-fast-refresh\";const o=\"unhandled-error\";const i=\"unhandled-rejection\";let l=new Set;let s=[];function drain(){setTimeout((function(){while(Boolean(s.length)&&Boolean(l.size)){const e=s.shift();l.forEach((t=>t(e)))}}),1)}function emit(e){s.push(Object.freeze({...e}));drain()}function on(e){if(l.has(e)){return false}l.add(e);drain();return true}function off(e){if(l.has(e)){l.delete(e);return true}return false}var u=__webpack_require__(/*! next/dist/compiled/stacktrace-parser */ \"./node_modules/next/dist/compiled/stacktrace-parser/stack-trace-parser.cjs.js\");const c=/\\/_next(\\/static\\/.+)/g;function parseStack(e){const t=(0,u.parse)(e);return t.map((e=>{try{const t=new URL(e.file);const r=c.exec(t.pathname);if(r){const t=\"/Users/akashranjan/Documents/currency-converter/.next\"?.replace(/\\\\/g,\"/\")?.replace(/\\/$/,\"\");if(t){e.file=\"file://\"+t.concat(r.pop())}}}catch{}return e}))}var d=__nccwpck_require__(659);var f=__nccwpck_require__(876);function getFilesystemFrame(e){const t={...e};if(typeof t.file===\"string\"){if(t.file.startsWith(\"/\")||/^[a-z]:\\\\/i.test(t.file)||t.file.startsWith(\"\\\\\\\\\")){t.file=`file://${t.file}`}}return t}const m=Symbol(\"NextjsError\");function getErrorSource(e){return e[m]||null}function decorateServerError(e,t){Object.defineProperty(e,m,{writable:false,enumerable:false,configurable:false,value:t})}function getServerError(e,t){let r;try{throw new Error(e.message)}catch(e){r=e}r.name=e.name;try{r.stack=`${r.toString()}\\n${(0,u.parse)(e.stack).map(getFilesystemFrame).map((e=>{let t=`    at ${e.methodName}`;if(e.file){let r=e.file;if(e.lineNumber){r+=`:${e.lineNumber}`;if(e.column){r+=`:${e.column}`}}t+=` (${r})`}return t})).join(\"\\n\")}`}catch{r.stack=e.stack}decorateServerError(r,t);return r}function getOriginalStackFrame(e,t,r){async function _getOriginalStackFrame(){const n=new URLSearchParams;n.append(\"isServer\",String(t===\"server\"));n.append(\"isEdgeServer\",String(t===\"edge-server\"));n.append(\"errorMessage\",r);for(const t in e){n.append(t,(e[t]??\"\").toString())}const a=new AbortController;const o=setTimeout((()=>a.abort()),3e3);const i=await self.fetch(`${ false||\"\"}/__nextjs_original-stack-frame?${n.toString()}`,{signal:a.signal}).finally((()=>{clearTimeout(o)}));if(!i.ok||i.status===204){return Promise.reject(new Error(await i.text()))}const l=await i.json();return{error:false,reason:null,external:false,expanded:!Boolean((e.file?.includes(\"node_modules\")||l.originalStackFrame?.file?.includes(\"node_modules\"))??true),sourceStackFrame:e,originalStackFrame:l.originalStackFrame,originalCodeFrame:l.originalCodeFrame||null}}if(!(e.file?.startsWith(\"webpack-internal:\")||e.file?.startsWith(\"file:\"))){return Promise.resolve({error:false,reason:null,external:true,expanded:false,sourceStackFrame:e,originalStackFrame:null,originalCodeFrame:null})}return _getOriginalStackFrame().catch((t=>({error:true,reason:t?.message??t?.toString()??\"Unknown Error\",external:false,expanded:false,sourceStackFrame:e,originalStackFrame:null,originalCodeFrame:null})))}function getOriginalStackFrames(e,t,r){return Promise.all(e.map((e=>getOriginalStackFrame(e,t,r))))}function getFrameSource(e){let t=\"\";try{const r=new URL(e.file);if(typeof globalThis!==\"undefined\"&&globalThis.location?.origin!==r.origin){if(r.origin===\"null\"){t+=r.protocol}else{t+=r.origin}}t+=r.pathname;t+=\" \"}catch{t+=(e.file||\"(unknown)\")+\" \"}if(e.lineNumber!=null){if(e.column!=null){t+=`(${e.lineNumber}:${e.column}) `}else{t+=`(${e.lineNumber}) `}}return t.slice(0,-1)}async function getErrorByType(e){const{id:t,event:r}=e;switch(r.type){case o:case i:{const e={id:t,runtime:true,error:r.reason,frames:await getOriginalStackFrames(r.frames,getErrorSource(r.reason),r.reason.toString())};if(r.type===o){e.componentStack=r.componentStack}return e}default:{break}}const n=r;throw new Error(\"type system invariant violation\")}var p=__webpack_require__(/*! react */ \"./node_modules/react/index.js\");var b=__nccwpck_require__.n(p);var v=__webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");const g=function Portal({children:e,globalOverlay:t}){let r=p.useRef(null);let n=p.useRef(null);let a=p.useRef(null);let[,o]=p.useState();p.useLayoutEffect((()=>{const e=t?document:r.current.ownerDocument;n.current=e.createElement(\"nextjs-portal\");a.current=n.current.attachShadow({mode:\"open\"});e.body.appendChild(n.current);o({});return()=>{if(n.current&&n.current.ownerDocument){n.current.ownerDocument.body.removeChild(n.current)}}}),[t]);return a.current?(0,v.createPortal)(e,a.current):t?null:p.createElement(\"span\",{ref:r})};function useOnClickOutside(e,t){p.useEffect((()=>{if(e==null||t==null){return}const listener=r=>{if(!e||e.contains(r.target)){return}t(r)};const r=e.getRootNode();r.addEventListener(\"mousedown\",listener);r.addEventListener(\"touchstart\",listener);return function(){r.removeEventListener(\"mousedown\",listener);r.removeEventListener(\"touchstart\",listener)}}),[t,e])}const h=function Dialog({children:e,type:t,onClose:r,...n}){const[a,o]=p.useState(null);const[i,l]=p.useState(typeof document!==\"undefined\"&&document.hasFocus()?\"dialog\":undefined);const s=p.useCallback((e=>{o(e)}),[]);useOnClickOutside(a,r);p.useEffect((()=>{if(a==null){return}const e=a.getRootNode();if(!(e instanceof ShadowRoot)){return}const t=e;function handler(e){const r=t.activeElement;if(e.key===\"Enter\"&&r instanceof HTMLElement&&r.getAttribute(\"role\")===\"link\"){e.preventDefault();e.stopPropagation();r.click()}}function handleFocus(){l(document.hasFocus()?\"dialog\":undefined)}t.addEventListener(\"keydown\",handler);window.addEventListener(\"focus\",handleFocus);window.addEventListener(\"blur\",handleFocus);return()=>{t.removeEventListener(\"keydown\",handler);window.removeEventListener(\"focus\",handleFocus);window.removeEventListener(\"blur\",handleFocus)}}),[a]);return p.createElement(\"div\",{ref:s,\"data-nextjs-dialog\":true,tabIndex:-1,role:i,\"aria-labelledby\":n[\"aria-labelledby\"],\"aria-describedby\":n[\"aria-describedby\"],\"aria-modal\":\"true\"},p.createElement(\"div\",{\"data-nextjs-dialog-banner\":true,className:`banner-${t}`}),e)};const x=function DialogBody({children:e,className:t}){return p.createElement(\"div\",{\"data-nextjs-dialog-body\":true,className:t},e)};const y=function DialogContent({children:e,className:t}){return p.createElement(\"div\",{\"data-nextjs-dialog-content\":true,className:t},e)};const E=function DialogHeader({children:e,className:t}){return p.createElement(\"div\",{\"data-nextjs-dialog-header\":true,className:t},e)};function noop(e,...t){const r=e.length-1;return e.slice(0,r).reduce(((e,r,n)=>e+r+t[n]),\"\")+e[r]}const w=noop`\n  [data-nextjs-dialog] {\n    display: flex;\n    flex-direction: column;\n    width: 100%;\n    margin-right: auto;\n    margin-left: auto;\n    outline: none;\n    background: var(--color-background);\n    border-radius: var(--size-gap);\n    box-shadow: 0 var(--size-gap-half) var(--size-gap-double)\n      rgba(0, 0, 0, 0.25);\n    max-height: calc(100% - 56px);\n    overflow-y: hidden;\n  }\n\n  @media (max-height: 812px) {\n    [data-nextjs-dialog-overlay] {\n      max-height: calc(100% - 15px);\n    }\n  }\n\n  @media (min-width: 576px) {\n    [data-nextjs-dialog] {\n      max-width: 540px;\n      box-shadow: 0 var(--size-gap) var(--size-gap-quad) rgba(0, 0, 0, 0.25);\n    }\n  }\n\n  @media (min-width: 768px) {\n    [data-nextjs-dialog] {\n      max-width: 720px;\n    }\n  }\n\n  @media (min-width: 992px) {\n    [data-nextjs-dialog] {\n      max-width: 960px;\n    }\n  }\n\n  [data-nextjs-dialog-banner] {\n    position: relative;\n  }\n  [data-nextjs-dialog-banner].banner-warning {\n    border-color: var(--color-ansi-yellow);\n  }\n  [data-nextjs-dialog-banner].banner-error {\n    border-color: var(--color-ansi-red);\n  }\n\n  [data-nextjs-dialog-banner]::after {\n    z-index: 2;\n    content: '';\n    position: absolute;\n    top: 0;\n    right: 0;\n    width: 100%;\n    /* banner width: */\n    border-top-width: var(--size-gap-half);\n    border-bottom-width: 0;\n    border-top-style: solid;\n    border-bottom-style: solid;\n    border-top-color: inherit;\n    border-bottom-color: transparent;\n  }\n\n  [data-nextjs-dialog-content] {\n    overflow-y: auto;\n    border: none;\n    margin: 0;\n    /* calc(padding + banner width offset) */\n    padding: calc(var(--size-gap-double) + var(--size-gap-half))\n      var(--size-gap-double);\n    height: 100%;\n    display: flex;\n    flex-direction: column;\n  }\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-header] {\n    flex-shrink: 0;\n    margin-bottom: var(--size-gap-double);\n  }\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-body] {\n    position: relative;\n    flex: 1 1 auto;\n  }\n`;var k=__webpack_require__(/*! next/dist/compiled/platform */ \"./node_modules/next/dist/compiled/platform/platform.js\");var S=__nccwpck_require__.n(k);var _=__webpack_require__(/*! next/dist/compiled/css.escape */ \"./node_modules/next/dist/compiled/css.escape/css.escape.js\");var T=__nccwpck_require__.n(_);function nodeArray(e){if(!e){return[]}if(Array.isArray(e)){return e}if(e.nodeType!==undefined){return[e]}if(typeof e===\"string\"){e=document.querySelectorAll(e)}if(e.length!==undefined){return[].slice.call(e,0)}throw new TypeError(\"unexpected input \"+String(e))}function contextToElement(e){var t=e.context,r=e.label,n=r===undefined?\"context-to-element\":r,a=e.resolveDocument,o=e.defaultToDocument;var i=nodeArray(t)[0];if(a&&i&&i.nodeType===Node.DOCUMENT_NODE){i=i.documentElement}if(!i&&o){return document.documentElement}if(!i){throw new TypeError(n+\" requires valid options.context\")}if(i.nodeType!==Node.ELEMENT_NODE&&i.nodeType!==Node.DOCUMENT_FRAGMENT_NODE){throw new TypeError(n+\" requires options.context to be an Element\")}return i}function getShadowHost(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},t=e.context;var r=contextToElement({label:\"get/shadow-host\",context:t});var n=null;while(r){n=r;r=r.parentNode}if(n.nodeType===n.DOCUMENT_FRAGMENT_NODE&&n.host){return n.host}return null}function getDocument(e){if(!e){return document}if(e.nodeType===Node.DOCUMENT_NODE){return e}return e.ownerDocument||document}function isActiveElement(e){var t=contextToElement({label:\"is/active-element\",resolveDocument:true,context:e});var r=getDocument(t);if(r.activeElement===t){return true}var n=getShadowHost({context:t});if(n&&n.shadowRoot.activeElement===t){return true}return false}function getParents(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},t=e.context;var r=[];var n=contextToElement({label:\"get/parents\",context:t});while(n){r.push(n);n=n.parentNode;if(n&&n.nodeType!==Node.ELEMENT_NODE){n=null}}return r}var C=[\"matches\",\"webkitMatchesSelector\",\"mozMatchesSelector\",\"msMatchesSelector\"];var j=null;function findMethodName(e){C.some((function(t){if(!e[t]){return false}j=t;return true}))}function elementMatches(e,t){if(!j){findMethodName(e)}return e[j](t)}var A=JSON.parse(JSON.stringify(S()));var O=A.os.family||\"\";var N=O===\"Android\";var I=O.slice(0,7)===\"Windows\";var F=O===\"OS X\";var L=O===\"iOS\";var D=A.layout===\"Blink\";var M=A.layout===\"Gecko\";var R=A.layout===\"Trident\";var z=A.layout===\"EdgeHTML\";var B=A.layout===\"WebKit\";var H=parseFloat(A.version);var q=Math.floor(H);A.majorVersion=q;A.is={ANDROID:N,WINDOWS:I,OSX:F,IOS:L,BLINK:D,GECKO:M,TRIDENT:R,EDGE:z,WEBKIT:B,IE9:R&&q===9,IE10:R&&q===10,IE11:R&&q===11};function before(){var e={activeElement:document.activeElement,windowScrollTop:window.scrollTop,windowScrollLeft:window.scrollLeft,bodyScrollTop:document.body.scrollTop,bodyScrollLeft:document.body.scrollLeft};var t=document.createElement(\"iframe\");t.setAttribute(\"style\",\"position:absolute; position:fixed; top:0; left:-2px; width:1px; height:1px; overflow:hidden;\");t.setAttribute(\"aria-live\",\"off\");t.setAttribute(\"aria-busy\",\"true\");t.setAttribute(\"aria-hidden\",\"true\");document.body.appendChild(t);var r=t.contentWindow;var n=r.document;n.open();n.close();var a=n.createElement(\"div\");n.body.appendChild(a);e.iframe=t;e.wrapper=a;e.window=r;e.document=n;return e}function test(e,t){e.wrapper.innerHTML=\"\";var r=typeof t.element===\"string\"?e.document.createElement(t.element):t.element(e.wrapper,e.document);var n=t.mutate&&t.mutate(r,e.wrapper,e.document);if(!n&&n!==false){n=r}!r.parentNode&&e.wrapper.appendChild(r);n&&n.focus&&n.focus();return t.validate?t.validate(r,n,e.document):e.document.activeElement===n}function after(e){if(e.activeElement===document.body){document.activeElement&&document.activeElement.blur&&document.activeElement.blur();if(A.is.IE10){document.body.focus()}}else{e.activeElement&&e.activeElement.focus&&e.activeElement.focus()}document.body.removeChild(e.iframe);window.scrollTop=e.windowScrollTop;window.scrollLeft=e.windowScrollLeft;document.body.scrollTop=e.bodyScrollTop;document.body.scrollLeft=e.bodyScrollLeft}function detectFocus(e){var t=before();var r={};Object.keys(e).map((function(n){r[n]=test(t,e[n])}));after(t);return r}var P=\"1.4.1\";function readLocalStorage(e){var t=void 0;try{t=window.localStorage&&window.localStorage.getItem(e);t=t?JSON.parse(t):{}}catch(e){t={}}return t}function writeLocalStorage(e,t){if(!document.hasFocus()){try{window.localStorage&&window.localStorage.removeItem(e)}catch(e){}return}try{window.localStorage&&window.localStorage.setItem(e,JSON.stringify(t))}catch(e){}}var W=typeof window!==\"undefined\"&&window.navigator.userAgent||\"\";var V=\"ally-supports-cache\";var $=readLocalStorage(V);if($.userAgent!==W||$.version!==P){$={}}$.userAgent=W;$.version=P;var K={get:function get(){return $},set:function set(e){Object.keys(e).forEach((function(t){$[t]=e[t]}));$.time=(new Date).toISOString();writeLocalStorage(V,$)}};function cssShadowPiercingDeepCombinator(){var e=void 0;try{document.querySelector(\"html >>> :first-child\");e=\">>>\"}catch(t){try{document.querySelector(\"html /deep/ :first-child\");e=\"/deep/\"}catch(t){e=\"\"}}return e}var Z=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";var U={element:\"div\",mutate:function mutate(e){e.innerHTML='<map name=\"image-map-tabindex-test\">'+'<area shape=\"rect\" coords=\"63,19,144,45\"></map>'+'<img usemap=\"#image-map-tabindex-test\" tabindex=\"-1\" alt=\"\" src=\"'+Z+'\">';return e.querySelector(\"area\")}};var G={element:\"div\",mutate:function mutate(e){e.innerHTML='<map name=\"image-map-tabindex-test\">'+'<area href=\"#void\" tabindex=\"-1\" shape=\"rect\" coords=\"63,19,144,45\"></map>'+'<img usemap=\"#image-map-tabindex-test\" alt=\"\" src=\"'+Z+'\">';return false},validate:function validate(e,t,r){if(A.is.GECKO){return true}var n=e.querySelector(\"area\");n.focus();return r.activeElement===n}};var X={element:\"div\",mutate:function mutate(e){e.innerHTML='<map name=\"image-map-area-href-test\">'+'<area shape=\"rect\" coords=\"63,19,144,45\"></map>'+'<img usemap=\"#image-map-area-href-test\" alt=\"\" src=\"'+Z+'\">';return e.querySelector(\"area\")},validate:function validate(e,t,r){if(A.is.GECKO){return true}return r.activeElement===t}};var J={name:\"can-focus-audio-without-controls\",element:\"audio\",mutate:function mutate(e){try{e.setAttribute(\"src\",Z)}catch(e){}}};var Q=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\";var Y={element:\"div\",mutate:function mutate(e){e.innerHTML='<map name=\"broken-image-map-test\"><area href=\"#void\" shape=\"rect\" coords=\"63,19,144,45\"></map>'+'<img usemap=\"#broken-image-map-test\" alt=\"\" src=\"'+Q+'\">';return e.querySelector(\"area\")}};var ee={element:\"div\",mutate:function mutate(e){e.setAttribute(\"tabindex\",\"-1\");e.setAttribute(\"style\",\"display: -webkit-flex; display: -ms-flexbox; display: flex;\");e.innerHTML='<span style=\"display: block;\">hello</span>';return e.querySelector(\"span\")}};var te={element:\"fieldset\",mutate:function mutate(e){e.setAttribute(\"tabindex\",0);e.setAttribute(\"disabled\",\"disabled\")}};var re={element:\"fieldset\",mutate:function mutate(e){e.innerHTML=\"<legend>legend</legend><p>content</p>\"}};var ne={element:\"span\",mutate:function mutate(e){e.setAttribute(\"style\",\"display: -webkit-flex; display: -ms-flexbox; display: flex;\");e.innerHTML='<span style=\"display: block;\">hello</span>'}};var ae={element:\"form\",mutate:function mutate(e){e.setAttribute(\"tabindex\",0);e.setAttribute(\"disabled\",\"disabled\")}};var oe={element:\"a\",mutate:function mutate(e){e.href=\"#void\";e.innerHTML='<img ismap src=\"'+Z+'\" alt=\"\">';return e.querySelector(\"img\")}};var ie={element:\"div\",mutate:function mutate(e){e.innerHTML='<map name=\"image-map-tabindex-test\"><area href=\"#void\" shape=\"rect\" coords=\"63,19,144,45\"></map>'+'<img usemap=\"#image-map-tabindex-test\" tabindex=\"-1\" alt=\"\" '+'src=\"'+Z+'\">';return e.querySelector(\"img\")}};var le={element:function element(e,t){var r=t.createElement(\"iframe\");e.appendChild(r);var n=r.contentWindow.document;n.open();n.close();return r},mutate:function mutate(e){e.style.visibility=\"hidden\";var t=e.contentWindow.document;var r=t.createElement(\"input\");t.body.appendChild(r);return r},validate:function validate(e){var t=e.contentWindow.document;var r=t.querySelector(\"input\");return t.activeElement===r}};var se=!A.is.WEBKIT;function focusInZeroDimensionObject(){return se}var ue={element:\"div\",mutate:function mutate(e){e.setAttribute(\"tabindex\",\"invalid-value\")}};var ce={element:\"label\",mutate:function mutate(e){e.setAttribute(\"tabindex\",\"-1\")},validate:function validate(e,t,r){var n=e.offsetHeight;e.focus();return r.activeElement===e}};var de=\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtb\"+\"G5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBpZD0ic3ZnIj48dGV4dCB4PSIxMCIgeT0iMjAiIGlkPSJ\"+\"zdmctbGluay10ZXh0Ij50ZXh0PC90ZXh0Pjwvc3ZnPg==\";var fe={element:\"object\",mutate:function mutate(e){e.setAttribute(\"type\",\"image/svg+xml\");e.setAttribute(\"data\",de);e.setAttribute(\"width\",\"200\");e.setAttribute(\"height\",\"50\");e.style.visibility=\"hidden\"}};var me={name:\"can-focus-object-svg\",element:\"object\",mutate:function mutate(e){e.setAttribute(\"type\",\"image/svg+xml\");e.setAttribute(\"data\",de);e.setAttribute(\"width\",\"200\");e.setAttribute(\"height\",\"50\")},validate:function validate(e,t,r){if(A.is.GECKO){return true}return r.activeElement===e}};var pe=!A.is.IE9;function focusObjectSwf(){return pe}var be={element:\"div\",mutate:function mutate(e){e.innerHTML='<map name=\"focus-redirect-img-usemap\"><area href=\"#void\" shape=\"rect\" coords=\"63,19,144,45\"></map>'+'<img usemap=\"#focus-redirect-img-usemap\" alt=\"\" '+'src=\"'+Z+'\">';return e.querySelector(\"img\")},validate:function validate(e,t,r){var n=e.querySelector(\"area\");return r.activeElement===n}};var ve={element:\"fieldset\",mutate:function mutate(e){e.innerHTML='<legend>legend</legend><input tabindex=\"-1\"><input tabindex=\"0\">';return false},validate:function validate(e,t,r){var n=e.querySelector('input[tabindex=\"-1\"]');var a=e.querySelector('input[tabindex=\"0\"]');e.focus();e.querySelector(\"legend\").focus();return r.activeElement===n&&\"focusable\"||r.activeElement===a&&\"tabbable\"||\"\"}};var ge={element:\"div\",mutate:function mutate(e){e.setAttribute(\"style\",\"width: 100px; height: 50px; overflow: auto;\");e.innerHTML='<div style=\"width: 500px; height: 40px;\">scrollable content</div>';return e.querySelector(\"div\")}};var he={element:\"div\",mutate:function mutate(e){e.setAttribute(\"style\",\"width: 100px; height: 50px;\");e.innerHTML='<div style=\"width: 500px; height: 40px;\">scrollable content</div>'}};var xe={element:\"div\",mutate:function mutate(e){e.setAttribute(\"style\",\"width: 100px; height: 50px; overflow: auto;\");e.innerHTML='<div style=\"width: 500px; height: 40px;\">scrollable content</div>'}};var ye={element:\"details\",mutate:function mutate(e){e.innerHTML=\"<summary>foo</summary><p>content</p>\";return e.firstElementChild}};function makeFocusableForeignObject(){var e=document.createElementNS(\"http://www.w3.org/2000/svg\",\"foreignObject\");e.width.baseVal.value=30;e.height.baseVal.value=30;e.appendChild(document.createElement(\"input\"));e.lastChild.type=\"text\";return e}function focusSvgForeignObjectHack(e){var t=e.ownerSVGElement||e.nodeName.toLowerCase()===\"svg\";if(!t){return false}var r=makeFocusableForeignObject();e.appendChild(r);var n=r.querySelector(\"input\");n.focus();n.disabled=true;e.removeChild(r);return true}function generate(e){return'<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">'+e+\"</svg>\"}function maintain_tab_focus_focus(e){if(e.focus){return}try{HTMLElement.prototype.focus.call(e)}catch(t){focusSvgForeignObjectHack(e)}}function validate(e,t,r){maintain_tab_focus_focus(t);return r.activeElement===t}var Ee={element:\"div\",mutate:function mutate(e){e.innerHTML=generate('<text focusable=\"true\">a</text>');return e.querySelector(\"text\")},validate:validate};var we={element:\"div\",mutate:function mutate(e){e.innerHTML=generate('<text tabindex=\"0\">a</text>');return e.querySelector(\"text\")},validate:validate};var ke={element:\"div\",mutate:function mutate(e){e.innerHTML=generate('<text tabindex=\"-1\">a</text>');return e.querySelector(\"text\")},validate:validate};var Se={element:\"div\",mutate:function mutate(e){e.innerHTML=generate(['<g id=\"ally-test-target\"><a xlink:href=\"#void\"><text>link</text></a></g>','<use xlink:href=\"#ally-test-target\" x=\"0\" y=\"0\" tabindex=\"-1\" />'].join(\"\"));return e.querySelector(\"use\")},validate:validate};var _e={element:\"div\",mutate:function mutate(e){e.innerHTML=generate('<foreignObject tabindex=\"-1\"><input type=\"text\" /></foreignObject>');return e.querySelector(\"foreignObject\")||e.getElementsByTagName(\"foreignObject\")[0]},validate:validate};var Te=Boolean(A.is.GECKO&&typeof SVGElement!==\"undefined\"&&SVGElement.prototype.focus);function focusSvgInIframe(){return Te}var Ce={element:\"div\",mutate:function mutate(e){e.innerHTML=generate(\"\");return e.firstChild},validate:validate};var je={element:\"div\",mutate:function mutate(e){e.setAttribute(\"tabindex\",\"3x\")}};var Ae={element:\"table\",mutate:function mutate(e,t,r){var n=r.createDocumentFragment();n.innerHTML=\"<tr><td>cell</td></tr>\";e.appendChild(n)}};var Oe={element:\"video\",mutate:function mutate(e){try{e.setAttribute(\"src\",Z)}catch(e){}}};var Ne=A.is.GECKO||A.is.TRIDENT||A.is.EDGE;function tabsequenceAreaAtImgPosition(){return Ne}var Ie={cssShadowPiercingDeepCombinator:cssShadowPiercingDeepCombinator,focusInZeroDimensionObject:focusInZeroDimensionObject,focusObjectSwf:focusObjectSwf,focusSvgInIframe:focusSvgInIframe,tabsequenceAreaAtImgPosition:tabsequenceAreaAtImgPosition};var Fe={focusAreaImgTabindex:U,focusAreaTabindex:G,focusAreaWithoutHref:X,focusAudioWithoutControls:J,focusBrokenImageMap:Y,focusChildrenOfFocusableFlexbox:ee,focusFieldsetDisabled:te,focusFieldset:re,focusFlexboxContainer:ne,focusFormDisabled:ae,focusImgIsmap:oe,focusImgUsemapTabindex:ie,focusInHiddenIframe:le,focusInvalidTabindex:ue,focusLabelTabindex:ce,focusObjectSvg:me,focusObjectSvgHidden:fe,focusRedirectImgUsemap:be,focusRedirectLegend:ve,focusScrollBody:ge,focusScrollContainerWithoutOverflow:he,focusScrollContainer:xe,focusSummary:ye,focusSvgFocusableAttribute:Ee,focusSvgTabindexAttribute:we,focusSvgNegativeTabindexAttribute:ke,focusSvgUseTabindex:Se,focusSvgForeignobjectTabindex:_e,focusSvg:Ce,focusTabindexTrailingCharacters:je,focusTable:Ae,focusVideoWithoutControls:Oe};function executeTests(){var e=detectFocus(Fe);Object.keys(Ie).forEach((function(t){e[t]=Ie[t]()}));return e}var Le=null;function _supports(){if(Le){return Le}Le=K.get();if(!Le.time){K.set(executeTests());Le=K.get()}return Le}var De=void 0;var Me=/^\\s*(-|\\+)?[0-9]+\\s*$/;var Re=/^\\s*(-|\\+)?[0-9]+.*$/;function isValidTabindex(e){if(!De){De=_supports()}var t=De.focusTabindexTrailingCharacters?Re:Me;var r=contextToElement({label:\"is/valid-tabindex\",resolveDocument:true,context:e});var n=r.hasAttribute(\"tabindex\");var a=r.hasAttribute(\"tabIndex\");if(!n&&!a){return false}var o=r.ownerSVGElement||r.nodeName.toLowerCase()===\"svg\";if(o&&!De.focusSvgTabindexAttribute){return false}if(De.focusInvalidTabindex){return true}var i=r.getAttribute(n?\"tabindex\":\"tabIndex\");if(i===\"-32768\"){return false}return Boolean(i&&t.test(i))}function tabindexValue(e){if(!isValidTabindex(e)){return null}var t=e.hasAttribute(\"tabindex\");var r=t?\"tabindex\":\"tabIndex\";var n=parseInt(e.getAttribute(r),10);return isNaN(n)?-1:n}function isUserModifyWritable(e){var t=e.webkitUserModify||\"\";return Boolean(t&&t.indexOf(\"write\")!==-1)}function hasCssOverflowScroll(e){return[e.getPropertyValue(\"overflow\"),e.getPropertyValue(\"overflow-x\"),e.getPropertyValue(\"overflow-y\")].some((function(e){return e===\"auto\"||e===\"scroll\"}))}function hasCssDisplayFlex(e){return e.display.indexOf(\"flex\")>-1}function isScrollableContainer(e,t,r,n){if(t!==\"div\"&&t!==\"span\"){return false}if(r&&r!==\"div\"&&r!==\"span\"&&!hasCssOverflowScroll(n)){return false}return e.offsetHeight<e.scrollHeight||e.offsetWidth<e.scrollWidth}var ze=void 0;function isFocusRelevantRules(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},t=e.context,r=e.except,n=r===undefined?{flexbox:false,scrollable:false,shadow:false}:r;if(!ze){ze=_supports()}var a=contextToElement({label:\"is/focus-relevant\",resolveDocument:true,context:t});if(!n.shadow&&a.shadowRoot){return true}var o=a.nodeName.toLowerCase();if(o===\"input\"&&a.type===\"hidden\"){return false}if(o===\"input\"||o===\"select\"||o===\"button\"||o===\"textarea\"){return true}if(o===\"legend\"&&ze.focusRedirectLegend){return true}if(o===\"label\"){return true}if(o===\"area\"){return true}if(o===\"a\"&&a.hasAttribute(\"href\")){return true}if(o===\"object\"&&a.hasAttribute(\"usemap\")){return false}if(o===\"object\"){var i=a.getAttribute(\"type\");if(!ze.focusObjectSvg&&i===\"image/svg+xml\"){return false}else if(!ze.focusObjectSwf&&i===\"application/x-shockwave-flash\"){return false}}if(o===\"iframe\"||o===\"object\"){return true}if(o===\"embed\"||o===\"keygen\"){return true}if(a.hasAttribute(\"contenteditable\")){return true}if(o===\"audio\"&&(ze.focusAudioWithoutControls||a.hasAttribute(\"controls\"))){return true}if(o===\"video\"&&(ze.focusVideoWithoutControls||a.hasAttribute(\"controls\"))){return true}if(ze.focusSummary&&o===\"summary\"){return true}var l=isValidTabindex(a);if(o===\"img\"&&a.hasAttribute(\"usemap\")){return l&&ze.focusImgUsemapTabindex||ze.focusRedirectImgUsemap}if(ze.focusTable&&(o===\"table\"||o===\"td\")){return true}if(ze.focusFieldset&&o===\"fieldset\"){return true}var s=o===\"svg\";var u=a.ownerSVGElement;var c=a.getAttribute(\"focusable\");var d=tabindexValue(a);if(o===\"use\"&&d!==null&&!ze.focusSvgUseTabindex){return false}if(o===\"foreignobject\"){return d!==null&&ze.focusSvgForeignobjectTabindex}if(elementMatches(a,\"svg a\")&&a.hasAttribute(\"xlink:href\")){return true}if((s||u)&&a.focus&&!ze.focusSvgNegativeTabindexAttribute&&d<0){return false}if(s){return l||ze.focusSvg||ze.focusSvgInIframe||Boolean(ze.focusSvgFocusableAttribute&&c&&c===\"true\")}if(u){if(ze.focusSvgTabindexAttribute&&l){return true}if(ze.focusSvgFocusableAttribute){return c===\"true\"}}if(l){return true}var f=window.getComputedStyle(a,null);if(isUserModifyWritable(f)){return true}if(ze.focusImgIsmap&&o===\"img\"&&a.hasAttribute(\"ismap\")){var m=getParents({context:a}).some((function(e){return e.nodeName.toLowerCase()===\"a\"&&e.hasAttribute(\"href\")}));if(m){return true}}if(!n.scrollable&&ze.focusScrollContainer){if(ze.focusScrollContainerWithoutOverflow){if(isScrollableContainer(a,o)){return true}}else if(hasCssOverflowScroll(f)){return true}}if(!n.flexbox&&ze.focusFlexboxContainer&&hasCssDisplayFlex(f)){return true}var p=a.parentElement;if(!n.scrollable&&p){var b=p.nodeName.toLowerCase();var v=window.getComputedStyle(p,null);if(ze.focusScrollBody&&isScrollableContainer(p,o,b,v)){return true}if(ze.focusChildrenOfFocusableFlexbox){if(hasCssDisplayFlex(v)){return true}}}return false}isFocusRelevantRules.except=function(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var t=function isFocusRelevant(t){return isFocusRelevantRules({context:t,except:e})};t.rules=isFocusRelevantRules;return t};var Be=isFocusRelevantRules.except({});function findIndex(e,t){if(e.findIndex){return e.findIndex(t)}var r=e.length;if(r===0){return-1}for(var n=0;n<r;n++){if(t(e[n],n,e)){return n}}return-1}function getContentDocument(e){try{return e.contentDocument||e.contentWindow&&e.contentWindow.document||e.getSVGDocument&&e.getSVGDocument()||null}catch(e){return null}}function getWindow(e){var t=getDocument(e);return t.defaultView||window}var He=void 0;function selectInShadows(e){if(typeof He!==\"string\"){var t=cssShadowPiercingDeepCombinator();if(t){He=\", html \"+t+\" \"}}if(!He){return e}return e+He+e.replace(/\\s*,\\s*/g,\",\").split(\",\").join(He)}var qe=void 0;function findDocumentHostElement(e){if(!qe){qe=selectInShadows(\"object, iframe\")}if(e._frameElement!==undefined){return e._frameElement}e._frameElement=null;var t=e.parent.document.querySelectorAll(qe);[].some.call(t,(function(t){var r=getContentDocument(t);if(r!==e.document){return false}e._frameElement=t;return true}));return e._frameElement}function getFrameElement(e){var t=getWindow(e);if(!t.parent||t.parent===t){return null}try{return t.frameElement||findDocumentHostElement(t)}catch(e){return null}}var Pe=/^(area)$/;function computedStyle(e,t){return window.getComputedStyle(e,null).getPropertyValue(t)}function notDisplayed(e){return e.some((function(e){return computedStyle(e,\"display\")===\"none\"}))}function notVisible(e){var t=findIndex(e,(function(e){var t=computedStyle(e,\"visibility\");return t===\"hidden\"||t===\"collapse\"}));if(t===-1){return false}var r=findIndex(e,(function(e){return computedStyle(e,\"visibility\")===\"visible\"}));if(r===-1){return true}if(t<r){return true}return false}function collapsedParent(e){var t=1;if(e[0].nodeName.toLowerCase()===\"summary\"){t=2}return e.slice(t).some((function(e){return e.nodeName.toLowerCase()===\"details\"&&e.open===false}))}function isVisibleRules(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},t=e.context,r=e.except,n=r===undefined?{notRendered:false,cssDisplay:false,cssVisibility:false,detailsElement:false,browsingContext:false}:r;var a=contextToElement({label:\"is/visible\",resolveDocument:true,context:t});var o=a.nodeName.toLowerCase();if(!n.notRendered&&Pe.test(o)){return true}var i=getParents({context:a});var l=o===\"audio\"&&!a.hasAttribute(\"controls\");if(!n.cssDisplay&&notDisplayed(l?i.slice(1):i)){return false}if(!n.cssVisibility&&notVisible(i)){return false}if(!n.detailsElement&&collapsedParent(i)){return false}if(!n.browsingContext){var s=getFrameElement(a);var u=isVisibleRules.except(n);if(s&&!u(s)){return false}}return true}isVisibleRules.except=function(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var t=function isVisible(t){return isVisibleRules({context:t,except:e})};t.rules=isVisibleRules;return t};var We=isVisibleRules.except({});function getMapByName(e,t){var r=t.querySelector('map[name=\"'+T()(e)+'\"]');return r||null}function getImageOfArea(e){var t=e.parentElement;if(!t.name||t.nodeName.toLowerCase()!==\"map\"){return null}var r=getDocument(e);return r.querySelector('img[usemap=\"#'+T()(t.name)+'\"]')||null}var Ve=void 0;function isValidArea(e){if(!Ve){Ve=_supports()}var t=contextToElement({label:\"is/valid-area\",context:e});var r=t.nodeName.toLowerCase();if(r!==\"area\"){return false}var n=t.hasAttribute(\"tabindex\");if(!Ve.focusAreaTabindex&&n){return false}var a=getImageOfArea(t);if(!a||!We(a)){return false}if(!Ve.focusBrokenImageMap&&(!a.complete||!a.naturalHeight||a.offsetWidth<=0||a.offsetHeight<=0)){return false}if(!Ve.focusAreaWithoutHref&&!t.href){return Ve.focusAreaTabindex&&n||Ve.focusAreaImgTabindex&&a.hasAttribute(\"tabindex\")}var o=getParents({context:a}).slice(1).some((function(e){var t=e.nodeName.toLowerCase();return t===\"button\"||t===\"a\"}));if(o){return false}return true}var $e=void 0;var Ke=void 0;var Ze={input:true,select:true,textarea:true,button:true,fieldset:true,form:true};function isNativeDisabledSupported(e){if(!$e){$e=_supports();if($e.focusFieldsetDisabled){delete Ze.fieldset}if($e.focusFormDisabled){delete Ze.form}Ke=new RegExp(\"^(\"+Object.keys(Ze).join(\"|\")+\")$\")}var t=contextToElement({label:\"is/native-disabled-supported\",context:e});var r=t.nodeName.toLowerCase();return Boolean(Ke.test(r))}var Ue=void 0;function isDisabledFieldset(e){var t=e.nodeName.toLowerCase();return t===\"fieldset\"&&e.disabled}function isDisabledForm(e){var t=e.nodeName.toLowerCase();return t===\"form\"&&e.disabled}function isDisabled(e){if(!Ue){Ue=_supports()}var t=contextToElement({label:\"is/disabled\",context:e});if(t.hasAttribute(\"data-ally-disabled\")){return true}if(!isNativeDisabledSupported(t)){return false}if(t.disabled){return true}var r=getParents({context:t});if(r.some(isDisabledFieldset)){return true}if(!Ue.focusFormDisabled&&r.some(isDisabledForm)){return true}return false}function isOnlyTabbableRules(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},t=e.context,r=e.except,n=r===undefined?{onlyFocusableBrowsingContext:false,visible:false}:r;var a=contextToElement({label:\"is/only-tabbable\",resolveDocument:true,context:t});if(!n.visible&&!We(a)){return false}if(!n.onlyFocusableBrowsingContext&&(A.is.GECKO||A.is.TRIDENT||A.is.EDGE)){var o=getFrameElement(a);if(o){if(tabindexValue(o)<0){return false}}}var i=a.nodeName.toLowerCase();var l=tabindexValue(a);if(i===\"label\"&&A.is.GECKO){return l!==null&&l>=0}if(A.is.GECKO&&a.ownerSVGElement&&!a.focus){if(i===\"a\"&&a.hasAttribute(\"xlink:href\")){if(A.is.GECKO){return true}}}return false}isOnlyTabbableRules.except=function(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var t=function isOnlyTabbable(t){return isOnlyTabbableRules({context:t,except:e})};t.rules=isOnlyTabbableRules;return t};var Ge=isOnlyTabbableRules.except({});var Xe=void 0;function isOnlyFocusRelevant(e){var t=e.nodeName.toLowerCase();if(t===\"embed\"||t===\"keygen\"){return true}var r=tabindexValue(e);if(e.shadowRoot&&r===null){return true}if(t===\"label\"){return!Xe.focusLabelTabindex||r===null}if(t===\"legend\"){return r===null}if(Xe.focusSvgFocusableAttribute&&(e.ownerSVGElement||t===\"svg\")){var n=e.getAttribute(\"focusable\");return n&&n===\"false\"}if(t===\"img\"&&e.hasAttribute(\"usemap\")){return r===null||!Xe.focusImgUsemapTabindex}if(t===\"area\"){return!isValidArea(e)}return false}function isFocusableRules(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},t=e.context,r=e.except,n=r===undefined?{disabled:false,visible:false,onlyTabbable:false}:r;if(!Xe){Xe=_supports()}var a=Ge.rules.except({onlyFocusableBrowsingContext:true,visible:n.visible});var o=contextToElement({label:\"is/focusable\",resolveDocument:true,context:t});var i=Be.rules({context:o,except:n});if(!i||isOnlyFocusRelevant(o)){return false}if(!n.disabled&&isDisabled(o)){return false}if(!n.onlyTabbable&&a(o)){return false}if(!n.visible){var l={context:o,except:{}};if(Xe.focusInHiddenIframe){l.except.browsingContext=true}if(Xe.focusObjectSvgHidden){var s=o.nodeName.toLowerCase();if(s===\"object\"){l.except.cssVisibility=true}}if(!We.rules(l)){return false}}var u=getFrameElement(o);if(u){var c=u.nodeName.toLowerCase();if(c===\"object\"&&!Xe.focusInZeroDimensionObject){if(!u.offsetWidth||!u.offsetHeight){return false}}}var d=o.nodeName.toLowerCase();if(d===\"svg\"&&Xe.focusSvgInIframe&&!u&&o.getAttribute(\"tabindex\")===null){return false}return true}isFocusableRules.except=function(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var t=function isFocusable(t){return isFocusableRules({context:t,except:e})};t.rules=isFocusableRules;return t};var Je=isFocusableRules.except({});function createFilter(e){var t=function filter(t){if(t.shadowRoot){return NodeFilter.FILTER_ACCEPT}if(e(t)){return NodeFilter.FILTER_ACCEPT}return NodeFilter.FILTER_SKIP};t.acceptNode=t;return t}var Qe=createFilter(Be);function queryFocusableStrict(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},t=e.context,r=e.includeContext,n=e.includeOnlyTabbable,a=e.strategy;if(!t){t=document.documentElement}var o=Je.rules.except({onlyTabbable:n});var i=getDocument(t);var l=i.createTreeWalker(t,NodeFilter.SHOW_ELEMENT,a===\"all\"?Qe:createFilter(o),false);var s=[];while(l.nextNode()){if(l.currentNode.shadowRoot){if(o(l.currentNode)){s.push(l.currentNode)}s=s.concat(queryFocusableStrict({context:l.currentNode.shadowRoot,includeOnlyTabbable:n,strategy:a}))}else{s.push(l.currentNode)}}if(r){if(a===\"all\"){if(Be(t)){s.unshift(t)}}else if(o(t)){s.unshift(t)}}return s}var Ye=void 0;var et=void 0;function selector$2(){if(!Ye){Ye=_supports()}if(typeof et===\"string\"){return et}et=\"\"+(Ye.focusTable?\"table, td,\":\"\")+(Ye.focusFieldset?\"fieldset,\":\"\")+\"svg a,\"+\"a[href],\"+\"area[href],\"+\"input, select, textarea, button,\"+\"iframe, object, embed,\"+\"keygen,\"+(Ye.focusAudioWithoutControls?\"audio,\":\"audio[controls],\")+(Ye.focusVideoWithoutControls?\"video,\":\"video[controls],\")+(Ye.focusSummary?\"summary,\":\"\")+\"[tabindex],\"+\"[contenteditable]\";et=selectInShadows(et);return et}function queryFocusableQuick(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},t=e.context,r=e.includeContext,n=e.includeOnlyTabbable;var a=selector$2();var o=t.querySelectorAll(a);var i=Je.rules.except({onlyTabbable:n});var l=[].filter.call(o,i);if(r&&i(t)){l.unshift(t)}return l}function queryFocusable(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},t=e.context,r=e.includeContext,n=e.includeOnlyTabbable,a=e.strategy,o=a===undefined?\"quick\":a;var i=contextToElement({label:\"query/focusable\",resolveDocument:true,defaultToDocument:true,context:t});var l={context:i,includeContext:r,includeOnlyTabbable:n,strategy:o};if(o===\"quick\"){return queryFocusableQuick(l)}else if(o===\"strict\"||o===\"all\"){return queryFocusableStrict(l)}throw new TypeError('query/focusable requires option.strategy to be one of [\"quick\", \"strict\", \"all\"]')}var tt=void 0;var rt=/^(fieldset|table|td|body)$/;function isTabbableRules(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},t=e.context,r=e.except,n=r===undefined?{flexbox:false,scrollable:false,shadow:false,visible:false,onlyTabbable:false}:r;if(!tt){tt=_supports()}var a=contextToElement({label:\"is/tabbable\",resolveDocument:true,context:t});if(A.is.BLINK&&A.is.ANDROID&&A.majorVersion>42){return false}var o=getFrameElement(a);if(o){if(A.is.WEBKIT&&A.is.IOS){return false}if(tabindexValue(o)<0){return false}if(!n.visible&&(A.is.BLINK||A.is.WEBKIT)&&!We(o)){return false}var i=o.nodeName.toLowerCase();if(i===\"object\"){var l=A.name===\"Chrome\"&&A.majorVersion>=54||A.name===\"Opera\"&&A.majorVersion>=41;if(A.is.WEBKIT||A.is.BLINK&&!l){return false}}}var s=a.nodeName.toLowerCase();var u=tabindexValue(a);var c=u===null?null:u>=0;if(A.is.EDGE&&A.majorVersion>=14&&o&&a.ownerSVGElement&&u<0){return true}var d=c!==false;var f=u!==null&&u>=0;if(a.hasAttribute(\"contenteditable\")){return d}if(rt.test(s)&&c!==true){return false}if(A.is.WEBKIT&&A.is.IOS){var m=s===\"input\"&&a.type===\"text\"||a.type===\"password\"||s===\"select\"||s===\"textarea\"||a.hasAttribute(\"contenteditable\");if(!m){var p=window.getComputedStyle(a,null);m=isUserModifyWritable(p)}if(!m){return false}}if(s===\"use\"&&u!==null){if(A.is.BLINK||A.is.WEBKIT&&A.majorVersion===9){return true}}if(elementMatches(a,\"svg a\")&&a.hasAttribute(\"xlink:href\")){if(d){return true}if(a.focus&&!tt.focusSvgNegativeTabindexAttribute){return true}}if(s===\"svg\"&&tt.focusSvgInIframe&&d){return true}if(A.is.TRIDENT||A.is.EDGE){if(s===\"svg\"){if(tt.focusSvg){return true}return a.hasAttribute(\"focusable\")||f}if(a.ownerSVGElement){if(tt.focusSvgTabindexAttribute&&f){return true}return a.hasAttribute(\"focusable\")}}if(a.tabIndex===undefined){return Boolean(n.onlyTabbable)}if(s===\"audio\"){if(!a.hasAttribute(\"controls\")){return false}else if(A.is.BLINK){return true}}if(s===\"video\"){if(!a.hasAttribute(\"controls\")){if(A.is.TRIDENT||A.is.EDGE){return false}}else if(A.is.BLINK||A.is.GECKO){return true}}if(s===\"object\"){if(A.is.BLINK||A.is.WEBKIT){return false}}if(s===\"iframe\"){return false}if(!n.scrollable&&A.is.GECKO){var b=window.getComputedStyle(a,null);if(hasCssOverflowScroll(b)){return d}}if(A.is.TRIDENT||A.is.EDGE){if(s===\"area\"){var v=getImageOfArea(a);if(v&&tabindexValue(v)<0){return false}}var g=window.getComputedStyle(a,null);if(isUserModifyWritable(g)){return a.tabIndex>=0}if(!n.flexbox&&hasCssDisplayFlex(g)){if(u!==null){return f}return nt(a)&&at(a)}if(isScrollableContainer(a,s)){return false}var h=a.parentElement;if(h){var x=h.nodeName.toLowerCase();var y=window.getComputedStyle(h,null);if(isScrollableContainer(h,s,x,y)){return false}if(hasCssDisplayFlex(y)){return f}}}return a.tabIndex>=0}isTabbableRules.except=function(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var t=function isTabbable(t){return isTabbableRules({context:t,except:e})};t.rules=isTabbableRules;return t};var nt=Be.rules.except({flexbox:true});var at=isTabbableRules.except({flexbox:true});var ot=isTabbableRules.except({});function queryTabbable(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},t=e.context,r=e.includeContext,n=e.includeOnlyTabbable,a=e.strategy;var o=ot.rules.except({onlyTabbable:n});return queryFocusable({context:t,includeContext:r,includeOnlyTabbable:n,strategy:a}).filter(o)}function compareDomPosition(e,t){return e.compareDocumentPosition(t)&Node.DOCUMENT_POSITION_FOLLOWING?-1:1}function sortDomOrder(e){return e.sort(compareDomPosition)}function getFirstSuccessorOffset(e,t){return findIndex(e,(function(e){return t.compareDocumentPosition(e)&Node.DOCUMENT_POSITION_FOLLOWING}))}function findInsertionOffsets(e,t,r){var n=[];t.forEach((function(t){var a=true;var o=e.indexOf(t);if(o===-1){o=getFirstSuccessorOffset(e,t);a=false}if(o===-1){o=e.length}var i=nodeArray(r?r(t):t);if(!i.length){return}n.push({offset:o,replace:a,elements:i})}));return n}function insertElementsAtOffsets(e,t){var r=0;t.sort((function(e,t){return e.offset-t.offset}));t.forEach((function(t){var n=t.replace?1:0;var a=[t.offset+r,n].concat(t.elements);e.splice.apply(e,a);r+=t.elements.length-n}))}function mergeInDomOrder(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},t=e.list,r=e.elements,n=e.resolveElement;var a=t.slice(0);var o=nodeArray(r).slice(0);sortDomOrder(o);var i=findInsertionOffsets(a,o,n);insertElementsAtOffsets(a,i);return a}var it=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||false;n.configurable=true;if(\"value\"in n)n.writable=true;Object.defineProperty(e,n.key,n)}}return function(e,t,r){if(t)defineProperties(e.prototype,t);if(r)defineProperties(e,r);return e}}();function _classCallCheck(e,t){if(!(e instanceof t)){throw new TypeError(\"Cannot call a class as a function\")}}var lt=function(){function Maps(e){_classCallCheck(this,Maps);this._document=getDocument(e);this.maps={}}it(Maps,[{key:\"getAreasFor\",value:function getAreasFor(e){if(!this.maps[e]){this.addMapByName(e)}return this.maps[e]}},{key:\"addMapByName\",value:function addMapByName(e){var t=getMapByName(e,this._document);if(!t){return}this.maps[t.name]=queryTabbable({context:t})}},{key:\"extractAreasFromList\",value:function extractAreasFromList(e){return e.filter((function(e){var t=e.nodeName.toLowerCase();if(t!==\"area\"){return true}var r=e.parentNode;if(!this.maps[r.name]){this.maps[r.name]=[]}this.maps[r.name].push(e);return false}),this)}}]);return Maps}();function sortArea(e,t){var r=t.querySelectorAll(\"img[usemap]\");var n=new lt(t);var a=n.extractAreasFromList(e);if(!r.length){return a}return mergeInDomOrder({list:a,elements:r,resolveElement:function resolveElement(e){var t=e.getAttribute(\"usemap\").slice(1);return n.getAreasFor(t)}})}var st=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||false;n.configurable=true;if(\"value\"in n)n.writable=true;Object.defineProperty(e,n.key,n)}}return function(e,t,r){if(t)defineProperties(e.prototype,t);if(r)defineProperties(e,r);return e}}();function _classCallCheck$1(e,t){if(!(e instanceof t)){throw new TypeError(\"Cannot call a class as a function\")}}var ut=function(){function Shadows(e,t){_classCallCheck$1(this,Shadows);this.context=e;this.sortElements=t;this.hostCounter=1;this.inHost={};this.inDocument=[];this.hosts={};this.elements={}}st(Shadows,[{key:\"_registerHost\",value:function _registerHost(e){if(e._sortingId){return}e._sortingId=\"shadow-\"+this.hostCounter++;this.hosts[e._sortingId]=e;var t=getShadowHost({context:e});if(t){this._registerHost(t);this._registerHostParent(e,t)}else{this.inDocument.push(e)}}},{key:\"_registerHostParent\",value:function _registerHostParent(e,t){if(!this.inHost[t._sortingId]){this.inHost[t._sortingId]=[]}this.inHost[t._sortingId].push(e)}},{key:\"_registerElement\",value:function _registerElement(e,t){if(!this.elements[t._sortingId]){this.elements[t._sortingId]=[]}this.elements[t._sortingId].push(e)}},{key:\"extractElements\",value:function extractElements(e){return e.filter((function(e){var t=getShadowHost({context:e});if(!t){return true}this._registerHost(t);this._registerElement(e,t);return false}),this)}},{key:\"sort\",value:function sort(e){var t=this._injectHosts(e);t=this._replaceHosts(t);this._cleanup();return t}},{key:\"_injectHosts\",value:function _injectHosts(e){Object.keys(this.hosts).forEach((function(e){var t=this.elements[e];var r=this.inHost[e];var n=this.hosts[e].shadowRoot;this.elements[e]=this._merge(t,r,n)}),this);return this._merge(e,this.inDocument,this.context)}},{key:\"_merge\",value:function _merge(e,t,r){var n=mergeInDomOrder({list:e,elements:t});return this.sortElements(n,r)}},{key:\"_replaceHosts\",value:function _replaceHosts(e){return mergeInDomOrder({list:e,elements:this.inDocument,resolveElement:this._resolveHostElement.bind(this)})}},{key:\"_resolveHostElement\",value:function _resolveHostElement(e){var t=mergeInDomOrder({list:this.elements[e._sortingId],elements:this.inHost[e._sortingId],resolveElement:this._resolveHostElement.bind(this)});var r=tabindexValue(e);if(r!==null&&r>-1){return[e].concat(t)}return t}},{key:\"_cleanup\",value:function _cleanup(){Object.keys(this.hosts).forEach((function(e){delete this.hosts[e]._sortingId}),this)}}]);return Shadows}();function sortShadowed(e,t,r){var n=new ut(t,r);var a=n.extractElements(e);if(a.length===e.length){return r(e)}return n.sort(a)}function sortTabindex(e){var t={};var r=[];var n=e.filter((function(e){var n=e.tabIndex;if(n===undefined){n=tabindexValue(e)}if(n<=0||n===null||n===undefined){return true}if(!t[n]){t[n]=[];r.push(n)}t[n].push(e);return false}));var a=r.sort().map((function(e){return t[e]})).reduceRight((function(e,t){return t.concat(e)}),n);return a}var ct=void 0;function moveContextToBeginning(e,t){var r=e.indexOf(t);if(r>0){var n=e.splice(r,1);return n.concat(e)}return e}function sortElements(e,t){if(ct.tabsequenceAreaAtImgPosition){e=sortArea(e,t)}e=sortTabindex(e);return e}function queryTabsequence(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},t=e.context,r=e.includeContext,n=e.includeOnlyTabbable,a=e.strategy;if(!ct){ct=_supports()}var o=nodeArray(t)[0]||document.documentElement;var i=queryTabbable({context:o,includeContext:r,includeOnlyTabbable:n,strategy:a});if(document.body.createShadowRoot&&A.is.BLINK){i=sortShadowed(i,o,sortElements)}else{i=sortElements(i,o)}if(r){i=moveContextToBeginning(i,o)}return i}var dt={tab:9,left:37,up:38,right:39,down:40,pageUp:33,\"page-up\":33,pageDown:34,\"page-down\":34,end:35,home:36,enter:13,escape:27,space:32,shift:16,capsLock:20,\"caps-lock\":20,ctrl:17,alt:18,meta:91,pause:19,insert:45,delete:46,backspace:8,_alias:{91:[92,93,224]}};for(var ft=1;ft<26;ft++){dt[\"f\"+ft]=ft+111}for(var mt=0;mt<10;mt++){var pt=mt+48;var bt=mt+96;dt[mt]=pt;dt[\"num-\"+mt]=bt;dt._alias[pt]=[bt]}for(var vt=0;vt<26;vt++){var gt=vt+65;var ht=String.fromCharCode(gt).toLowerCase();dt[ht]=gt}var xt={alt:\"altKey\",ctrl:\"ctrlKey\",meta:\"metaKey\",shift:\"shiftKey\"};var yt=Object.keys(xt).map((function(e){return xt[e]}));function createExpectedModifiers(e){var t=e?null:false;return{altKey:t,ctrlKey:t,metaKey:t,shiftKey:t}}function resolveModifiers(e){var t=e.indexOf(\"*\")!==-1;var r=createExpectedModifiers(t);e.forEach((function(e){if(e===\"*\"){return}var t=true;var n=e.slice(0,1);if(n===\"?\"){t=null}else if(n===\"!\"){t=false}if(t!==true){e=e.slice(1)}var a=xt[e];if(!a){throw new TypeError('Unknown modifier \"'+e+'\"')}r[a]=t}));return r}function resolveKey(e){var t=dt[e]||parseInt(e,10);if(!t||typeof t!==\"number\"||isNaN(t)){throw new TypeError('Unknown key \"'+e+'\"')}return[t].concat(dt._alias[t]||[])}function matchModifiers(e,t){return!yt.some((function(r){return typeof e[r]===\"boolean\"&&Boolean(t[r])!==e[r]}))}function keyBinding(e){return e.split(/\\s+/).map((function(e){var t=e.split(\"+\");var r=resolveModifiers(t.slice(0,-1));var n=resolveKey(t.slice(-1));return{keyCodes:n,modifiers:r,matchModifiers:matchModifiers.bind(null,r)}}))}function getParentComparator(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},t=e.parent,r=e.element,n=e.includeSelf;if(t){return function isChildOf(e){return Boolean(n&&e===t||t.compareDocumentPosition(e)&Node.DOCUMENT_POSITION_CONTAINED_BY)}}else if(r){return function isParentOf(e){return Boolean(n&&r===e||e.compareDocumentPosition(r)&Node.DOCUMENT_POSITION_CONTAINED_BY)}}throw new TypeError(\"util/compare-position#getParentComparator required either options.parent or options.element\")}function whenKey(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var t={};var r=nodeArray(e.context)[0]||document.documentElement;delete e.context;var n=nodeArray(e.filter);delete e.filter;var a=Object.keys(e);if(!a.length){throw new TypeError(\"when/key requires at least one option key\")}var o=function registerBinding(e){e.keyCodes.forEach((function(r){if(!t[r]){t[r]=[]}t[r].push(e)}))};a.forEach((function(t){if(typeof e[t]!==\"function\"){throw new TypeError('when/key requires option[\"'+t+'\"] to be a function')}var r=function addCallback(r){r.callback=e[t];return r};keyBinding(t).map(r).forEach(o)}));var i=function handleKeyDown(e){if(e.defaultPrevented){return}if(n.length){var a=getParentComparator({element:e.target,includeSelf:true});if(n.some(a)){return}}var o=e.keyCode||e.which;if(!t[o]){return}t[o].forEach((function(t){if(!t.matchModifiers(e)){return}t.callback.call(r,e,l)}))};r.addEventListener(\"keydown\",i,false);var l=function disengage(){r.removeEventListener(\"keydown\",i,false)};return{disengage:l}}function maintain_tab_focus({context:e}={}){if(!e){e=document.documentElement}queryTabsequence();return whenKey({\"?alt+?shift+tab\":function altShiftTab(t){t.preventDefault();var r=queryTabsequence({context:e});var n=t.shiftKey;var a=r[0];var o=r[r.length-1];var i=n?a:o;var l=n?o:a;if(isActiveElement(i)){l.focus();return}var s=void 0;var u=r.some((function(e,t){if(!isActiveElement(e)){return false}s=t;return true}));if(!u){a.focus();return}var c=n?-1:1;r[s+c].focus()}})}let Et;let wt;let kt=0;function lock(){setTimeout((()=>{if(kt++>0){return}const e=window.innerWidth-document.documentElement.clientWidth;if(e>0){Et=document.body.style.paddingRight;document.body.style.paddingRight=`${e}px`}wt=document.body.style.overflow;document.body.style.overflow=\"hidden\"}))}function unlock(){setTimeout((()=>{if(kt===0||--kt!==0){return}if(Et!==undefined){document.body.style.paddingRight=Et;Et=undefined}if(wt!==undefined){document.body.style.overflow=wt;wt=undefined}}))}const St=function Overlay({className:e,children:t,fixed:r}){p.useEffect((()=>{lock();return()=>{unlock()}}),[]);const[n,a]=p.useState(null);const o=p.useCallback((e=>{a(e)}),[]);p.useEffect((()=>{if(n==null){return}const e=maintain_tab_focus({context:n});return()=>{e.disengage()}}),[n]);return p.createElement(\"div\",{\"data-nextjs-dialog-overlay\":true,className:e,ref:o},p.createElement(\"div\",{\"data-nextjs-dialog-backdrop\":true,\"data-nextjs-dialog-backdrop-fixed\":r?true:undefined}),t)};var _t=__webpack_require__(/*! next/dist/compiled/anser */ \"./node_modules/next/dist/compiled/anser/index.js\");var Tt=__nccwpck_require__.n(_t);const Ct=function Terminal({content:e}){const t=p.useMemo((()=>Tt().ansiToJson(e,{json:true,use_classes:true,remove_empty:true})),[e]);return p.createElement(\"div\",{\"data-nextjs-terminal\":true},p.createElement(\"pre\",null,t.map(((e,t)=>p.createElement(\"span\",{key:`terminal-entry-${t}`,style:{color:e.fg?`var(--color-${e.fg})`:undefined,...e.decoration===\"bold\"?{fontWeight:800}:e.decoration===\"italic\"?{fontStyle:\"italic\"}:undefined}},e.content)))))};const jt=function BuildError({message:e}){const t=p.useCallback((()=>{}),[]);return p.createElement(St,{fixed:true},p.createElement(h,{type:\"error\",\"aria-labelledby\":\"nextjs__container_build_error_label\",\"aria-describedby\":\"nextjs__container_build_error_desc\",onClose:t},p.createElement(y,null,p.createElement(E,{className:\"nextjs-container-build-error-header\"},p.createElement(\"h4\",{id:\"nextjs__container_build_error_label\"},\"Failed to compile\")),p.createElement(x,{className:\"nextjs-container-build-error-body\"},p.createElement(Ct,{content:e}),p.createElement(\"footer\",null,p.createElement(\"p\",{id:\"nextjs__container_build_error_desc\"},p.createElement(\"small\",null,\"This error occurred during the build process and can only be dismissed by fixing the error.\")))))))};const At=noop`\n  .nextjs-container-build-error-header > h4 {\n    line-height: 1.5;\n    margin: 0;\n    padding: 0;\n  }\n\n  .nextjs-container-build-error-body footer {\n    margin-top: var(--size-gap);\n  }\n  .nextjs-container-build-error-body footer p {\n    margin: 0;\n  }\n\n  .nextjs-container-build-error-body small {\n    color: var(--color-font);\n  }\n`;const CloseIcon=()=>p.createElement(\"svg\",{width:\"24\",height:\"24\",viewBox:\"0 0 24 24\",fill:\"none\",xmlns:\"http://www.w3.org/2000/svg\"},p.createElement(\"path\",{d:\"M18 6L6 18\",stroke:\"currentColor\",strokeWidth:\"2\",strokeLinecap:\"round\",strokeLinejoin:\"round\"}),p.createElement(\"path\",{d:\"M6 6L18 18\",stroke:\"currentColor\",strokeWidth:\"2\",strokeLinecap:\"round\",strokeLinejoin:\"round\"}));const Ot=function LeftRightDialogHeader({children:e,className:t,previous:r,next:n,close:a}){const o=p.useRef(null);const i=p.useRef(null);const l=p.useRef(null);const[s,u]=p.useState(null);const c=p.useCallback((e=>{u(e)}),[]);p.useEffect((()=>{if(s==null){return}const e=s.getRootNode();const t=self.document;function handler(t){if(t.key===\"ArrowLeft\"){t.stopPropagation();if(o.current){o.current.focus()}r&&r()}else if(t.key===\"ArrowRight\"){t.stopPropagation();if(i.current){i.current.focus()}n&&n()}else if(t.key===\"Escape\"){t.stopPropagation();if(e instanceof ShadowRoot){const t=e.activeElement;if(t&&t!==l.current&&t instanceof HTMLElement){t.blur();return}}if(a){a()}}}e.addEventListener(\"keydown\",handler);if(e!==t){t.addEventListener(\"keydown\",handler)}return function(){e.removeEventListener(\"keydown\",handler);if(e!==t){t.removeEventListener(\"keydown\",handler)}}}),[a,s,n,r]);p.useEffect((()=>{if(s==null){return}const e=s.getRootNode();if(e instanceof ShadowRoot){const t=e.activeElement;if(r==null){if(o.current&&t===o.current){o.current.blur()}}else if(n==null){if(i.current&&t===i.current){i.current.blur()}}}}),[s,n,r]);return p.createElement(\"div\",{\"data-nextjs-dialog-left-right\":true,className:t},p.createElement(\"nav\",{ref:c},p.createElement(\"button\",{ref:o,type:\"button\",disabled:r==null?true:undefined,\"aria-disabled\":r==null?true:undefined,onClick:r??undefined},p.createElement(\"svg\",{viewBox:\"0 0 14 14\",fill:\"none\",xmlns:\"http://www.w3.org/2000/svg\"},p.createElement(\"title\",null,\"previous\"),p.createElement(\"path\",{d:\"M6.99996 1.16666L1.16663 6.99999L6.99996 12.8333M12.8333 6.99999H1.99996H12.8333Z\",stroke:\"currentColor\",strokeWidth:\"2\",strokeLinecap:\"round\",strokeLinejoin:\"round\"}))),p.createElement(\"button\",{ref:i,type:\"button\",disabled:n==null?true:undefined,\"aria-disabled\":n==null?true:undefined,onClick:n??undefined},p.createElement(\"svg\",{viewBox:\"0 0 14 14\",fill:\"none\",xmlns:\"http://www.w3.org/2000/svg\"},p.createElement(\"title\",null,\"next\"),p.createElement(\"path\",{d:\"M6.99996 1.16666L12.8333 6.99999L6.99996 12.8333M1.16663 6.99999H12H1.16663Z\",stroke:\"currentColor\",strokeWidth:\"2\",strokeLinecap:\"round\",strokeLinejoin:\"round\"}))),\"\",e),a?p.createElement(\"button\",{\"data-nextjs-errors-dialog-left-right-close-button\":true,ref:l,type:\"button\",onClick:a,\"aria-label\":\"Close\"},p.createElement(\"span\",{\"aria-hidden\":\"true\"},p.createElement(CloseIcon,null))):null)};const Nt=noop`\n  [data-nextjs-dialog-left-right] {\n    display: flex;\n    flex-direction: row;\n    align-content: center;\n    align-items: center;\n    justify-content: space-between;\n  }\n  [data-nextjs-dialog-left-right] > nav > button {\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n\n    width: calc(var(--size-gap-double) + var(--size-gap));\n    height: calc(var(--size-gap-double) + var(--size-gap));\n    font-size: 0;\n    border: none;\n    background-color: rgba(255, 85, 85, 0.1);\n    color: var(--color-ansi-red);\n    cursor: pointer;\n    transition: background-color 0.25s ease;\n  }\n  [data-nextjs-dialog-left-right] > nav > button > svg {\n    width: auto;\n    height: calc(var(--size-gap) + var(--size-gap-half));\n  }\n  [data-nextjs-dialog-left-right] > nav > button:hover {\n    background-color: rgba(255, 85, 85, 0.2);\n  }\n  [data-nextjs-dialog-left-right] > nav > button:disabled {\n    background-color: rgba(255, 85, 85, 0.1);\n    color: rgba(255, 85, 85, 0.4);\n    cursor: not-allowed;\n  }\n\n  [data-nextjs-dialog-left-right] > nav > button:first-of-type {\n    border-radius: var(--size-gap-half) 0 0 var(--size-gap-half);\n    margin-right: 1px;\n  }\n  [data-nextjs-dialog-left-right] > nav > button:last-of-type {\n    border-radius: 0 var(--size-gap-half) var(--size-gap-half) 0;\n  }\n\n  [data-nextjs-dialog-left-right] > button:last-of-type {\n    border: 0;\n    padding: 0;\n\n    background-color: transparent;\n    appearance: none;\n\n    opacity: 0.4;\n    transition: opacity 0.25s ease;\n\n    color: var(--color-font);\n  }\n  [data-nextjs-dialog-left-right] > button:last-of-type:hover {\n    opacity: 0.7;\n  }\n`;const It=noop`\n  [data-nextjs-toast] {\n    position: fixed;\n    bottom: var(--size-gap-double);\n    left: var(--size-gap-double);\n    max-width: 420px;\n    z-index: 9000;\n  }\n\n  @media (max-width: 440px) {\n    [data-nextjs-toast] {\n      max-width: 90vw;\n      left: 5vw;\n    }\n  }\n\n  [data-nextjs-toast-wrapper] {\n    padding: 16px;\n    border-radius: var(--size-gap-half);\n    font-weight: 500;\n    color: var(--color-ansi-bright-white);\n    background-color: var(--color-ansi-red);\n    box-shadow: 0px var(--size-gap-double) var(--size-gap-quad)\n      rgba(0, 0, 0, 0.25);\n  }\n`;const Ft=function Toast({onClick:e,children:t,className:r}){return p.createElement(\"div\",{\"data-nextjs-toast\":true,onClick:e,className:r},p.createElement(\"div\",{\"data-nextjs-toast-wrapper\":true},t))};var Lt=__webpack_require__(/*! next/dist/compiled/strip-ansi */ \"./node_modules/next/dist/compiled/strip-ansi/index.js\");var Dt=__nccwpck_require__.n(Lt);const Mt=function CodeFrame({stackFrame:e,codeFrame:t}){const r=p.useMemo((()=>{const e=t.split(/\\r?\\n/g);const r=e.map((e=>/^>? +\\d+ +\\| [ ]+/.exec(Dt()(e))===null?null:/^>? +\\d+ +\\| ( *)/.exec(Dt()(e)))).filter(Boolean).map((e=>e.pop())).reduce(((e,t)=>isNaN(e)?t.length:Math.min(e,t.length)),NaN);if(r>1){const t=\" \".repeat(r);return e.map(((e,r)=>~(r=e.indexOf(\"|\"))?e.substring(0,r)+e.substring(r).replace(t,\"\"):e)).join(\"\\n\")}return e.join(\"\\n\")}),[t]);const n=p.useMemo((()=>Tt().ansiToJson(r,{json:true,use_classes:true,remove_empty:true})),[r]);const a=p.useCallback((()=>{const t=new URLSearchParams;for(const r in e){t.append(r,(e[r]??\"\").toString())}self.fetch(`${ false||\"\"}/__nextjs_launch-editor?${t.toString()}`).then((()=>{}),(()=>{console.error(\"There was an issue opening this code in your editor.\")}))}),[e]);return p.createElement(\"div\",{\"data-nextjs-codeframe\":true},p.createElement(\"div\",null,p.createElement(\"p\",{role:\"link\",onClick:a,tabIndex:1,title:\"Click to open in your editor\"},p.createElement(\"span\",null,getFrameSource(e),\" @ \",e.methodName),p.createElement(\"svg\",{xmlns:\"http://www.w3.org/2000/svg\",viewBox:\"0 0 24 24\",fill:\"none\",stroke:\"currentColor\",strokeWidth:\"2\",strokeLinecap:\"round\",strokeLinejoin:\"round\"},p.createElement(\"path\",{d:\"M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6\"}),p.createElement(\"polyline\",{points:\"15 3 21 3 21 9\"}),p.createElement(\"line\",{x1:\"10\",y1:\"14\",x2:\"21\",y2:\"3\"})))),p.createElement(\"pre\",null,n.map(((e,t)=>p.createElement(\"span\",{key:`frame-${t}`,style:{color:e.fg?`var(--color-${e.fg})`:undefined,...e.decoration===\"bold\"?{fontWeight:800}:e.decoration===\"italic\"?{fontStyle:\"italic\"}:undefined}},e.content)))))};const Rt=function CallStackFrame({frame:e}){const t=e.originalStackFrame??e.sourceStackFrame;const r=Boolean(e.originalCodeFrame);const n=p.useCallback((()=>{if(!r)return;const e=new URLSearchParams;for(const r in t){e.append(r,(t[r]??\"\").toString())}self.fetch(`${ false||\"\"}/__nextjs_launch-editor?${e.toString()}`).then((()=>{}),(()=>{console.error(\"There was an issue opening this code in your editor.\")}))}),[r,t]);return p.createElement(\"div\",{\"data-nextjs-call-stack-frame\":true},p.createElement(\"h3\",{\"data-nextjs-frame-expanded\":Boolean(e.expanded)},t.methodName),p.createElement(\"div\",{\"data-has-source\":r?\"true\":undefined,tabIndex:r?10:undefined,role:r?\"link\":undefined,onClick:n,title:r?\"Click to open in your editor\":undefined},p.createElement(\"span\",null,getFrameSource(t)),p.createElement(\"svg\",{xmlns:\"http://www.w3.org/2000/svg\",viewBox:\"0 0 24 24\",fill:\"none\",stroke:\"currentColor\",strokeWidth:\"2\",strokeLinecap:\"round\",strokeLinejoin:\"round\"},p.createElement(\"path\",{d:\"M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6\"}),p.createElement(\"polyline\",{points:\"15 3 21 3 21 9\"}),p.createElement(\"line\",{x1:\"10\",y1:\"14\",x2:\"21\",y2:\"3\"}))))};const zt=function RuntimeError({error:e}){const t=p.useMemo((()=>e.frames.findIndex((e=>e.expanded&&Boolean(e.originalCodeFrame)&&Boolean(e.originalStackFrame)))),[e.frames]);const r=p.useMemo((()=>e.frames[t]??null),[e.frames,t]);const n=p.useMemo((()=>t<0?[]:e.frames.slice(0,t)),[e.frames,t]);const[a,o]=p.useState(r==null);const i=p.useCallback((()=>{o((e=>!e))}),[]);const l=p.useMemo((()=>n.filter((e=>e.expanded||a))),[a,n]);const s=p.useMemo((()=>e.frames.slice(t+1)),[e.frames,t]);const u=p.useMemo((()=>s.filter((e=>e.expanded||a))),[a,s]);const c=p.useMemo((()=>s.length!==u.length||a&&r!=null),[a,s.length,r,u.length]);return p.createElement(p.Fragment,null,r?p.createElement(p.Fragment,null,p.createElement(\"h2\",null,\"Source\"),l.map(((e,t)=>p.createElement(Rt,{key:`leading-frame-${t}-${a}`,frame:e}))),p.createElement(Mt,{stackFrame:r.originalStackFrame,codeFrame:r.originalCodeFrame})):undefined,e.componentStack?p.createElement(p.Fragment,null,p.createElement(\"h2\",null,\"Component Stack\"),e.componentStack.map(((e,t)=>p.createElement(\"div\",{key:t,\"data-nextjs-component-stack-frame\":true},p.createElement(\"h3\",null,e))))):null,u.length?p.createElement(p.Fragment,null,p.createElement(\"h2\",null,\"Call Stack\"),u.map(((e,t)=>p.createElement(Rt,{key:`call-stack-${t}-${a}`,frame:e})))):undefined,c?p.createElement(p.Fragment,null,p.createElement(\"button\",{tabIndex:10,\"data-nextjs-data-runtime-error-collapsed-action\":true,type:\"button\",onClick:i},a?\"Hide\":\"Show\",\" collapsed frames\")):undefined)};const Bt=noop`\n  button[data-nextjs-data-runtime-error-collapsed-action] {\n    background: none;\n    border: none;\n    padding: 0;\n    font-size: var(--size-font-small);\n    line-height: var(--size-font-bigger);\n    color: var(--color-accents-3);\n  }\n\n  [data-nextjs-call-stack-frame]:not(:last-child),\n  [data-nextjs-component-stack-frame]:not(:last-child) {\n    margin-bottom: var(--size-gap-double);\n  }\n\n  [data-nextjs-call-stack-frame] > h3,\n  [data-nextjs-component-stack-frame] > h3 {\n    margin-top: 0;\n    margin-bottom: var(--size-gap);\n    font-family: var(--font-stack-monospace);\n    color: var(--color-stack-h6);\n  }\n  [data-nextjs-call-stack-frame] > h3[data-nextjs-frame-expanded='false'] {\n    color: var(--color-stack-headline);\n  }\n  [data-nextjs-call-stack-frame] > div {\n    display: flex;\n    align-items: center;\n    padding-left: calc(var(--size-gap) + var(--size-gap-half));\n    font-size: var(--size-font-small);\n    color: var(--color-stack-subline);\n  }\n  [data-nextjs-call-stack-frame] > div > svg {\n    width: auto;\n    height: var(--size-font-small);\n    margin-left: var(--size-gap);\n\n    display: none;\n  }\n\n  [data-nextjs-call-stack-frame] > div[data-has-source] {\n    cursor: pointer;\n  }\n  [data-nextjs-call-stack-frame] > div[data-has-source]:hover {\n    text-decoration: underline dotted;\n  }\n  [data-nextjs-call-stack-frame] > div[data-has-source] > svg {\n    display: unset;\n  }\n`;function getErrorSignature(e){const{event:t}=e;switch(t.type){case o:case i:{return`${t.reason.name}::${t.reason.message}::${t.reason.stack}`}default:{}}const r=t;return\"\"}const Ht=function HotlinkedText(e){const{text:t}=e;const r=/https?:\\/\\/[^\\s/$.?#].[^\\s)'\"]*/i;return p.createElement(p.Fragment,null,r.test(t)?t.split(\" \").map(((e,t,n)=>{if(r.test(e)){const a=r.exec(e);return p.createElement(p.Fragment,{key:`link-${t}`},a&&p.createElement(\"a\",{href:a[0],target:\"_blank\",rel:\"noreferrer noopener\"},e),t===n.length-1?\"\":\" \")}return t===n.length-1?p.createElement(p.Fragment,{key:`text-${t}`},e):p.createElement(p.Fragment,{key:`text-${t}`},e,\" \")})):t)};const qt=function Errors({errors:e}){const[t,r]=p.useState({});const[n,a]=p.useMemo((()=>{let r=[];let n=null;for(let a=0;a<e.length;++a){const o=e[a];const{id:i}=o;if(i in t){r.push(t[i]);continue}if(a>0){const t=e[a-1];if(getErrorSignature(t)===getErrorSignature(o)){continue}}n=o;break}return[r,n]}),[e,t]);const o=p.useMemo((()=>n.length<1&&Boolean(e.length)),[e.length,n.length]);p.useEffect((()=>{if(a==null){return}let e=true;getErrorByType(a).then((t=>{if(e){r((e=>({...e,[t.id]:t})))}}),(()=>{}));return()=>{e=false}}),[a]);const[i,l]=p.useState(\"fullscreen\");const[s,u]=p.useState(0);const c=p.useCallback((e=>{e?.preventDefault();u((e=>Math.max(0,e-1)))}),[]);const d=p.useCallback((e=>{e?.preventDefault();u((e=>Math.max(0,Math.min(n.length-1,e+1))))}),[n.length]);const f=p.useMemo((()=>n[s]??null),[s,n]);p.useEffect((()=>{if(e.length<1){r({});l(\"hidden\");u(0)}}),[e.length]);const m=p.useCallback((e=>{e?.preventDefault();l(\"minimized\")}),[]);const b=p.useCallback((e=>{e?.preventDefault();l(\"hidden\")}),[]);const v=p.useCallback((e=>{e?.preventDefault();l(\"fullscreen\")}),[]);if(e.length<1||f==null){return null}if(o){return p.createElement(St,null)}if(i===\"hidden\"){return null}if(i===\"minimized\"){return p.createElement(Ft,{className:\"nextjs-toast-errors-parent\",onClick:v},p.createElement(\"div\",{className:\"nextjs-toast-errors\"},p.createElement(\"svg\",{xmlns:\"http://www.w3.org/2000/svg\",width:\"24\",height:\"24\",viewBox:\"0 0 24 24\",fill:\"none\",stroke:\"currentColor\",strokeWidth:\"2\",strokeLinecap:\"round\",strokeLinejoin:\"round\"},p.createElement(\"circle\",{cx:\"12\",cy:\"12\",r:\"10\"}),p.createElement(\"line\",{x1:\"12\",y1:\"8\",x2:\"12\",y2:\"12\"}),p.createElement(\"line\",{x1:\"12\",y1:\"16\",x2:\"12.01\",y2:\"16\"})),p.createElement(\"span\",null,n.length,\" error\",n.length>1?\"s\":\"\"),p.createElement(\"button\",{\"data-nextjs-toast-errors-hide-button\":true,className:\"nextjs-toast-errors-hide-button\",type:\"button\",onClick:e=>{e.stopPropagation();b()},\"aria-label\":\"Hide Errors\"},p.createElement(CloseIcon,null))))}const g=[\"server\",\"edge-server\"].includes(getErrorSource(f.error)||\"\");return p.createElement(St,null,p.createElement(h,{type:\"error\",\"aria-labelledby\":\"nextjs__container_errors_label\",\"aria-describedby\":\"nextjs__container_errors_desc\",onClose:g?undefined:m},p.createElement(y,null,p.createElement(E,{className:\"nextjs-container-errors-header\"},p.createElement(Ot,{previous:s>0?c:null,next:s<n.length-1?d:null,close:g?undefined:m},p.createElement(\"small\",null,p.createElement(\"span\",null,s+1),\" of\",\" \",p.createElement(\"span\",null,n.length),\" unhandled error\",n.length<2?\"\":\"s\")),p.createElement(\"h1\",{id:\"nextjs__container_errors_label\"},g?\"Server Error\":\"Unhandled Runtime Error\"),p.createElement(\"p\",{id:\"nextjs__container_errors_desc\"},f.error.name,\":\",\" \",p.createElement(Ht,{text:f.error.message})),g?p.createElement(\"div\",null,p.createElement(\"small\",null,\"This error happened while generating the page. Any console logs will be displayed in the terminal window.\")):undefined),p.createElement(x,{className:\"nextjs-container-errors-body\"},p.createElement(zt,{key:f.id.toString(),error:f})))))};const Pt=noop`\n  .nextjs-container-errors-header > h1 {\n    font-size: var(--size-font-big);\n    line-height: var(--size-font-bigger);\n    font-weight: bold;\n    margin: 0;\n    margin-top: calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n  .nextjs-container-errors-header small {\n    font-size: var(--size-font-small);\n    color: var(--color-accents-1);\n    margin-left: var(--size-gap-double);\n  }\n  .nextjs-container-errors-header small > span {\n    font-family: var(--font-stack-monospace);\n  }\n  .nextjs-container-errors-header > p {\n    font-family: var(--font-stack-monospace);\n    font-size: var(--size-font-small);\n    line-height: var(--size-font-big);\n    font-weight: bold;\n    margin: 0;\n    margin-top: var(--size-gap-half);\n    color: var(--color-ansi-red);\n    white-space: pre-wrap;\n  }\n  .nextjs-container-errors-header > div > small {\n    margin: 0;\n    margin-top: var(--size-gap-half);\n  }\n  .nextjs-container-errors-header > p > a {\n    color: var(--color-ansi-red);\n  }\n\n  .nextjs-container-errors-body > h2:not(:first-child) {\n    margin-top: calc(var(--size-gap-double) + var(--size-gap));\n  }\n  .nextjs-container-errors-body > h2 {\n    margin-bottom: var(--size-gap);\n    font-size: var(--size-font-big);\n  }\n\n  .nextjs-toast-errors-parent {\n    cursor: pointer;\n    transition: transform 0.2s ease;\n  }\n  .nextjs-toast-errors-parent:hover {\n    transform: scale(1.1);\n  }\n  .nextjs-toast-errors {\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n  }\n  .nextjs-toast-errors > svg {\n    margin-right: var(--size-gap);\n  }\n  .nextjs-toast-errors-hide-button {\n    margin-left: var(--size-gap-triple);\n    border: none;\n    background: none;\n    color: var(--color-ansi-bright-white);\n    padding: 0;\n    transition: opacity 0.25s ease;\n    opacity: 0.7;\n  }\n  .nextjs-toast-errors-hide-button:hover {\n    opacity: 1;\n  }\n`;class ErrorBoundary extends b().PureComponent{constructor(){super(...arguments);this.state={error:null}}static getDerivedStateFromError(e){return{error:e}}componentDidCatch(e,t){this.props.onError(e,t?.componentStack||null);if(!this.props.globalOverlay){this.setState({error:e})}}render(){return this.state.error||this.props.globalOverlay&&this.props.isMounted?this.props.globalOverlay?b().createElement(\"html\",null,b().createElement(\"head\",null),b().createElement(\"body\",null)):null:this.props.children}}function Base(){return p.createElement(\"style\",null,noop`\n        :host {\n          --size-gap-half: 4px;\n          --size-gap: 8px;\n          --size-gap-double: 16px;\n          --size-gap-triple: 24px;\n          --size-gap-quad: 32px;\n\n          --size-font-small: 14px;\n          --size-font: 16px;\n          --size-font-big: 20px;\n          --size-font-bigger: 24px;\n\n          --color-background: white;\n          --color-font: #757575;\n          --color-backdrop: rgba(17, 17, 17, 0.2);\n\n          --color-stack-h6: #222;\n          --color-stack-headline: #666;\n          --color-stack-subline: #999;\n\n          --color-accents-1: #808080;\n          --color-accents-2: #222222;\n          --color-accents-3: #404040;\n\n          --font-stack-monospace: 'SFMono-Regular', Consolas, 'Liberation Mono',\n            Menlo, Courier, monospace;\n\n          --color-ansi-selection: rgba(95, 126, 151, 0.48);\n          --color-ansi-bg: #111111;\n          --color-ansi-fg: #cccccc;\n\n          --color-ansi-white: #777777;\n          --color-ansi-black: #141414;\n          --color-ansi-blue: #00aaff;\n          --color-ansi-cyan: #88ddff;\n          --color-ansi-green: #98ec65;\n          --color-ansi-magenta: #aa88ff;\n          --color-ansi-red: #ff5555;\n          --color-ansi-yellow: #ffcc33;\n          --color-ansi-bright-white: #ffffff;\n          --color-ansi-bright-black: #777777;\n          --color-ansi-bright-blue: #33bbff;\n          --color-ansi-bright-cyan: #bbecff;\n          --color-ansi-bright-green: #b6f292;\n          --color-ansi-bright-magenta: #cebbff;\n          --color-ansi-bright-red: #ff8888;\n          --color-ansi-bright-yellow: #ffd966;\n        }\n\n        @media (prefers-color-scheme: dark) {\n          :host {\n            --color-background: rgb(28, 28, 30);\n            --color-font: white;\n            --color-backdrop: rgb(44, 44, 46);\n\n            --color-stack-h6: rgb(200, 200, 204);\n            --color-stack-headline: rgb(99, 99, 102);\n            --color-stack-subline: rgba(142, 142, 147);\n\n            --color-accents-3: rgb(118, 118, 118);\n          }\n        }\n\n        .mono {\n          font-family: var(--font-stack-monospace);\n        }\n\n        h1,\n        h2,\n        h3,\n        h4,\n        h5,\n        h6 {\n          margin-bottom: var(--size-gap);\n          font-weight: 500;\n          line-height: 1.5;\n        }\n      `)}const Wt=noop`\n  [data-nextjs-codeframe] {\n    overflow: auto;\n    border-radius: var(--size-gap-half);\n    background-color: var(--color-ansi-bg);\n    color: var(--color-ansi-fg);\n  }\n  [data-nextjs-codeframe]::selection,\n  [data-nextjs-codeframe] *::selection {\n    background-color: var(--color-ansi-selection);\n  }\n  [data-nextjs-codeframe] * {\n    color: inherit;\n    background-color: transparent;\n    font-family: var(--font-stack-monospace);\n  }\n\n  [data-nextjs-codeframe] > * {\n    margin: 0;\n    padding: calc(var(--size-gap) + var(--size-gap-half))\n      calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n  [data-nextjs-codeframe] > div {\n    display: inline-block;\n    width: auto;\n    min-width: 100%;\n    border-bottom: 1px solid var(--color-ansi-bright-black);\n  }\n  [data-nextjs-codeframe] > div > p {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    cursor: pointer;\n    margin: 0;\n  }\n  [data-nextjs-codeframe] > div > p:hover {\n    text-decoration: underline dotted;\n  }\n  [data-nextjs-codeframe] div > p > svg {\n    width: auto;\n    height: 1em;\n    margin-left: 8px;\n  }\n  [data-nextjs-codeframe] div > pre {\n    overflow: hidden;\n    display: inline-block;\n  }\n`;const Vt=noop`\n  [data-nextjs-dialog-overlay] {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    overflow: auto;\n    z-index: 9000;\n\n    display: flex;\n    align-content: center;\n    align-items: center;\n    flex-direction: column;\n    padding: 10vh 15px 0;\n  }\n\n  @media (max-height: 812px) {\n    [data-nextjs-dialog-overlay] {\n      padding: 15px 15px 0;\n    }\n  }\n\n  [data-nextjs-dialog-backdrop] {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    background-color: var(--color-backdrop);\n    pointer-events: all;\n    z-index: -1;\n  }\n\n  [data-nextjs-dialog-backdrop-fixed] {\n    cursor: not-allowed;\n    -webkit-backdrop-filter: blur(8px);\n    backdrop-filter: blur(8px);\n  }\n`;const $t=noop`\n  [data-nextjs-terminal] {\n    border-radius: var(--size-gap-half);\n    background-color: var(--color-ansi-bg);\n    color: var(--color-ansi-fg);\n  }\n  [data-nextjs-terminal]::selection,\n  [data-nextjs-terminal] *::selection {\n    background-color: var(--color-ansi-selection);\n  }\n  [data-nextjs-terminal] * {\n    color: inherit;\n    background-color: transparent;\n    font-family: var(--font-stack-monospace);\n  }\n  [data-nextjs-terminal] > * {\n    margin: 0;\n    padding: calc(var(--size-gap) + var(--size-gap-half))\n      calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n\n  [data-nextjs-terminal] pre {\n    white-space: pre-wrap;\n    word-break: break-word;\n  }\n`;function ComponentStyles(){return p.createElement(\"style\",null,noop`\n        ${Vt}\n        ${It}\n        ${w}\n        ${Nt}\n        ${Wt}\n        ${$t}\n        \n        ${At}\n        ${Pt}\n        ${Bt}\n      `)}function CssReset(){return p.createElement(\"style\",null,noop`\n        :host {\n          all: initial;\n\n          /* the direction property is not reset by 'all' */\n          direction: ltr;\n        }\n\n        /*!\n         * Bootstrap Reboot v4.4.1 (https://getbootstrap.com/)\n         * Copyright 2011-2019 The Bootstrap Authors\n         * Copyright 2011-2019 Twitter, Inc.\n         * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n         * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md)\n         */\n        *,\n        *::before,\n        *::after {\n          box-sizing: border-box;\n        }\n\n        :host {\n          font-family: sans-serif;\n          line-height: 1.15;\n          -webkit-text-size-adjust: 100%;\n          -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n        }\n\n        article,\n        aside,\n        figcaption,\n        figure,\n        footer,\n        header,\n        hgroup,\n        main,\n        nav,\n        section {\n          display: block;\n        }\n\n        :host {\n          margin: 0;\n          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,\n            'Helvetica Neue', Arial, 'Noto Sans', sans-serif,\n            'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',\n            'Noto Color Emoji';\n          font-size: 16px;\n          font-weight: 400;\n          line-height: 1.5;\n          color: var(--color-font);\n          text-align: left;\n          background-color: #fff;\n        }\n\n        [tabindex='-1']:focus:not(:focus-visible) {\n          outline: 0 !important;\n        }\n\n        hr {\n          box-sizing: content-box;\n          height: 0;\n          overflow: visible;\n        }\n\n        h1,\n        h2,\n        h3,\n        h4,\n        h5,\n        h6 {\n          margin-top: 0;\n          margin-bottom: 8px;\n        }\n\n        p {\n          margin-top: 0;\n          margin-bottom: 16px;\n        }\n\n        abbr[title],\n        abbr[data-original-title] {\n          text-decoration: underline;\n          -webkit-text-decoration: underline dotted;\n          text-decoration: underline dotted;\n          cursor: help;\n          border-bottom: 0;\n          -webkit-text-decoration-skip-ink: none;\n          text-decoration-skip-ink: none;\n        }\n\n        address {\n          margin-bottom: 16px;\n          font-style: normal;\n          line-height: inherit;\n        }\n\n        ol,\n        ul,\n        dl {\n          margin-top: 0;\n          margin-bottom: 16px;\n        }\n\n        ol ol,\n        ul ul,\n        ol ul,\n        ul ol {\n          margin-bottom: 0;\n        }\n\n        dt {\n          font-weight: 700;\n        }\n\n        dd {\n          margin-bottom: 8px;\n          margin-left: 0;\n        }\n\n        blockquote {\n          margin: 0 0 16px;\n        }\n\n        b,\n        strong {\n          font-weight: bolder;\n        }\n\n        small {\n          font-size: 80%;\n        }\n\n        sub,\n        sup {\n          position: relative;\n          font-size: 75%;\n          line-height: 0;\n          vertical-align: baseline;\n        }\n\n        sub {\n          bottom: -0.25em;\n        }\n\n        sup {\n          top: -0.5em;\n        }\n\n        a {\n          color: #007bff;\n          text-decoration: none;\n          background-color: transparent;\n        }\n\n        a:hover {\n          color: #0056b3;\n          text-decoration: underline;\n        }\n\n        a:not([href]) {\n          color: inherit;\n          text-decoration: none;\n        }\n\n        a:not([href]):hover {\n          color: inherit;\n          text-decoration: none;\n        }\n\n        pre,\n        code,\n        kbd,\n        samp {\n          font-family: SFMono-Regular, Menlo, Monaco, Consolas,\n            'Liberation Mono', 'Courier New', monospace;\n          font-size: 1em;\n        }\n\n        pre {\n          margin-top: 0;\n          margin-bottom: 16px;\n          overflow: auto;\n        }\n\n        figure {\n          margin: 0 0 16px;\n        }\n\n        img {\n          vertical-align: middle;\n          border-style: none;\n        }\n\n        svg {\n          overflow: hidden;\n          vertical-align: middle;\n        }\n\n        table {\n          border-collapse: collapse;\n        }\n\n        caption {\n          padding-top: 12px;\n          padding-bottom: 12px;\n          color: #6c757d;\n          text-align: left;\n          caption-side: bottom;\n        }\n\n        th {\n          text-align: inherit;\n        }\n\n        label {\n          display: inline-block;\n          margin-bottom: 8px;\n        }\n\n        button {\n          border-radius: 0;\n        }\n\n        button:focus {\n          outline: 1px dotted;\n          outline: 5px auto -webkit-focus-ring-color;\n        }\n\n        input,\n        button,\n        select,\n        optgroup,\n        textarea {\n          margin: 0;\n          font-family: inherit;\n          font-size: inherit;\n          line-height: inherit;\n        }\n\n        button,\n        input {\n          overflow: visible;\n        }\n\n        button,\n        select {\n          text-transform: none;\n        }\n\n        select {\n          word-wrap: normal;\n        }\n\n        button,\n        [type='button'],\n        [type='reset'],\n        [type='submit'] {\n          -webkit-appearance: button;\n        }\n\n        button:not(:disabled),\n        [type='button']:not(:disabled),\n        [type='reset']:not(:disabled),\n        [type='submit']:not(:disabled) {\n          cursor: pointer;\n        }\n\n        button::-moz-focus-inner,\n        [type='button']::-moz-focus-inner,\n        [type='reset']::-moz-focus-inner,\n        [type='submit']::-moz-focus-inner {\n          padding: 0;\n          border-style: none;\n        }\n\n        input[type='radio'],\n        input[type='checkbox'] {\n          box-sizing: border-box;\n          padding: 0;\n        }\n\n        input[type='date'],\n        input[type='time'],\n        input[type='datetime-local'],\n        input[type='month'] {\n          -webkit-appearance: listbox;\n        }\n\n        textarea {\n          overflow: auto;\n          resize: vertical;\n        }\n\n        fieldset {\n          min-width: 0;\n          padding: 0;\n          margin: 0;\n          border: 0;\n        }\n\n        legend {\n          display: block;\n          width: 100%;\n          max-width: 100%;\n          padding: 0;\n          margin-bottom: 8px;\n          font-size: 24px;\n          line-height: inherit;\n          color: inherit;\n          white-space: normal;\n        }\n\n        progress {\n          vertical-align: baseline;\n        }\n\n        [type='number']::-webkit-inner-spin-button,\n        [type='number']::-webkit-outer-spin-button {\n          height: auto;\n        }\n\n        [type='search'] {\n          outline-offset: -2px;\n          -webkit-appearance: none;\n        }\n\n        [type='search']::-webkit-search-decoration {\n          -webkit-appearance: none;\n        }\n\n        ::-webkit-file-upload-button {\n          font: inherit;\n          -webkit-appearance: button;\n        }\n\n        output {\n          display: inline-block;\n        }\n\n        summary {\n          display: list-item;\n          cursor: pointer;\n        }\n\n        template {\n          display: none;\n        }\n\n        [hidden] {\n          display: none !important;\n        }\n      `)}function pushErrorFilterDuplicates(e,t){return[...e.filter((e=>e.event.reason!==t.event.reason)),t]}function reducer(r,l){switch(l.type){case e:{return{...r,buildError:null}}case t:{return{...r,buildError:l.message}}case a:{return{...r,refreshState:{type:\"pending\",errors:[]}}}case n:{return{...r,buildError:null,errors:r.refreshState.type===\"pending\"?r.refreshState.errors:[],refreshState:{type:\"idle\"}}}case o:case i:{switch(r.refreshState.type){case\"idle\":{return{...r,nextId:r.nextId+1,errors:pushErrorFilterDuplicates(r.errors,{id:r.nextId,event:l})}}case\"pending\":{return{...r,nextId:r.nextId+1,refreshState:{...r.refreshState,errors:pushErrorFilterDuplicates(r.refreshState.errors,{id:r.nextId,event:l})}}}default:const e=r.refreshState;return r}}default:{const e=l;return r}}}const shouldPreventDisplay=(e,t)=>{if(!t||!e){return false}return t.includes(e)};const Kt=function ReactDevOverlay({children:e,preventDisplay:t,globalOverlay:r}){const[n,a]=p.useReducer(reducer,{nextId:1,buildError:null,errors:[],refreshState:{type:\"idle\"}});p.useEffect((()=>{on(a);return function(){off(a)}}),[a]);const o=p.useCallback(((e,t)=>{}),[]);const i=n.buildError!=null;const l=Boolean(n.errors.length);const s=i?\"build\":l?\"runtime\":null;const u=s!==null;return p.createElement(p.Fragment,null,p.createElement(ErrorBoundary,{globalOverlay:r,isMounted:u,onError:o},e??null),u?p.createElement(g,{globalOverlay:r},p.createElement(CssReset,null),p.createElement(Base,null),p.createElement(ComponentStyles,null),shouldPreventDisplay(s,t)?null:i?p.createElement(jt,{message:n.buildError}):l?p.createElement(qt,{errors:n.errors}):undefined):undefined)};var Zt=Kt;(0,f.patchConsoleError)();let Ut=false;let Gt=undefined;function onUnhandledError(e){const t=e?.error;if(!t||!(t instanceof Error)||typeof t.stack!==\"string\"){return}if(t.message.match(/(hydration|content does not match|did not match)/i)){if(f.hydrationErrorWarning){t.message+=\"\\n\\n\"+f.hydrationErrorWarning}t.message+=`\\n\\nSee more info here: https://nextjs.org/docs/messages/react-hydration-error`}const r=t;const n=typeof f.hydrationErrorComponentStack===\"string\"?(0,d.parseComponentStack)(f.hydrationErrorComponentStack).map((e=>e.component)):undefined;emit({type:o,reason:t,frames:parseStack(r.stack),componentStack:n})}function onUnhandledRejection(e){const t=e?.reason;if(!t||!(t instanceof Error)||typeof t.stack!==\"string\"){return}const r=t;emit({type:i,reason:t,frames:parseStack(r.stack)})}function register(){if(Ut){return}Ut=true;try{const e=Error.stackTraceLimit;Error.stackTraceLimit=50;Gt=e}catch{}window.addEventListener(\"error\",onUnhandledError);window.addEventListener(\"unhandledrejection\",onUnhandledRejection)}function unregister(){if(!Ut){return}Ut=false;if(Gt!==undefined){try{Error.stackTraceLimit=Gt}catch{}Gt=undefined}window.removeEventListener(\"error\",onUnhandledError);window.removeEventListener(\"unhandledrejection\",onUnhandledRejection)}function onBuildOk(){emit({type:e})}function onBuildError(e){emit({type:t,message:e})}function onRefresh(){emit({type:n})}function onBeforeRefresh(){emit({type:a})}}();module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2Rpc3QvY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLGFBQWEsT0FBTyxrQkFBa0Isc0NBQXNDLFdBQVcsRUFBRSxHQUFHLENBQUMsQ0FBQyxzQkFBc0IsMENBQTBDLHlCQUF5QixFQUFFLFdBQVcsaUNBQWlDLFNBQVMseUNBQXlDLFNBQVMsOEJBQThCLDBCQUEwQixFQUFFLE1BQU0sTUFBTSxrWUFBa1ksNkJBQTZCLHNCQUFzQixnQ0FBZ0MsYUFBYSxxREFBcUQsSUFBSSw0QkFBNEIsOEhBQThILDhDQUE4QyxXQUFXLEVBQUUsMkJBQTJCLHFCQUFxQixtQkFBbUIsc0NBQXNDLFdBQVcsRUFBRSwrQ0FBK0MsK0JBQStCLDRCQUE0QixFQUFFLGdDQUFnQyxXQUFXLHFDQUFxQyx5Q0FBeUMsd0JBQXdCLGFBQWEsYUFBYSwyQ0FBMkMsTUFBTSx1RkFBdUYsTUFBTSx3REFBd0QsUUFBUSxpRkFBaUYsR0FBRyxTQUFTLDhIQUE4SCw4Q0FBOEMsV0FBVyxFQUFFLDJCQUEyQix1QkFBdUIsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLFlBQVksa0NBQWtDLGlDQUFpQyxvQkFBb0IsWUFBWSxVQUFVLHlCQUF5QixJQUFJLEVBQUUsVUFBVSxHQUFHLFlBQVksb0NBQW9DLGdCQUFnQiw0REFBNEQsMkJBQTJCLHlCQUF5QixLQUFLLEdBQUcsWUFBWSxvQ0FBb0Msa0RBQWtELEdBQUcsWUFBWSxrQ0FBa0Msb0RBQW9ELDRDQUE0QyxlQUFlLEVBQUUsc0NBQXNDLFdBQVcsR0FBRyxHQUFHLG1FQUFtRSxTQUFTLEtBQUssU0FBUyxZQUFZLHlCQUF5Qix5QkFBeUIsMkJBQTJCLFVBQVUsMkJBQTJCLHNCQUFzQiwyQkFBMkIsc0JBQXNCLDRCQUE0Qix1QkFBdUIseUJBQXlCLG9CQUFvQixzQkFBc0IsaUJBQWlCLHNCQUFzQixpQkFBaUIscUJBQXFCLGdCQUFnQix1QkFBdUIsbUJBQW1CLEVBQUUsbUJBQW1CLHNCQUFzQix1QkFBdUIsOEJBQThCLDBCQUEwQiw4QkFBOEIsY0FBYyxTQUFTLGlCQUFpQix1QkFBdUIsMENBQTBDLGtCQUFrQixzQkFBc0IsS0FBSyxpQkFBaUIsc0JBQXNCLEtBQUssR0FBRyxRQUFRLGVBQWUsYUFBYSxhQUFhLFNBQVMsUUFBUSxZQUFZLGdCQUFnQixhQUFhLFlBQVksWUFBWSxhQUFhLE1BQU0sbUJBQU8sQ0FBQywySEFBc0MsRUFBRSxpQ0FBaUMsdUJBQXVCLHVCQUF1QixrQkFBa0IsSUFBSSx3QkFBd0IsMkJBQTJCLE1BQU0sUUFBUSx1REFBMkIsd0NBQXdDLE1BQU0scUNBQXFDLE9BQU8sU0FBUyxHQUFHLCtCQUErQiwrQkFBK0IsK0JBQStCLFNBQVMsTUFBTSw2QkFBNkIsaUZBQWlGLGlCQUFpQixPQUFPLEdBQUcsU0FBUyw4QkFBOEIsMkJBQTJCLGtCQUFrQixrQ0FBa0MsMkJBQTJCLDJEQUEyRCxFQUFFLDZCQUE2QixNQUFNLElBQUksMkJBQTJCLFNBQVMsSUFBSSxjQUFjLElBQUksV0FBVyxhQUFhLElBQUksc0RBQXNELGdCQUFnQixhQUFhLEVBQUUsV0FBVyxhQUFhLGlCQUFpQixPQUFPLGFBQWEsRUFBRSxhQUFhLE9BQU8sU0FBUyxHQUFHLFFBQVEsRUFBRSxHQUFHLFNBQVMsY0FBYyxFQUFFLE1BQU0sZ0JBQWdCLHlCQUF5QixTQUFTLHNDQUFzQyx3Q0FBd0MsNEJBQTRCLDBDQUEwQyxtREFBbUQsMkJBQTJCLGtCQUFrQixrQ0FBa0MsNEJBQTRCLHdDQUF3Qyw0QkFBNEIsTUFBa0MsS0FBSyxpQ0FBaUMsYUFBYSxHQUFHLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLEdBQUcsMEJBQTBCLGlEQUFpRCx1QkFBdUIsT0FBTyxpUUFBaVEsNEVBQTRFLHdCQUF3Qix1SEFBdUgsRUFBRSw0Q0FBNEMsNkpBQTZKLElBQUksdUNBQXVDLDZEQUE2RCwyQkFBMkIsU0FBUyxJQUFJLHdCQUF3Qiw0RUFBNEUsc0JBQXNCLGNBQWMsS0FBSyxhQUFhLGNBQWMsT0FBTyxNQUFNLDZCQUE2Qix1QkFBdUIsbUJBQW1CLE9BQU8sYUFBYSxHQUFHLFNBQVMsSUFBSSxLQUFLLE9BQU8sYUFBYSxLQUFLLHFCQUFxQixpQ0FBaUMsTUFBTSxhQUFhLEdBQUcsZUFBZSxlQUFlLFNBQVMsNkhBQTZILGVBQWUsa0NBQWtDLFNBQVMsU0FBUyxPQUFPLFVBQVUsbURBQW1ELE1BQU0sbUJBQU8sQ0FBQyw0Q0FBTyxFQUFFLCtCQUErQixNQUFNLG1CQUFPLENBQUMsb0RBQVcsRUFBRSx5QkFBeUIsMkJBQTJCLEVBQUUscUJBQXFCLHFCQUFxQixxQkFBcUIscUJBQXFCLHdCQUF3QiwyQ0FBMkMsMkNBQTJDLGtDQUFrQyxZQUFZLEVBQUUsOEJBQThCLElBQUksRUFBRSxXQUFXLHVDQUF1QyxzREFBc0QsT0FBTyxnRkFBZ0YsTUFBTSxHQUFHLGdDQUFnQyxrQkFBa0IscUJBQXFCLE9BQU8sbUJBQW1CLDZCQUE2QixPQUFPLE1BQU0sd0JBQXdCLHlDQUF5QywwQ0FBMEMsa0JBQWtCLDRDQUE0Qyw4Q0FBOEMsU0FBUyx5QkFBeUIsaUNBQWlDLEVBQUUsNEJBQTRCLDZGQUE2RiwyQkFBMkIsS0FBSyxNQUFNLHVCQUF1QixrQkFBa0IsWUFBWSxPQUFPLHdCQUF3QiwrQkFBK0IsT0FBTyxVQUFVLG9CQUFvQix3QkFBd0IsK0VBQStFLG1CQUFtQixvQkFBb0IsV0FBVyx1QkFBdUIsMENBQTBDLHNDQUFzQyw2Q0FBNkMsNENBQTRDLFdBQVcseUNBQXlDLGdEQUFnRCxnREFBZ0QsT0FBTyw4QkFBOEIsdUpBQXVKLHdCQUF3QixxREFBcUQsRUFBRSxFQUFFLE1BQU0sNkJBQTZCLHVCQUF1QixFQUFFLDhCQUE4QiwyQ0FBMkMsS0FBSyxnQ0FBZ0MsdUJBQXVCLEVBQUUsOEJBQThCLDhDQUE4QyxLQUFLLCtCQUErQix1QkFBdUIsRUFBRSw4QkFBOEIsNkNBQTZDLEtBQUssc0JBQXNCLG1CQUFtQix3REFBd0Q7QUFDM3JUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLE1BQU0sbUJBQU8sQ0FBQywyRkFBNkIsRUFBRSwrQkFBK0IsTUFBTSxtQkFBTyxDQUFDLGlHQUErQixFQUFFLCtCQUErQixzQkFBc0IsT0FBTyxTQUFTLHFCQUFxQixTQUFTLDJCQUEyQixVQUFVLHdCQUF3QiwrQkFBK0IseUJBQXlCLHlCQUF5QixtREFBbUQsNkJBQTZCLDJHQUEyRyxzQkFBc0IsMENBQTBDLG9CQUFvQixVQUFVLGdDQUFnQyxPQUFPLHlEQUF5RCw2RUFBNkUsb0VBQW9FLFNBQVMseUJBQXlCLGtFQUFrRSxhQUFhLHdCQUF3QixrQ0FBa0MsRUFBRSxXQUFXLFNBQVMsSUFBSSxlQUFlLGtEQUFrRCxjQUFjLFlBQVksd0JBQXdCLE9BQU8sZ0JBQWdCLG9DQUFvQyxTQUFTLGlDQUFpQyw0QkFBNEIsd0JBQXdCLHlEQUF5RCxFQUFFLHFCQUFxQix3QkFBd0IsWUFBWSxxQkFBcUIsVUFBVSxFQUFFLHNDQUFzQyxZQUFZLGFBQWEsc0JBQXNCLGtFQUFrRSxhQUFhLFNBQVMsd0JBQXdCLDhCQUE4QixFQUFFLFNBQVMsVUFBVSxlQUFlLHNDQUFzQyxRQUFRLFNBQVMsbUZBQW1GLFdBQVcsMkJBQTJCLG9CQUFvQixVQUFVLGFBQWEsSUFBSSxZQUFZLEdBQUcsNkJBQTZCLE9BQU8sa0JBQWtCLGVBQWUsc0NBQXNDLHNCQUFzQixvQkFBb0IsK0JBQStCLGlCQUFpQixnQkFBZ0IseUJBQXlCLHlCQUF5QiwyQkFBMkIsNEJBQTRCLDBCQUEwQiw0QkFBNEIsb0JBQW9CLGlCQUFpQixNQUFNLHNIQUFzSCxrQkFBa0IsT0FBTyx3TEFBd0wsdUNBQXVDLDJDQUEyQyxnQkFBZ0IsT0FBTyxXQUFXLFdBQVcsWUFBWSxnQkFBZ0IsR0FBRyxrQ0FBa0MsbUNBQW1DLHFDQUFxQyw2QkFBNkIsc0JBQXNCLGlCQUFpQixTQUFTLFVBQVUsNkJBQTZCLHNCQUFzQixXQUFXLFlBQVksV0FBVyxhQUFhLFNBQVMsbUJBQW1CLHVCQUF1QixzR0FBc0csaURBQWlELGtCQUFrQixJQUFJLHdDQUF3QyxzQkFBc0IsMEVBQTBFLGtCQUFrQixvQ0FBb0MsbUZBQW1GLGNBQWMsdUJBQXVCLEtBQUssZ0VBQWdFLG9DQUFvQyxtQ0FBbUMscUNBQXFDLHdDQUF3QywwQ0FBMEMsd0JBQXdCLGVBQWUsU0FBUyxnQ0FBZ0Msa0JBQWtCLEdBQUcsU0FBUyxTQUFTLGNBQWMsNkJBQTZCLGFBQWEsSUFBSSxzREFBc0QscUJBQXFCLFNBQVMsS0FBSyxTQUFTLGdDQUFnQyx5QkFBeUIsSUFBSSx1REFBdUQsVUFBVSxPQUFPLElBQUksc0VBQXNFLFdBQVcsa0VBQWtFLDRCQUE0QiwwQkFBMEIsbUNBQW1DLEtBQUssY0FBYyxZQUFZLE9BQU8sbUJBQW1CLFNBQVMscUJBQXFCLG9DQUFvQyxVQUFVLEdBQUcsZ0NBQWdDLHlCQUF5QiwyQ0FBMkMsYUFBYSxJQUFJLGdEQUFnRCxRQUFRLFNBQVMsSUFBSSxtREFBbUQsV0FBVyxTQUFTLE1BQU0sU0FBUyxzQkFBc0IsaUVBQWlFLE9BQU8sd0NBQXdDLGdMQUFnTCxpQ0FBaUMsT0FBTyx3Q0FBd0MsNkxBQTZMLGFBQWEsbUNBQW1DLGVBQWUsWUFBWSw4QkFBOEIsVUFBVSw2QkFBNkIsT0FBTyx3Q0FBd0Msb0tBQW9LLCtCQUErQixtQ0FBbUMsZUFBZSxZQUFZLDZCQUE2QixPQUFPLGtGQUFrRixJQUFJLHdCQUF3QixhQUFhLHNCQUFzQixpRUFBaUUsT0FBTyx3Q0FBd0Msd0tBQXdLLGlDQUFpQyxRQUFRLHdDQUF3QyxnQ0FBZ0MsK0NBQStDLHNCQUFzQixjQUFjLEdBQUcseUNBQXlDLGdCQUFnQixpQ0FBaUMsUUFBUSw2Q0FBNkMsNkJBQTZCLHdDQUF3QyxRQUFRLDZDQUE2QyxzREFBc0QsUUFBUSx5Q0FBeUMsK0NBQStDLHNCQUFzQixjQUFjLEdBQUcseUNBQXlDLGtCQUFrQixRQUFRLHlDQUF5Qyw2QkFBNkIsd0NBQXdDLFFBQVEsc0NBQXNDLGVBQWUsNkNBQTZDLGdDQUFnQyxRQUFRLHdDQUF3Qyw2TEFBNkwsZ0NBQWdDLFFBQVEsOEJBQThCLGdDQUFnQyxpQkFBaUIsK0JBQStCLFNBQVMsVUFBVSxTQUFTLDJCQUEyQiw0QkFBNEIsK0JBQStCLCtCQUErQixzQkFBc0IsU0FBUywrQkFBK0IsK0JBQStCLCtCQUErQiw2QkFBNkIsb0JBQW9CLHNDQUFzQyxVQUFVLFFBQVEsd0NBQXdDLDZDQUE2QyxRQUFRLDBDQUEwQyxnQ0FBZ0MsbUNBQW1DLHFCQUFxQixVQUFVLDZCQUE2QiwyQkFBMkIsdU5BQXVOLFFBQVEsMkNBQTJDLHVDQUF1QywwQkFBMEIsOEJBQThCLDhCQUE4Qiw4QkFBOEIsUUFBUSx1RUFBdUUsdUNBQXVDLDBCQUEwQiw4QkFBOEIsOEJBQThCLG1DQUFtQyxlQUFlLFlBQVksNkJBQTZCLGlCQUFpQiwwQkFBMEIsVUFBVSxRQUFRLHdDQUF3QyxtTEFBbUwsOEJBQThCLG1DQUFtQyw4QkFBOEIsNkJBQTZCLFFBQVEsNkNBQTZDLCtFQUErRSxhQUFhLG1DQUFtQyw4Q0FBOEMsNkNBQTZDLFVBQVUsa0NBQWtDLCtFQUErRSxRQUFRLHdDQUF3QyxzQ0FBc0MsY0FBYyxlQUFlLEdBQUcsdUNBQXVDLGFBQWEsNEJBQTRCLGdDQUFnQyxRQUFRLHdDQUF3QyxzQ0FBc0MsYUFBYSxHQUFHLHVDQUF1QyxhQUFhLDhCQUE4QixRQUFRLHdDQUF3QyxzQ0FBc0MsY0FBYyxlQUFlLEdBQUcsdUNBQXVDLGFBQWEsOEJBQThCLFFBQVEsNENBQTRDLG1EQUFtRCw2QkFBNkIsc0NBQXNDLDZFQUE2RSx5QkFBeUIsMEJBQTBCLCtDQUErQyx3QkFBd0IsU0FBUyxzQ0FBc0MsMERBQTBELE9BQU8sYUFBYSxtQ0FBbUMsaUJBQWlCLCtCQUErQixVQUFVLGdCQUFnQixpQkFBaUIsWUFBWSxxQkFBcUIsdUdBQXVHLHFDQUFxQyxZQUFZLE9BQU8sSUFBSSxvQ0FBb0MsU0FBUyw4QkFBOEIseUJBQXlCLDRCQUE0QiwyQkFBMkIsUUFBUSx3Q0FBd0Msd0RBQXdELCtCQUErQixvQkFBb0IsUUFBUSx3Q0FBd0Msb0RBQW9ELCtCQUErQixvQkFBb0IsUUFBUSx3Q0FBd0MscURBQXFELCtCQUErQixvQkFBb0IsUUFBUSx3Q0FBd0MsK0tBQStLLDhCQUE4QixvQkFBb0IsUUFBUSx3Q0FBd0MsMkZBQTJGLG9GQUFvRixvQkFBb0Isd0ZBQXdGLDRCQUE0QixVQUFVLFFBQVEsd0NBQXdDLHlCQUF5QixvQkFBb0Isb0JBQW9CLFFBQVEsd0NBQXdDLGtDQUFrQyxRQUFRLDhDQUE4QyxpQ0FBaUMscUNBQXFDLG1CQUFtQixRQUFRLDBDQUEwQyxJQUFJLHdCQUF3QixhQUFhLDJDQUEyQyx3Q0FBd0MsVUFBVSxRQUFRLGlQQUFpUCxRQUFRLCt3QkFBK3dCLHdCQUF3QixzQkFBc0IscUNBQXFDLGFBQWEsR0FBRyxTQUFTLFlBQVkscUJBQXFCLE9BQU8sVUFBVSxXQUFXLGFBQWEsc0JBQXNCLFdBQVcsVUFBVSxjQUFjLCtCQUErQiw4QkFBOEIsNEJBQTRCLFFBQVEsZUFBZSwrQ0FBK0Msd0JBQXdCLHlEQUF5RCxFQUFFLGlDQUFpQyxpQ0FBaUMsV0FBVyxhQUFhLDBEQUEwRCxxQ0FBcUMsYUFBYSw0QkFBNEIsWUFBWSw4Q0FBOEMsaUJBQWlCLGFBQWEsNkJBQTZCLDBCQUEwQix3QkFBd0IsWUFBWSxpQ0FBaUMsOEJBQThCLHFDQUFxQyxxQkFBcUIsaUNBQWlDLDZCQUE2QiwyQ0FBMkMsaUNBQWlDLDJIQUEySCxnQ0FBZ0MsR0FBRyw4QkFBOEIsb0NBQW9DLHdDQUF3QywwQkFBMEIsYUFBYSx1REFBdUQsYUFBYSxrRUFBa0UsY0FBYyxnQ0FBZ0Msa0VBQWtFLHlDQUF5Qyw0Q0FBNEMsR0FBRyxRQUFRLGVBQWUsd0JBQXdCLHlEQUF5RCxFQUFFLDRCQUE0QixZQUFZLCtCQUErQixtQ0FBbUMsYUFBYSw0REFBNEQsWUFBWSx5Q0FBeUMsWUFBWSxnQkFBZ0IsWUFBWSxlQUFlLFlBQVksb0NBQW9DLFlBQVksMkNBQTJDLGFBQWEsaUJBQWlCLDZCQUE2Qiw0Q0FBNEMsYUFBYSxpRUFBaUUsY0FBYywrQkFBK0IsWUFBWSw4QkFBOEIsWUFBWSxzQ0FBc0MsWUFBWSw0RUFBNEUsWUFBWSw0RUFBNEUsWUFBWSxtQ0FBbUMsWUFBWSx5QkFBeUIsd0NBQXdDLCtEQUErRCwyQ0FBMkMsWUFBWSxxQ0FBcUMsWUFBWSxnQkFBZ0Isd0JBQXdCLGtDQUFrQyx1QkFBdUIsaURBQWlELGFBQWEsd0JBQXdCLGtEQUFrRCw0REFBNEQsWUFBWSxnRUFBZ0UsYUFBYSxNQUFNLGtHQUFrRyxNQUFNLG9DQUFvQyxZQUFZLGtDQUFrQyxtQkFBbUIsTUFBTSxZQUFZLHNDQUFzQyw0QkFBNEIsWUFBWSx5REFBeUQsa0JBQWtCLFVBQVUsb0JBQW9CLDhEQUE4RCxHQUFHLE1BQU0sYUFBYSwyQ0FBMkMsMkNBQTJDLCtCQUErQixhQUFhLGlDQUFpQyxhQUFhLCtEQUErRCxZQUFZLHNCQUFzQixxQkFBcUIsK0JBQStCLHNDQUFzQyx1REFBdUQsWUFBWSx1Q0FBdUMseUJBQXlCLGNBQWMsYUFBYSx1Q0FBdUMsbUVBQW1FLGtDQUFrQyw2QkFBNkIsbUJBQW1CLEdBQUcsNkJBQTZCLFVBQVUscUNBQXFDLEVBQUUsd0JBQXdCLGdCQUFnQixzQkFBc0IsZUFBZSxVQUFVLFNBQVMsWUFBWSxJQUFJLEtBQUssZ0JBQWdCLFVBQVUsU0FBUywrQkFBK0IsSUFBSSxnSEFBZ0gsU0FBUyxhQUFhLHNCQUFzQixxQkFBcUIsNkJBQTZCLGNBQWMsNEJBQTRCLHlCQUF5Qix3Q0FBd0MsTUFBTSxvQkFBb0IsUUFBUSxTQUFTLDBEQUEwRCxjQUFjLG9DQUFvQyxRQUFRLHFDQUFxQyxnQ0FBZ0MsdUJBQXVCLHFCQUFxQiw2Q0FBNkMsNEJBQTRCLDRCQUE0QixtQkFBbUIsYUFBYSxrQkFBa0IsWUFBWSxHQUFHLHVCQUF1Qiw0QkFBNEIsbUJBQW1CLDRCQUE0QixZQUFZLElBQUksa0RBQWtELFNBQVMsYUFBYSxrQkFBa0IsNEJBQTRCLDJEQUEyRCx5QkFBeUIsMkJBQTJCLDJDQUEyQyxHQUFHLHVCQUF1QiwrQkFBK0Isb0NBQW9DLG9DQUFvQyxHQUFHLFdBQVcsYUFBYSwrQkFBK0IsaURBQWlELEdBQUcsV0FBVyxZQUFZLFFBQVEsWUFBWSxhQUFhLDRCQUE0QixRQUFRLDRDQUE0QyxJQUFJLG9DQUFvQyw0REFBNEQsR0FBRywwQkFBMEIsa0VBQWtFLHlDQUF5QyxrR0FBa0csR0FBRyx3QkFBd0Isa0RBQWtELEVBQUUsK0JBQStCLCtCQUErQixZQUFZLGtCQUFrQixVQUFVLEVBQUUsK0NBQStDLGdEQUFnRCxhQUFhLG9DQUFvQyxhQUFhLDBDQUEwQyxhQUFhLHVCQUF1Qix5QkFBeUIsK0JBQStCLGFBQWEsY0FBYyxZQUFZLGlDQUFpQyxtRUFBbUUsNEJBQTRCLHVCQUF1QixtQkFBbUIsR0FBRyx1QkFBdUIsVUFBVSwrQkFBK0IsRUFBRSwyQkFBMkIsZ0RBQWdELGVBQWUsMkJBQTJCLHNCQUFzQiw4Q0FBOEMsWUFBWSxxQkFBcUIsK0RBQStELGNBQWMsd0JBQXdCLFFBQVEsZUFBZSx3QkFBd0IsZ0NBQWdDLEVBQUUsK0JBQStCLGVBQWUsYUFBYSxpQ0FBaUMsNkJBQTZCLGFBQWEsd0JBQXdCLGVBQWUsYUFBYSxrR0FBa0csYUFBYSxzQ0FBc0Msb0ZBQW9GLGtCQUFrQixVQUFVLDZCQUE2QiwrQkFBK0IsNkJBQTZCLEdBQUcsTUFBTSxhQUFhLFlBQVksY0FBYyxjQUFjLFFBQVEsMEVBQTBFLHNDQUFzQyxRQUFRLGVBQWUsNkJBQTZCLG1CQUFtQix5QkFBeUIsZUFBZSxtREFBbUQsd0JBQXdCLCtDQUErQyxFQUFFLCtCQUErQiwyQkFBMkIsY0FBYywrQkFBK0IsK0JBQStCLGtDQUFrQywyQkFBMkIsK0JBQStCLDhCQUE4Qix1QkFBdUIsUUFBUSxlQUFlLHdCQUF3Qiw4QkFBOEIsRUFBRSx5Q0FBeUMsWUFBWSxrQ0FBa0MsYUFBYSxlQUFlLFlBQVksa0JBQWtCLFVBQVUsRUFBRSwrQkFBK0IsWUFBWSxrREFBa0QsWUFBWSxhQUFhLCtCQUErQixrRUFBa0UseUNBQXlDLGlEQUFpRCxHQUFHLHdCQUF3Qix3REFBd0QsRUFBRSx1QkFBdUIsYUFBYSwyRUFBMkUseUJBQXlCLE1BQU0sdUJBQXVCLGVBQWUsK0JBQStCLHVCQUF1Qiw0QkFBNEIsc0JBQXNCLDRDQUE0QywwQ0FBMEMsZUFBZSxjQUFjLGFBQWEsc0NBQXNDLG1FQUFtRSxpQ0FBaUMsNEJBQTRCLG1CQUFtQixHQUFHLDRCQUE0QixVQUFVLG9DQUFvQyxFQUFFLGNBQWMsZ0NBQWdDLCtCQUErQiw4QkFBOEIsWUFBWSx1QkFBdUIsMkJBQTJCLFlBQVksZ0JBQWdCLHVDQUF1QyxpQkFBaUIsZ0JBQWdCLGtFQUFrRSxrQ0FBa0Msc0JBQXNCLHdDQUF3Qyw0Q0FBNEMsZUFBZSxzQkFBc0IsYUFBYSw0QkFBNEIsa0VBQWtFLHlDQUF5QyxnREFBZ0QsR0FBRyxRQUFRLGVBQWUsdUJBQXVCLG9EQUFvRCxFQUFFLHdCQUF3QixvREFBb0QsRUFBRSxnQkFBZ0IsbUJBQW1CLEVBQUUsK0JBQStCLGFBQWEsK0JBQStCLGFBQWEsMEJBQTBCLGFBQWEsZUFBZSxPQUFPLHFCQUFxQiwyQkFBMkIsOEJBQThCLDRCQUE0QiwrQkFBK0IsaUJBQWlCLDZCQUE2QixpQkFBaUIsY0FBYyx5QkFBeUIsTUFBTSwrQkFBK0IsaURBQWlELG9DQUFvQyxlQUFlLCtCQUErQiwwRUFBMEUsYUFBYSxZQUFZLG1DQUFtQyxtRUFBbUUsOEJBQThCLHlCQUF5QixtQkFBbUIsR0FBRyx5QkFBeUIsVUFBVSxpQ0FBaUMsRUFBRSx5QkFBeUIseUJBQXlCLGlCQUFpQixnQ0FBZ0MsU0FBUyxnQ0FBZ0MsK0JBQStCLGVBQWUsU0FBUyx3QkFBd0IsZ0NBQWdDLGtFQUFrRSxxRUFBcUUsT0FBTywyQkFBMkIsdUJBQXVCLGVBQWUsRUFBRSxxQkFBcUIsdUZBQXVGLFNBQVMsb0JBQW9CLDZCQUE2QixxQkFBcUIsc0JBQXNCLGlDQUFpQyxrRUFBa0UsR0FBRyxLQUFLLHVCQUF1QixNQUFNLGNBQWMsVUFBVSxjQUFjLGNBQWMsY0FBYyxTQUFTLGNBQWMsY0FBYyxzQkFBc0IsUUFBUSxlQUFlLHlCQUF5QixVQUFVLHdXQUF3Vyx1QkFBdUIsVUFBVSwrQkFBK0Isa0VBQWtFLHdEQUF3RCxtQkFBbUIsNEJBQTRCLHVCQUF1QixlQUFlLEVBQUUsMEJBQTBCLFlBQVksYUFBYSxTQUFTLDBCQUEwQixrRUFBa0UsK0ZBQStGLHdCQUF3Qiw4RUFBOEUsRUFBRSxPQUFPLDZEQUE2RCxnQkFBZ0IsOEJBQThCLGlDQUFpQywrQkFBK0Isd0dBQXdHLGNBQWMsb0NBQW9DLDJCQUEyQixrRUFBa0UseUNBQXlDLDZFQUE2RSxHQUFHLFFBQVEsZUFBZSx3QkFBd0IsbURBQW1ELEVBQUUsZ0RBQWdELGFBQWEseUJBQXlCLE1BQU0sMEJBQTBCLGFBQWEsdUJBQXVCLGFBQWEsa0RBQWtELGFBQWEsK0JBQStCLGlCQUFpQixrRkFBa0YsZ0NBQWdDLGVBQWUsK0JBQStCLHVCQUF1Qix5QkFBeUIsNkRBQTZELFlBQVksZ0JBQWdCLHFCQUFxQixzQ0FBc0MsU0FBUyx5QkFBeUIsYUFBYSwwQkFBMEIseUhBQXlILE9BQU8sc0NBQXNDLDBCQUEwQixPQUFPLGNBQWMsd0JBQXdCLGdEQUFnRCxhQUFhLDREQUE0RCxNQUFNLFlBQVksbURBQW1ELGFBQWEsc0NBQXNDLFlBQVksNEJBQTRCLGNBQWMsZ0JBQWdCLFlBQVksc0NBQXNDLHNCQUFzQixvQ0FBb0MsWUFBWSxvQ0FBb0MsMkJBQTJCLCtCQUErQixnQkFBZ0IsZ0NBQWdDLGFBQWEsb0JBQW9CLGFBQWEsZ0JBQWdCLGdDQUFnQyw0QkFBNEIsY0FBYyxnQ0FBZ0MsYUFBYSxpQkFBaUIsNEJBQTRCLGNBQWMsaUJBQWlCLGFBQWEsOEJBQThCLHNDQUFzQyw0QkFBNEIsVUFBVSw0QkFBNEIsZUFBZSx3QkFBd0IsMEJBQTBCLGNBQWMsc0NBQXNDLDRCQUE0QixxQkFBcUIscUNBQXFDLGFBQWEsU0FBUyxvQkFBb0IsK0JBQStCLGFBQWEsc0JBQXNCLE1BQU0sK0JBQStCLHNDQUFzQyxtQ0FBbUMsYUFBYSx5QkFBeUIsV0FBVyxxQkFBcUIsa0NBQWtDLG1FQUFtRSw2QkFBNkIsd0JBQXdCLG1CQUFtQixHQUFHLHdCQUF3QixVQUFVLHdCQUF3QixhQUFhLEVBQUUsK0JBQStCLGFBQWEsRUFBRSxnQ0FBZ0MsRUFBRSx5QkFBeUIsa0VBQWtFLHFFQUFxRSx1QkFBdUIsZUFBZSxFQUFFLHVCQUF1Qiw0REFBNEQsWUFBWSxpQ0FBaUMsMEVBQTBFLHlCQUF5QixrQ0FBa0Msc0NBQXNDLGdDQUFnQyxxRUFBcUUsR0FBRyxxQ0FBcUMsU0FBUyx1QkFBdUIsV0FBVyxtQkFBbUIsV0FBVywrQkFBK0IsUUFBUSxXQUFXLFdBQVcsMEJBQTBCLGNBQWMsT0FBTyxRQUFRLDhCQUE4QixFQUFFLEdBQUcsU0FBUyxzQ0FBc0MsUUFBUSxzQkFBc0IseUJBQXlCLEdBQUcsdUJBQXVCLG9CQUFvQix3Q0FBd0Msb0JBQW9CLHVCQUF1QixHQUFHLDJCQUEyQixrRUFBa0UsMENBQTBDLGlCQUFpQiw0QkFBNEIsZ0JBQWdCLGtDQUFrQyw2QkFBNkIsU0FBUyxrQkFBa0IsK0JBQStCLFlBQVksV0FBVyxLQUFLLFdBQVcsaUNBQWlDLG9CQUFvQiwrQkFBK0Isa0NBQWtDLHVCQUF1QixxQ0FBcUMsMkJBQTJCLFVBQVUsR0FBRyw4QkFBOEIsc0JBQXNCLDBEQUEwRCxrQkFBa0IsaUJBQWlCLDJCQUEyQiw4QkFBOEIsYUFBYSxVQUFVLGdEQUFnRCxrQkFBa0IscUJBQXFCLHFCQUFxQixFQUFFLGtEQUFrRCxxQ0FBcUMsT0FBTyxPQUFPLGlDQUFpQyxVQUFVLEdBQUcsRUFBRSxrRUFBa0UsNkJBQTZCLCtCQUErQixlQUFlLFlBQVksbUJBQW1CLHVCQUF1QixxQkFBcUIsMEJBQTBCLGFBQWEsU0FBUyxHQUFHLFlBQVksR0FBRyx1QkFBdUIsd0NBQXdDLGdCQUFnQixnQ0FBZ0MsY0FBYyxTQUFTLHdCQUF3Qiw0REFBNEQsd0NBQXdDLHlCQUF5QixFQUFFLGtCQUFrQiwrQkFBK0IsWUFBWSxXQUFXLEtBQUssV0FBVyxpQ0FBaUMsb0JBQW9CLCtCQUErQixrQ0FBa0MsdUJBQXVCLHFDQUFxQywyQkFBMkIsVUFBVSxHQUFHLGdDQUFnQyxzQkFBc0IsMERBQTBELGtCQUFrQixzQkFBc0IsZ0NBQWdDLGVBQWUsb0JBQW9CLG1CQUFtQixlQUFlLG1CQUFtQixjQUFjLGlCQUFpQixhQUFhLG9EQUFvRCxpQkFBaUIsT0FBTywwQ0FBMEMsMkJBQTJCLHFCQUFxQixVQUFVLEVBQUUsTUFBTSxzQkFBc0IsOEJBQThCLEtBQUssMEJBQTBCLEVBQUUsa0VBQWtFLCtCQUErQiw2QkFBNkIsbUNBQW1DLEVBQUUsNERBQTRELGlDQUFpQywrQkFBK0IscUNBQXFDLEVBQUUsd0RBQXdELDZCQUE2QixxQkFBcUIsVUFBVSxFQUFFLE9BQU8sWUFBWSxzQkFBc0IsMkJBQTJCLGFBQWEsU0FBUyxFQUFFLGtDQUFrQywyQkFBMkIsd0JBQXdCLGdCQUFnQixVQUFVLEVBQUUsa0RBQWtELDZDQUE2Qyx1QkFBdUIscUJBQXFCLCtCQUErQixvQ0FBb0MsUUFBUSxvREFBb0QsRUFBRSwwQ0FBMEMsdUJBQXVCLGtCQUFrQixFQUFFLCtCQUErQixFQUFFLG9EQUFvRCx3QkFBd0IsbUZBQW1GLEdBQUcsRUFBRSxnRUFBZ0UsdUJBQXVCLHVIQUF1SCxFQUFFLHVCQUF1QixtQkFBbUIsb0JBQW9CLFVBQVUsRUFBRSx5Q0FBeUMsNkNBQTZDLGdDQUFnQyxTQUFTLEdBQUcsZUFBZSxHQUFHLDZCQUE2QixrQkFBa0IsMkJBQTJCLHdCQUF3QixZQUFZLGlCQUFpQix5QkFBeUIsU0FBUyxTQUFTLDRCQUE0QixpQkFBaUIsa0JBQWtCLG1CQUFtQixrQ0FBa0MsWUFBWSxVQUFVLFFBQVEsVUFBVSxhQUFhLGFBQWEsR0FBRyxnQ0FBZ0MsWUFBWSw4QkFBOEIsbUJBQW1CLEtBQUssU0FBUyxjQUFjLHFDQUFxQyxtQkFBbUIsUUFBUSxvQkFBb0IsbUJBQW1CLFNBQVMsMkJBQTJCLG9DQUFvQyxnQkFBZ0Isa0JBQWtCLFNBQVMsNEJBQTRCLGtFQUFrRSxxRUFBcUUsUUFBUSxlQUFlLGdEQUFnRCxxQkFBcUIsNERBQTRELEVBQUUsK0NBQStDLGlDQUFpQyxLQUFLLG9CQUFvQixNQUFNLDhCQUE4QixTQUFTLFFBQVEsOE9BQThPLGlCQUFpQixhQUFhLE1BQU0sTUFBTSxrQkFBa0IsYUFBYSxNQUFNLE1BQU0sYUFBYSxhQUFhLFVBQVUsaUJBQWlCLG1CQUFtQixhQUFhLE1BQU0sTUFBTSxhQUFhLDZDQUE2QyxVQUFVLFFBQVEsNkRBQTZELHdDQUF3QyxhQUFhLEdBQUcsb0NBQW9DLG1CQUFtQixPQUFPLHlDQUF5Qyw2QkFBNkIsMEJBQTBCLGlDQUFpQyx1QkFBdUIsWUFBWSxPQUFPLFdBQVcsbUJBQW1CLFlBQVksT0FBTyxpQkFBaUIsUUFBUSxhQUFhLGFBQWEsWUFBWSxPQUFPLGdEQUFnRCxPQUFPLEdBQUcsU0FBUyx1QkFBdUIsNEJBQTRCLHNDQUFzQywyQ0FBMkMsbUNBQW1DLDZCQUE2Qiw0QkFBNEIscURBQXFELEdBQUcsdUJBQXVCLHVDQUF1QyxtQkFBbUIsc0NBQXNDLDhCQUE4QixPQUFPLG1FQUFtRSxHQUFHLCtCQUErQixrRUFBa0Usd0NBQXdDLE1BQU0sNkJBQTZCLDRGQUE0RixXQUFXLDhCQUE4Qiw0RkFBNEYsbUhBQW1ILG1CQUFtQixtRUFBbUUsU0FBUyx3REFBd0QsaUJBQWlCLDBCQUEwQixnQkFBZ0IscUJBQXFCLGNBQWMsaUVBQWlFLGtDQUFrQyxnQ0FBZ0MsVUFBVSxRQUFRLGFBQWEsSUFBSSx1QkFBdUIsNkJBQTZCLDBFQUEwRSw4QkFBOEIsZ0JBQWdCLFVBQVUsZ0NBQWdDLEdBQUcsZ0NBQWdDLHVCQUF1QixPQUFPLGFBQWEsMkJBQTJCLGtDQUFrQyxFQUFFLGNBQWMsUUFBUSx5QkFBeUIsVUFBVSxPQUFPLDBCQUEwQix5QkFBeUIsT0FBTyx1QkFBdUIsSUFBSSxzQ0FBc0MsMkJBQTJCLDBDQUEwQyxPQUFPLGFBQWEsNkJBQTZCLFVBQVUsR0FBRyxFQUFFLE9BQU8sMkJBQTJCLG1CQUFtQixnQkFBZ0IsMENBQTBDLG1CQUFtQix3QkFBd0IsVUFBVSxFQUFFLGlCQUFpQixXQUFXLG9CQUFvQixZQUFZLFlBQVksdUJBQXVCLFVBQVUsT0FBTyxhQUFhLDRCQUE0Qix3QkFBd0IsYUFBYSxJQUFJLFlBQVksR0FBRyxPQUFPLFVBQVUsT0FBTyxhQUFhLGdCQUFnQixFQUFFLE9BQU8sT0FBTyxTQUFTLGdCQUFnQixpQkFBaUIsV0FBVyxPQUFPLCtEQUErRCxRQUFRLG9DQUFvQyxvQ0FBb0MsRUFBRSxJQUFJLGdDQUFnQyxzQ0FBc0MsR0FBRyxrQkFBa0IsaUJBQWlCLHFCQUFxQixPQUFPLG1CQUFtQixvQ0FBb0MsYUFBYSxtQkFBbUIsZ0NBQWdDLGNBQWMsR0FBRywyQkFBMkIsK0JBQStCLEVBQUUsa0JBQWtCLE9BQU8sV0FBVyxVQUFVLE1BQU0sNEJBQTRCLDJCQUEyQixLQUFLLE1BQU0sa0JBQWtCLFlBQVksT0FBTyw0QkFBNEIsVUFBVSxFQUFFLFdBQVcsZUFBZSxPQUFPLDhCQUE4QixvREFBb0Qsd0JBQXdCLHdGQUF3RixNQUFNLE9BQU8sbUJBQU8sQ0FBQyxrRkFBMEIsRUFBRSxpQ0FBaUMsNEJBQTRCLFVBQVUsRUFBRSwwQ0FBMEMsNkNBQTZDLFFBQVEsOEJBQThCLDRCQUE0QixrRUFBa0Usc0JBQXNCLEVBQUUsU0FBUywwQkFBMEIsS0FBSyx1Q0FBdUMsZUFBZSwwQkFBMEIsbUJBQW1CLFlBQVksaUJBQWlCLDhCQUE4QixVQUFVLEVBQUUsNkJBQTZCLE1BQU0sMkJBQTJCLFdBQVcsb0JBQW9CLHVJQUF1SSwyQ0FBMkMsZ0RBQWdELHVCQUF1Qix5Q0FBeUMsMENBQTBDLDhDQUE4QyxxQkFBcUIsVUFBVSxxREFBcUQsd0NBQXdDLG9JQUFvSTtBQUNocjJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsMkNBQTJDLDBGQUEwRix5QkFBeUIsa0dBQWtHLDBCQUEwQixrR0FBa0csR0FBRyx5Q0FBeUMsaURBQWlELEVBQUUsdUJBQXVCLHVCQUF1Qix1QkFBdUIsNEJBQTRCLDJCQUEyQixLQUFLLE1BQU0sa0JBQWtCLFlBQVksT0FBTyx3QkFBd0Isc0JBQXNCLG9CQUFvQix3QkFBd0Isb0JBQW9CLGNBQWMsa0JBQWtCLE9BQU8sOEJBQThCLG9CQUFvQixjQUFjLGtCQUFrQixPQUFPLDBCQUEwQixvQkFBb0IsNEJBQTRCLHdCQUF3QiwrQ0FBK0MsU0FBUyxRQUFRLE1BQU0sTUFBTSxzQ0FBc0MsVUFBVSxzQ0FBc0Msa0JBQWtCLHlDQUF5QyxVQUFVLDJDQUEyQyxhQUFhLGtCQUFrQixZQUFZLE9BQU8sd0JBQXdCLDRCQUE0Qix3QkFBd0IsWUFBWSw2QkFBNkIsa0JBQWtCLGlCQUFpQiw2QkFBNkIsb0JBQW9CLFdBQVcsOEJBQThCLGlEQUFpRCx3QkFBd0IsTUFBTSwyQkFBMkIsZ0hBQWdILHdCQUF3QixtRUFBbUUsa0VBQWtFLHlLQUF5Syw4QkFBOEIsZ0hBQWdILHdCQUF3QixtRUFBbUUsOERBQThELG9LQUFvSyx1Q0FBdUMsNEdBQTRHLHlCQUF5QixxQkFBcUIsMENBQTBDO0FBQ3J1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUseUJBQXlCLGlDQUFpQyxFQUFFLDhCQUE4QiwrQ0FBK0Msd0JBQXdCLGlDQUFpQyxNQUFNLE9BQU8sbUJBQU8sQ0FBQyw0RkFBK0IsRUFBRSxpQ0FBaUMsNkJBQTZCLHlCQUF5QixFQUFFLHdCQUF3QiwwQkFBMEIsa01BQWtNLFFBQVEsc0JBQXNCLHNHQUFzRyxvQkFBb0IsT0FBTywwQ0FBMEMsNkNBQTZDLFFBQVEsNEJBQTRCLDRCQUE0QixrQkFBa0Isa0NBQWtDLGNBQWMsTUFBa0MsS0FBSywwQkFBMEIsYUFBYSxlQUFlLFFBQVEsc0VBQXNFLEdBQUcsT0FBTyw4QkFBOEIsNkJBQTZCLGlEQUFpRCxzRUFBc0UsMEZBQTBGLHNKQUFzSix5QkFBeUIsNkRBQTZELDhCQUE4Qix3QkFBd0IsMEJBQTBCLCtCQUErQixzRUFBc0UsYUFBYSxFQUFFLFNBQVMsMEJBQTBCLEtBQUssdUNBQXVDLGVBQWUsMEJBQTBCLG1CQUFtQixZQUFZLGlCQUFpQixrQ0FBa0MsUUFBUSxFQUFFLGlEQUFpRCxxQ0FBcUMsNEJBQTRCLGFBQWEsNEJBQTRCLGtCQUFrQixrQ0FBa0MsY0FBYyxNQUFrQyxLQUFLLDBCQUEwQixhQUFhLGVBQWUsUUFBUSxzRUFBc0UsR0FBRyxTQUFTLDhCQUE4QixvQ0FBb0MsdUJBQXVCLGlEQUFpRCxzQ0FBc0MsZ0pBQWdKLHVFQUF1RSxzSkFBc0oseUJBQXlCLDZEQUE2RCw4QkFBOEIsd0JBQXdCLDBCQUEwQiwrQkFBK0IsTUFBTSxnQ0FBZ0MsUUFBUSxFQUFFLHFJQUFxSSx3REFBd0QsaUVBQWlFLCtCQUErQiw0QkFBNEIsV0FBVyxNQUFNLDREQUE0RCwwREFBMEQsNERBQTRELGlGQUFpRiwrSUFBK0kscUJBQXFCLEVBQUUsR0FBRyxFQUFFLFVBQVUsd0JBQXdCLDhEQUE4RCwrSkFBK0osK0NBQStDLDBKQUEwSixrQkFBa0IsRUFBRSxHQUFHLEVBQUUsVUFBVSwyRUFBMkUsMkZBQTJGLG1EQUFtRDtBQUN0bUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDhCQUE4QixNQUFNLFFBQVEsR0FBRyxlQUFlLGVBQWUsU0FBUyxjQUFjLElBQUksaUJBQWlCLElBQUksZUFBZSxFQUFFLFdBQVcsVUFBVSxTQUFTLG1DQUFtQyxNQUFNLE9BQU8sR0FBRywyQ0FBMkMsNkVBQTZFLGNBQWMsa0JBQWtCLG1DQUFtQyxZQUFZLEVBQUUsRUFBRSx5QkFBeUIsb0RBQW9ELDJCQUEyQixrREFBa0QsWUFBWSxFQUFFLEVBQUUsZ0NBQWdDLFlBQVksRUFBRSxFQUFFLFFBQVEsT0FBTywwQkFBMEIsU0FBUyxFQUFFLHdCQUF3QixFQUFFLDJCQUEyQixTQUFTLFdBQVcsWUFBWSxXQUFXLEtBQUssYUFBYSxNQUFNLEtBQUssR0FBRyxXQUFXLGFBQWEsU0FBUyxRQUFRLGVBQWUsZ0RBQWdELFVBQVUsSUFBSSxNQUFNLFlBQVksU0FBUywyRUFBMkUsa0JBQWtCLFlBQVksT0FBTyxXQUFXLDRCQUE0QixNQUFNLFFBQVEsY0FBYyxLQUFLLFNBQVMsR0FBRyxXQUFXLFNBQVMsT0FBTyxvQ0FBb0MseUJBQXlCLDJCQUEyQixvQkFBb0Isd0JBQXdCLE1BQU0sMkJBQTJCLG9CQUFvQiw2Q0FBNkMsY0FBYywwQ0FBMEMsa0JBQWtCLGVBQWUsSUFBSSxFQUFFLFlBQVksTUFBTSxjQUFjLDJCQUEyQixvQkFBb0IsZUFBZSxNQUFNLDJCQUEyQixvQkFBb0IsWUFBWSxNQUFNLDJCQUEyQixvQkFBb0IsZ0JBQWdCLE1BQU0sd0JBQXdCLFlBQVksTUFBTSxnQ0FBZ0MsaUJBQWlCLFlBQVksb0JBQW9CLDJCQUEyQixpREFBaUQsd0JBQXdCLGdDQUFnQyx3QkFBd0IsNktBQTZLLDJCQUEyQix1QkFBdUIsMEJBQTBCLCtCQUErQiwwQkFBMEIsbUNBQW1DLDhGQUE4RixrSEFBa0gsb0JBQW9CLElBQUksNEJBQTRCLG9DQUFvQyx1RUFBdUUsa0RBQWtELHlJQUF5SSwyQ0FBMkMsMkNBQTJDLHFCQUFxQixpRUFBaUUsNEtBQTRLLG9DQUFvQyxrRUFBa0UsbUNBQW1DLDBDQUEwQyxxQkFBcUIseU1BQXlNLHlDQUF5QyxxQkFBcUIsNEJBQTRCLE9BQU87QUFDenJIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSw4Q0FBOEMsY0FBYyxvQkFBb0IsWUFBWSxZQUFZLG1DQUFtQyxPQUFPLFNBQVMsdUJBQXVCLDhDQUE4Qyw4QkFBOEIsZUFBZSxRQUFRLEdBQUcsU0FBUyx3TkFBd04sZ0JBQWdCO0FBQzNnQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSwyQkFBMkI7QUFDN0IsVUFBVTtBQUNWLFVBQVU7QUFDVixVQUFVO0FBQ1YsVUFBVTtBQUNWLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWLFVBQVU7QUFDVixTQUFTLG9CQUFvQjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHdDQUF3Qyw0REFBNEQsc0JBQXNCLGVBQWUsUUFBUSxPQUFPLHNCQUFzQixRQUFRLE9BQU8sMkJBQTJCLFFBQVEsT0FBTyxtQkFBbUIsMkJBQTJCLFFBQVEsT0FBTyxtR0FBbUcsY0FBYyxlQUFlLDRCQUE0QixZQUFZLE9BQU8sa0VBQWtFLG9CQUFvQixHQUFHLGVBQWUsT0FBTyxxQ0FBcUMsMEVBQTBFLG9CQUFvQixJQUFJLCtCQUErQixVQUFVLFNBQVMsVUFBVSxXQUFXLG1DQUFtQyxXQUFXLGFBQWEsc0JBQXNCLG1DQUFtQyw0Q0FBNEMsRUFBRSxpQ0FBaUMsaURBQWlELGFBQWEsRUFBRSxrQkFBa0IsTUFBTSxrQkFBa0IsUUFBUSxPQUFPLGdDQUFnQyxNQUFNLDJCQUEyQixpQ0FBaUMsbUNBQW1DLGlCQUFpQixzRUFBc0Usc0NBQXNDLCtCQUErQixnQkFBZ0Isc0pBQXNKLHFCQUFxQix3QkFBd0IsZ0JBQWdCLHlCQUF5QixVQUFVLDBCQUEwQixhQUFhLGlCQUFpQiw2QkFBNkIsaUJBQWlCLHlEQUF5RCxPQUFPLHlFQUF5RSw0QkFBNEIsMENBQTBDLDRGQUE0RixVQUFVLG1KQUFtSixNQUFNLDREQUE0RCxFQUFFLGlDQUFpQyxrQkFBa0IseURBQXlELE9BQU8sVUFBVSxNQUFNLDJDQUEyQyxFQUFFLG9CQUFvQixPQUFPLE9BQU8sUUFBUSxJQUFJLDhCQUE4Qix5QkFBeUIsS0FBSyxPQUFPLGtEQUFrRCxtRUFBbUUsc0JBQXNCLFFBQVEsT0FBTyxTQUFTLG1CQUFtQixJQUFJLHlCQUF5QixPQUFPLGFBQWEscURBQXFELHNFQUFzRSxxQkFBcUIsTUFBTSxPQUFPLEVBQUUseUJBQXlCLE1BQU0saUJBQWlCLEVBQUUscUJBQXFCLE1BQU0sT0FBTyxFQUFFLDJCQUEyQixNQUFNLE9BQU8sR0FBRyxHQUFHLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2Rpc3QvY2xpZW50LmpzPzRkMzAiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9ezg3NjpmdW5jdGlvbihlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7MCYmMDtmdW5jdGlvbiBfZXhwb3J0KGUsdCl7Zm9yKHZhciByIGluIHQpT2JqZWN0LmRlZmluZVByb3BlcnR5KGUscix7ZW51bWVyYWJsZTp0cnVlLGdldDp0W3JdfSl9X2V4cG9ydCh0LHtoeWRyYXRpb25FcnJvcldhcm5pbmc6ZnVuY3Rpb24oKXtyZXR1cm4gcn0saHlkcmF0aW9uRXJyb3JDb21wb25lbnRTdGFjazpmdW5jdGlvbigpe3JldHVybiBufSxwYXRjaENvbnNvbGVFcnJvcjpmdW5jdGlvbigpe3JldHVybiBwYXRjaENvbnNvbGVFcnJvcn19KTtsZXQgcjtsZXQgbjtjb25zdCBhPW5ldyBTZXQoWydXYXJuaW5nOiBUZXh0IGNvbnRlbnQgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiBcIiVzXCIgQ2xpZW50OiBcIiVzXCIlcycsXCJXYXJuaW5nOiBFeHBlY3RlZCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgbWF0Y2hpbmcgPCVzPiBpbiA8JXM+LiVzXCIsJ1dhcm5pbmc6IEV4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyB0ZXh0IG5vZGUgZm9yIFwiJXNcIiBpbiA8JXM+LiVzJyxcIldhcm5pbmc6IERpZCBub3QgZXhwZWN0IHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSA8JXM+IGluIDwlcz4uJXNcIiwnV2FybmluZzogRGlkIG5vdCBleHBlY3Qgc2VydmVyIEhUTUwgdG8gY29udGFpbiB0aGUgdGV4dCBub2RlIFwiJXNcIiBpbiA8JXM+LiVzJ10pO2Z1bmN0aW9uIHBhdGNoQ29uc29sZUVycm9yKCl7Y29uc3QgZT1jb25zb2xlLmVycm9yO2NvbnNvbGUuZXJyb3I9ZnVuY3Rpb24odCxvLGksbCl7aWYoYS5oYXModCkpe3I9dC5yZXBsYWNlKFwiJXNcIixvKS5yZXBsYWNlKFwiJXNcIixpKS5yZXBsYWNlKFwiJXNcIixcIlwiKTtuPWx9ZS5hcHBseShjb25zb2xlLGFyZ3VtZW50cyl9fWlmKCh0eXBlb2YgdC5kZWZhdWx0PT09XCJmdW5jdGlvblwifHx0eXBlb2YgdC5kZWZhdWx0PT09XCJvYmplY3RcIiYmdC5kZWZhdWx0IT09bnVsbCkmJnR5cGVvZiB0LmRlZmF1bHQuX19lc01vZHVsZT09PVwidW5kZWZpbmVkXCIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTtPYmplY3QuYXNzaWduKHQuZGVmYXVsdCx0KTtlLmV4cG9ydHM9dC5kZWZhdWx0fX0sNjU5OmZ1bmN0aW9uKGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcInBhcnNlQ29tcG9uZW50U3RhY2tcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBwYXJzZUNvbXBvbmVudFN0YWNrfX0pO2Z1bmN0aW9uIHBhcnNlQ29tcG9uZW50U3RhY2soZSl7Y29uc3QgdD1bXTtmb3IoY29uc3QgbiBvZiBlLnRyaW0oKS5zcGxpdChcIlxcblwiKSl7Y29uc3QgZT0vYXQgKFteIF0rKSggXFwoKC4qKVxcKSk/Ly5leGVjKG4pO2lmKGU9PW51bGw/dm9pZCAwOmVbMV0pe2NvbnN0IG49ZVsxXTtjb25zdCBhPWVbM107aWYoYT09bnVsbD92b2lkIDA6YS5pbmNsdWRlcyhcIm5leHQvZGlzdFwiKSl7YnJlYWt9Y29uc3Qgbz1hPT1udWxsP3ZvaWQgMDphLnJlcGxhY2UoL14od2VicGFjay1pbnRlcm5hbDpcXC9cXC9cXC98ZmlsZTpcXC9cXC8pKFxcKC4qXFwpXFwvKT8vLFwiXCIpO3ZhciByO2NvbnN0W2ksbCxzXT0ocj1vPT1udWxsP3ZvaWQgMDpvLnNwbGl0KFwiOlwiKSkhPW51bGw/cjpbXTt0LnB1c2goe2NvbXBvbmVudDpuLGZpbGU6aSxsaW5lTnVtYmVyOmw/TnVtYmVyKGwpOnVuZGVmaW5lZCxjb2x1bW46cz9OdW1iZXIocyk6dW5kZWZpbmVkfSl9fXJldHVybiB0fWlmKCh0eXBlb2YgdC5kZWZhdWx0PT09XCJmdW5jdGlvblwifHx0eXBlb2YgdC5kZWZhdWx0PT09XCJvYmplY3RcIiYmdC5kZWZhdWx0IT09bnVsbCkmJnR5cGVvZiB0LmRlZmF1bHQuX19lc01vZHVsZT09PVwidW5kZWZpbmVkXCIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmRlZmF1bHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTtPYmplY3QuYXNzaWduKHQuZGVmYXVsdCx0KTtlLmV4cG9ydHM9dC5kZWZhdWx0fX19O3ZhciB0PXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18ocil7dmFyIG49dFtyXTtpZihuIT09dW5kZWZpbmVkKXtyZXR1cm4gbi5leHBvcnRzfXZhciBhPXRbcl09e2V4cG9ydHM6e319O3ZhciBvPXRydWU7dHJ5e2Vbcl0oYSxhLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7bz1mYWxzZX1maW5hbGx5e2lmKG8pZGVsZXRlIHRbcl19cmV0dXJuIGEuZXhwb3J0c30hZnVuY3Rpb24oKXtfX25jY3dwY2tfcmVxdWlyZV9fLm49ZnVuY3Rpb24oZSl7dmFyIHQ9ZSYmZS5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIGVbXCJkZWZhdWx0XCJdfTpmdW5jdGlvbigpe3JldHVybiBlfTtfX25jY3dwY2tfcmVxdWlyZV9fLmQodCx7YTp0fSk7cmV0dXJuIHR9fSgpOyFmdW5jdGlvbigpe19fbmNjd3Bja19yZXF1aXJlX18uZD1mdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiB0KXtpZihfX25jY3dwY2tfcmVxdWlyZV9fLm8odCxyKSYmIV9fbmNjd3Bja19yZXF1aXJlX18ubyhlLHIpKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLHtlbnVtZXJhYmxlOnRydWUsZ2V0OnRbcl19KX19fX0oKTshZnVuY3Rpb24oKXtfX25jY3dwY2tfcmVxdWlyZV9fLm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9fSgpOyFmdW5jdGlvbigpe19fbmNjd3Bja19yZXF1aXJlX18ucj1mdW5jdGlvbihlKXtpZih0eXBlb2YgU3ltYm9sIT09XCJ1bmRlZmluZWRcIiYmU3ltYm9sLnRvU3RyaW5nVGFnKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pfX0oKTtpZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHI9e307IWZ1bmN0aW9uKCl7X19uY2N3cGNrX3JlcXVpcmVfXy5yKHIpO19fbmNjd3Bja19yZXF1aXJlX18uZChyLHtSZWFjdERldk92ZXJsYXk6ZnVuY3Rpb24oKXtyZXR1cm4gWnR9LGdldEVycm9yQnlUeXBlOmZ1bmN0aW9uKCl7cmV0dXJuIGdldEVycm9yQnlUeXBlfSxnZXRTZXJ2ZXJFcnJvcjpmdW5jdGlvbigpe3JldHVybiBnZXRTZXJ2ZXJFcnJvcn0sb25CZWZvcmVSZWZyZXNoOmZ1bmN0aW9uKCl7cmV0dXJuIG9uQmVmb3JlUmVmcmVzaH0sb25CdWlsZEVycm9yOmZ1bmN0aW9uKCl7cmV0dXJuIG9uQnVpbGRFcnJvcn0sb25CdWlsZE9rOmZ1bmN0aW9uKCl7cmV0dXJuIG9uQnVpbGRPa30sb25SZWZyZXNoOmZ1bmN0aW9uKCl7cmV0dXJuIG9uUmVmcmVzaH0scmVnaXN0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gcmVnaXN0ZXJ9LHVucmVnaXN0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gdW5yZWdpc3Rlcn19KTtjb25zdCBlPVwiYnVpbGQtb2tcIjtjb25zdCB0PVwiYnVpbGQtZXJyb3JcIjtjb25zdCBuPVwiZmFzdC1yZWZyZXNoXCI7Y29uc3QgYT1cImJlZm9yZS1mYXN0LXJlZnJlc2hcIjtjb25zdCBvPVwidW5oYW5kbGVkLWVycm9yXCI7Y29uc3QgaT1cInVuaGFuZGxlZC1yZWplY3Rpb25cIjtsZXQgbD1uZXcgU2V0O2xldCBzPVtdO2Z1bmN0aW9uIGRyYWluKCl7c2V0VGltZW91dCgoZnVuY3Rpb24oKXt3aGlsZShCb29sZWFuKHMubGVuZ3RoKSYmQm9vbGVhbihsLnNpemUpKXtjb25zdCBlPXMuc2hpZnQoKTtsLmZvckVhY2goKHQ9PnQoZSkpKX19KSwxKX1mdW5jdGlvbiBlbWl0KGUpe3MucHVzaChPYmplY3QuZnJlZXplKHsuLi5lfSkpO2RyYWluKCl9ZnVuY3Rpb24gb24oZSl7aWYobC5oYXMoZSkpe3JldHVybiBmYWxzZX1sLmFkZChlKTtkcmFpbigpO3JldHVybiB0cnVlfWZ1bmN0aW9uIG9mZihlKXtpZihsLmhhcyhlKSl7bC5kZWxldGUoZSk7cmV0dXJuIHRydWV9cmV0dXJuIGZhbHNlfXZhciB1PXJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvc3RhY2t0cmFjZS1wYXJzZXJcIik7Y29uc3QgYz0vXFwvX25leHQoXFwvc3RhdGljXFwvLispL2c7ZnVuY3Rpb24gcGFyc2VTdGFjayhlKXtjb25zdCB0PSgwLHUucGFyc2UpKGUpO3JldHVybiB0Lm1hcCgoZT0+e3RyeXtjb25zdCB0PW5ldyBVUkwoZS5maWxlKTtjb25zdCByPWMuZXhlYyh0LnBhdGhuYW1lKTtpZihyKXtjb25zdCB0PXByb2Nlc3MuZW52Ll9fTkVYVF9ESVNUX0RJUj8ucmVwbGFjZSgvXFxcXC9nLFwiL1wiKT8ucmVwbGFjZSgvXFwvJC8sXCJcIik7aWYodCl7ZS5maWxlPVwiZmlsZTovL1wiK3QuY29uY2F0KHIucG9wKCkpfX19Y2F0Y2h7fXJldHVybiBlfSkpfXZhciBkPV9fbmNjd3Bja19yZXF1aXJlX18oNjU5KTt2YXIgZj1fX25jY3dwY2tfcmVxdWlyZV9fKDg3Nik7ZnVuY3Rpb24gZ2V0RmlsZXN5c3RlbUZyYW1lKGUpe2NvbnN0IHQ9ey4uLmV9O2lmKHR5cGVvZiB0LmZpbGU9PT1cInN0cmluZ1wiKXtpZih0LmZpbGUuc3RhcnRzV2l0aChcIi9cIil8fC9eW2Etel06XFxcXC9pLnRlc3QodC5maWxlKXx8dC5maWxlLnN0YXJ0c1dpdGgoXCJcXFxcXFxcXFwiKSl7dC5maWxlPWBmaWxlOi8vJHt0LmZpbGV9YH19cmV0dXJuIHR9Y29uc3QgbT1TeW1ib2woXCJOZXh0anNFcnJvclwiKTtmdW5jdGlvbiBnZXRFcnJvclNvdXJjZShlKXtyZXR1cm4gZVttXXx8bnVsbH1mdW5jdGlvbiBkZWNvcmF0ZVNlcnZlckVycm9yKGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbSx7d3JpdGFibGU6ZmFsc2UsZW51bWVyYWJsZTpmYWxzZSxjb25maWd1cmFibGU6ZmFsc2UsdmFsdWU6dH0pfWZ1bmN0aW9uIGdldFNlcnZlckVycm9yKGUsdCl7bGV0IHI7dHJ5e3Rocm93IG5ldyBFcnJvcihlLm1lc3NhZ2UpfWNhdGNoKGUpe3I9ZX1yLm5hbWU9ZS5uYW1lO3RyeXtyLnN0YWNrPWAke3IudG9TdHJpbmcoKX1cXG4keygwLHUucGFyc2UpKGUuc3RhY2spLm1hcChnZXRGaWxlc3lzdGVtRnJhbWUpLm1hcCgoZT0+e2xldCB0PWAgICAgYXQgJHtlLm1ldGhvZE5hbWV9YDtpZihlLmZpbGUpe2xldCByPWUuZmlsZTtpZihlLmxpbmVOdW1iZXIpe3IrPWA6JHtlLmxpbmVOdW1iZXJ9YDtpZihlLmNvbHVtbil7cis9YDoke2UuY29sdW1ufWB9fXQrPWAgKCR7cn0pYH1yZXR1cm4gdH0pKS5qb2luKFwiXFxuXCIpfWB9Y2F0Y2h7ci5zdGFjaz1lLnN0YWNrfWRlY29yYXRlU2VydmVyRXJyb3Iocix0KTtyZXR1cm4gcn1mdW5jdGlvbiBnZXRPcmlnaW5hbFN0YWNrRnJhbWUoZSx0LHIpe2FzeW5jIGZ1bmN0aW9uIF9nZXRPcmlnaW5hbFN0YWNrRnJhbWUoKXtjb25zdCBuPW5ldyBVUkxTZWFyY2hQYXJhbXM7bi5hcHBlbmQoXCJpc1NlcnZlclwiLFN0cmluZyh0PT09XCJzZXJ2ZXJcIikpO24uYXBwZW5kKFwiaXNFZGdlU2VydmVyXCIsU3RyaW5nKHQ9PT1cImVkZ2Utc2VydmVyXCIpKTtuLmFwcGVuZChcImVycm9yTWVzc2FnZVwiLHIpO2Zvcihjb25zdCB0IGluIGUpe24uYXBwZW5kKHQsKGVbdF0/P1wiXCIpLnRvU3RyaW5nKCkpfWNvbnN0IGE9bmV3IEFib3J0Q29udHJvbGxlcjtjb25zdCBvPXNldFRpbWVvdXQoKCgpPT5hLmFib3J0KCkpLDNlMyk7Y29uc3QgaT1hd2FpdCBzZWxmLmZldGNoKGAke3Byb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEh8fFwiXCJ9L19fbmV4dGpzX29yaWdpbmFsLXN0YWNrLWZyYW1lPyR7bi50b1N0cmluZygpfWAse3NpZ25hbDphLnNpZ25hbH0pLmZpbmFsbHkoKCgpPT57Y2xlYXJUaW1lb3V0KG8pfSkpO2lmKCFpLm9rfHxpLnN0YXR1cz09PTIwNCl7cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihhd2FpdCBpLnRleHQoKSkpfWNvbnN0IGw9YXdhaXQgaS5qc29uKCk7cmV0dXJue2Vycm9yOmZhbHNlLHJlYXNvbjpudWxsLGV4dGVybmFsOmZhbHNlLGV4cGFuZGVkOiFCb29sZWFuKChlLmZpbGU/LmluY2x1ZGVzKFwibm9kZV9tb2R1bGVzXCIpfHxsLm9yaWdpbmFsU3RhY2tGcmFtZT8uZmlsZT8uaW5jbHVkZXMoXCJub2RlX21vZHVsZXNcIikpPz90cnVlKSxzb3VyY2VTdGFja0ZyYW1lOmUsb3JpZ2luYWxTdGFja0ZyYW1lOmwub3JpZ2luYWxTdGFja0ZyYW1lLG9yaWdpbmFsQ29kZUZyYW1lOmwub3JpZ2luYWxDb2RlRnJhbWV8fG51bGx9fWlmKCEoZS5maWxlPy5zdGFydHNXaXRoKFwid2VicGFjay1pbnRlcm5hbDpcIil8fGUuZmlsZT8uc3RhcnRzV2l0aChcImZpbGU6XCIpKSl7cmV0dXJuIFByb21pc2UucmVzb2x2ZSh7ZXJyb3I6ZmFsc2UscmVhc29uOm51bGwsZXh0ZXJuYWw6dHJ1ZSxleHBhbmRlZDpmYWxzZSxzb3VyY2VTdGFja0ZyYW1lOmUsb3JpZ2luYWxTdGFja0ZyYW1lOm51bGwsb3JpZ2luYWxDb2RlRnJhbWU6bnVsbH0pfXJldHVybiBfZ2V0T3JpZ2luYWxTdGFja0ZyYW1lKCkuY2F0Y2goKHQ9Pih7ZXJyb3I6dHJ1ZSxyZWFzb246dD8ubWVzc2FnZT8/dD8udG9TdHJpbmcoKT8/XCJVbmtub3duIEVycm9yXCIsZXh0ZXJuYWw6ZmFsc2UsZXhwYW5kZWQ6ZmFsc2Usc291cmNlU3RhY2tGcmFtZTplLG9yaWdpbmFsU3RhY2tGcmFtZTpudWxsLG9yaWdpbmFsQ29kZUZyYW1lOm51bGx9KSkpfWZ1bmN0aW9uIGdldE9yaWdpbmFsU3RhY2tGcmFtZXMoZSx0LHIpe3JldHVybiBQcm9taXNlLmFsbChlLm1hcCgoZT0+Z2V0T3JpZ2luYWxTdGFja0ZyYW1lKGUsdCxyKSkpKX1mdW5jdGlvbiBnZXRGcmFtZVNvdXJjZShlKXtsZXQgdD1cIlwiO3RyeXtjb25zdCByPW5ldyBVUkwoZS5maWxlKTtpZih0eXBlb2YgZ2xvYmFsVGhpcyE9PVwidW5kZWZpbmVkXCImJmdsb2JhbFRoaXMubG9jYXRpb24/Lm9yaWdpbiE9PXIub3JpZ2luKXtpZihyLm9yaWdpbj09PVwibnVsbFwiKXt0Kz1yLnByb3RvY29sfWVsc2V7dCs9ci5vcmlnaW59fXQrPXIucGF0aG5hbWU7dCs9XCIgXCJ9Y2F0Y2h7dCs9KGUuZmlsZXx8XCIodW5rbm93bilcIikrXCIgXCJ9aWYoZS5saW5lTnVtYmVyIT1udWxsKXtpZihlLmNvbHVtbiE9bnVsbCl7dCs9YCgke2UubGluZU51bWJlcn06JHtlLmNvbHVtbn0pIGB9ZWxzZXt0Kz1gKCR7ZS5saW5lTnVtYmVyfSkgYH19cmV0dXJuIHQuc2xpY2UoMCwtMSl9YXN5bmMgZnVuY3Rpb24gZ2V0RXJyb3JCeVR5cGUoZSl7Y29uc3R7aWQ6dCxldmVudDpyfT1lO3N3aXRjaChyLnR5cGUpe2Nhc2UgbzpjYXNlIGk6e2NvbnN0IGU9e2lkOnQscnVudGltZTp0cnVlLGVycm9yOnIucmVhc29uLGZyYW1lczphd2FpdCBnZXRPcmlnaW5hbFN0YWNrRnJhbWVzKHIuZnJhbWVzLGdldEVycm9yU291cmNlKHIucmVhc29uKSxyLnJlYXNvbi50b1N0cmluZygpKX07aWYoci50eXBlPT09byl7ZS5jb21wb25lbnRTdGFjaz1yLmNvbXBvbmVudFN0YWNrfXJldHVybiBlfWRlZmF1bHQ6e2JyZWFrfX1jb25zdCBuPXI7dGhyb3cgbmV3IEVycm9yKFwidHlwZSBzeXN0ZW0gaW52YXJpYW50IHZpb2xhdGlvblwiKX12YXIgcD1yZXF1aXJlKFwicmVhY3RcIik7dmFyIGI9X19uY2N3cGNrX3JlcXVpcmVfXy5uKHApO3ZhciB2PXJlcXVpcmUoXCJyZWFjdC1kb21cIik7Y29uc3QgZz1mdW5jdGlvbiBQb3J0YWwoe2NoaWxkcmVuOmUsZ2xvYmFsT3ZlcmxheTp0fSl7bGV0IHI9cC51c2VSZWYobnVsbCk7bGV0IG49cC51c2VSZWYobnVsbCk7bGV0IGE9cC51c2VSZWYobnVsbCk7bGV0WyxvXT1wLnVzZVN0YXRlKCk7cC51c2VMYXlvdXRFZmZlY3QoKCgpPT57Y29uc3QgZT10P2RvY3VtZW50OnIuY3VycmVudC5vd25lckRvY3VtZW50O24uY3VycmVudD1lLmNyZWF0ZUVsZW1lbnQoXCJuZXh0anMtcG9ydGFsXCIpO2EuY3VycmVudD1uLmN1cnJlbnQuYXR0YWNoU2hhZG93KHttb2RlOlwib3BlblwifSk7ZS5ib2R5LmFwcGVuZENoaWxkKG4uY3VycmVudCk7byh7fSk7cmV0dXJuKCk9PntpZihuLmN1cnJlbnQmJm4uY3VycmVudC5vd25lckRvY3VtZW50KXtuLmN1cnJlbnQub3duZXJEb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG4uY3VycmVudCl9fX0pLFt0XSk7cmV0dXJuIGEuY3VycmVudD8oMCx2LmNyZWF0ZVBvcnRhbCkoZSxhLmN1cnJlbnQpOnQ/bnVsbDpwLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIse3JlZjpyfSl9O2Z1bmN0aW9uIHVzZU9uQ2xpY2tPdXRzaWRlKGUsdCl7cC51c2VFZmZlY3QoKCgpPT57aWYoZT09bnVsbHx8dD09bnVsbCl7cmV0dXJufWNvbnN0IGxpc3RlbmVyPXI9PntpZighZXx8ZS5jb250YWlucyhyLnRhcmdldCkpe3JldHVybn10KHIpfTtjb25zdCByPWUuZ2V0Um9vdE5vZGUoKTtyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIixsaXN0ZW5lcik7ci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLGxpc3RlbmVyKTtyZXR1cm4gZnVuY3Rpb24oKXtyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIixsaXN0ZW5lcik7ci5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLGxpc3RlbmVyKX19KSxbdCxlXSl9Y29uc3QgaD1mdW5jdGlvbiBEaWFsb2coe2NoaWxkcmVuOmUsdHlwZTp0LG9uQ2xvc2U6ciwuLi5ufSl7Y29uc3RbYSxvXT1wLnVzZVN0YXRlKG51bGwpO2NvbnN0W2ksbF09cC51c2VTdGF0ZSh0eXBlb2YgZG9jdW1lbnQhPT1cInVuZGVmaW5lZFwiJiZkb2N1bWVudC5oYXNGb2N1cygpP1wiZGlhbG9nXCI6dW5kZWZpbmVkKTtjb25zdCBzPXAudXNlQ2FsbGJhY2soKGU9PntvKGUpfSksW10pO3VzZU9uQ2xpY2tPdXRzaWRlKGEscik7cC51c2VFZmZlY3QoKCgpPT57aWYoYT09bnVsbCl7cmV0dXJufWNvbnN0IGU9YS5nZXRSb290Tm9kZSgpO2lmKCEoZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpKXtyZXR1cm59Y29uc3QgdD1lO2Z1bmN0aW9uIGhhbmRsZXIoZSl7Y29uc3Qgcj10LmFjdGl2ZUVsZW1lbnQ7aWYoZS5rZXk9PT1cIkVudGVyXCImJnIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCYmci5nZXRBdHRyaWJ1dGUoXCJyb2xlXCIpPT09XCJsaW5rXCIpe2UucHJldmVudERlZmF1bHQoKTtlLnN0b3BQcm9wYWdhdGlvbigpO3IuY2xpY2soKX19ZnVuY3Rpb24gaGFuZGxlRm9jdXMoKXtsKGRvY3VtZW50Lmhhc0ZvY3VzKCk/XCJkaWFsb2dcIjp1bmRlZmluZWQpfXQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIixoYW5kbGVyKTt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsaGFuZGxlRm9jdXMpO3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLGhhbmRsZUZvY3VzKTtyZXR1cm4oKT0+e3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIixoYW5kbGVyKTt3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsaGFuZGxlRm9jdXMpO3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLGhhbmRsZUZvY3VzKX19KSxbYV0pO3JldHVybiBwLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7cmVmOnMsXCJkYXRhLW5leHRqcy1kaWFsb2dcIjp0cnVlLHRhYkluZGV4Oi0xLHJvbGU6aSxcImFyaWEtbGFiZWxsZWRieVwiOm5bXCJhcmlhLWxhYmVsbGVkYnlcIl0sXCJhcmlhLWRlc2NyaWJlZGJ5XCI6bltcImFyaWEtZGVzY3JpYmVkYnlcIl0sXCJhcmlhLW1vZGFsXCI6XCJ0cnVlXCJ9LHAuY3JlYXRlRWxlbWVudChcImRpdlwiLHtcImRhdGEtbmV4dGpzLWRpYWxvZy1iYW5uZXJcIjp0cnVlLGNsYXNzTmFtZTpgYmFubmVyLSR7dH1gfSksZSl9O2NvbnN0IHg9ZnVuY3Rpb24gRGlhbG9nQm9keSh7Y2hpbGRyZW46ZSxjbGFzc05hbWU6dH0pe3JldHVybiBwLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7XCJkYXRhLW5leHRqcy1kaWFsb2ctYm9keVwiOnRydWUsY2xhc3NOYW1lOnR9LGUpfTtjb25zdCB5PWZ1bmN0aW9uIERpYWxvZ0NvbnRlbnQoe2NoaWxkcmVuOmUsY2xhc3NOYW1lOnR9KXtyZXR1cm4gcC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse1wiZGF0YS1uZXh0anMtZGlhbG9nLWNvbnRlbnRcIjp0cnVlLGNsYXNzTmFtZTp0fSxlKX07Y29uc3QgRT1mdW5jdGlvbiBEaWFsb2dIZWFkZXIoe2NoaWxkcmVuOmUsY2xhc3NOYW1lOnR9KXtyZXR1cm4gcC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse1wiZGF0YS1uZXh0anMtZGlhbG9nLWhlYWRlclwiOnRydWUsY2xhc3NOYW1lOnR9LGUpfTtmdW5jdGlvbiBub29wKGUsLi4udCl7Y29uc3Qgcj1lLmxlbmd0aC0xO3JldHVybiBlLnNsaWNlKDAscikucmVkdWNlKCgoZSxyLG4pPT5lK3IrdFtuXSksXCJcIikrZVtyXX1jb25zdCB3PW5vb3BgXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ddIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgbWFyZ2luLXJpZ2h0OiBhdXRvO1xuICAgIG1hcmdpbi1sZWZ0OiBhdXRvO1xuICAgIG91dGxpbmU6IG5vbmU7XG4gICAgYmFja2dyb3VuZDogdmFyKC0tY29sb3ItYmFja2dyb3VuZCk7XG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXApO1xuICAgIGJveC1zaGFkb3c6IDAgdmFyKC0tc2l6ZS1nYXAtaGFsZikgdmFyKC0tc2l6ZS1nYXAtZG91YmxlKVxuICAgICAgcmdiYSgwLCAwLCAwLCAwLjI1KTtcbiAgICBtYXgtaGVpZ2h0OiBjYWxjKDEwMCUgLSA1NnB4KTtcbiAgICBvdmVyZmxvdy15OiBoaWRkZW47XG4gIH1cblxuICBAbWVkaWEgKG1heC1oZWlnaHQ6IDgxMnB4KSB7XG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZy1vdmVybGF5XSB7XG4gICAgICBtYXgtaGVpZ2h0OiBjYWxjKDEwMCUgLSAxNXB4KTtcbiAgICB9XG4gIH1cblxuICBAbWVkaWEgKG1pbi13aWR0aDogNTc2cHgpIHtcbiAgICBbZGF0YS1uZXh0anMtZGlhbG9nXSB7XG4gICAgICBtYXgtd2lkdGg6IDU0MHB4O1xuICAgICAgYm94LXNoYWRvdzogMCB2YXIoLS1zaXplLWdhcCkgdmFyKC0tc2l6ZS1nYXAtcXVhZCkgcmdiYSgwLCAwLCAwLCAwLjI1KTtcbiAgICB9XG4gIH1cblxuICBAbWVkaWEgKG1pbi13aWR0aDogNzY4cHgpIHtcbiAgICBbZGF0YS1uZXh0anMtZGlhbG9nXSB7XG4gICAgICBtYXgtd2lkdGg6IDcyMHB4O1xuICAgIH1cbiAgfVxuXG4gIEBtZWRpYSAobWluLXdpZHRoOiA5OTJweCkge1xuICAgIFtkYXRhLW5leHRqcy1kaWFsb2ddIHtcbiAgICAgIG1heC13aWR0aDogOTYwcHg7XG4gICAgfVxuICB9XG5cbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYW5uZXJdIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIH1cbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYW5uZXJdLmJhbm5lci13YXJuaW5nIHtcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWNvbG9yLWFuc2kteWVsbG93KTtcbiAgfVxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWJhbm5lcl0uYmFubmVyLWVycm9yIHtcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktcmVkKTtcbiAgfVxuXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFubmVyXTo6YWZ0ZXIge1xuICAgIHotaW5kZXg6IDI7XG4gICAgY29udGVudDogJyc7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogMDtcbiAgICByaWdodDogMDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICAvKiBiYW5uZXIgd2lkdGg6ICovXG4gICAgYm9yZGVyLXRvcC13aWR0aDogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XG4gICAgYm9yZGVyLWJvdHRvbS13aWR0aDogMDtcbiAgICBib3JkZXItdG9wLXN0eWxlOiBzb2xpZDtcbiAgICBib3JkZXItYm90dG9tLXN0eWxlOiBzb2xpZDtcbiAgICBib3JkZXItdG9wLWNvbG9yOiBpbmhlcml0O1xuICAgIGJvcmRlci1ib3R0b20tY29sb3I6IHRyYW5zcGFyZW50O1xuICB9XG5cbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1jb250ZW50XSB7XG4gICAgb3ZlcmZsb3cteTogYXV0bztcbiAgICBib3JkZXI6IG5vbmU7XG4gICAgbWFyZ2luOiAwO1xuICAgIC8qIGNhbGMocGFkZGluZyArIGJhbm5lciB3aWR0aCBvZmZzZXQpICovXG4gICAgcGFkZGluZzogY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpXG4gICAgICB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIH1cbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1jb250ZW50XSA+IFtkYXRhLW5leHRqcy1kaWFsb2ctaGVhZGVyXSB7XG4gICAgZmxleC1zaHJpbms6IDA7XG4gICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcbiAgfVxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWNvbnRlbnRdID4gW2RhdGEtbmV4dGpzLWRpYWxvZy1ib2R5XSB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGZsZXg6IDEgMSBhdXRvO1xuICB9XG5gO3ZhciBrPXJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcGxhdGZvcm1cIik7dmFyIFM9X19uY2N3cGNrX3JlcXVpcmVfXy5uKGspO3ZhciBfPXJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvY3NzLmVzY2FwZVwiKTt2YXIgVD1fX25jY3dwY2tfcmVxdWlyZV9fLm4oXyk7ZnVuY3Rpb24gbm9kZUFycmF5KGUpe2lmKCFlKXtyZXR1cm5bXX1pZihBcnJheS5pc0FycmF5KGUpKXtyZXR1cm4gZX1pZihlLm5vZGVUeXBlIT09dW5kZWZpbmVkKXtyZXR1cm5bZV19aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtlPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZSl9aWYoZS5sZW5ndGghPT11bmRlZmluZWQpe3JldHVybltdLnNsaWNlLmNhbGwoZSwwKX10aHJvdyBuZXcgVHlwZUVycm9yKFwidW5leHBlY3RlZCBpbnB1dCBcIitTdHJpbmcoZSkpfWZ1bmN0aW9uIGNvbnRleHRUb0VsZW1lbnQoZSl7dmFyIHQ9ZS5jb250ZXh0LHI9ZS5sYWJlbCxuPXI9PT11bmRlZmluZWQ/XCJjb250ZXh0LXRvLWVsZW1lbnRcIjpyLGE9ZS5yZXNvbHZlRG9jdW1lbnQsbz1lLmRlZmF1bHRUb0RvY3VtZW50O3ZhciBpPW5vZGVBcnJheSh0KVswXTtpZihhJiZpJiZpLm5vZGVUeXBlPT09Tm9kZS5ET0NVTUVOVF9OT0RFKXtpPWkuZG9jdW1lbnRFbGVtZW50fWlmKCFpJiZvKXtyZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50fWlmKCFpKXt0aHJvdyBuZXcgVHlwZUVycm9yKG4rXCIgcmVxdWlyZXMgdmFsaWQgb3B0aW9ucy5jb250ZXh0XCIpfWlmKGkubm9kZVR5cGUhPT1Ob2RlLkVMRU1FTlRfTk9ERSYmaS5ub2RlVHlwZSE9PU5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSl7dGhyb3cgbmV3IFR5cGVFcnJvcihuK1wiIHJlcXVpcmVzIG9wdGlvbnMuY29udGV4dCB0byBiZSBhbiBFbGVtZW50XCIpfXJldHVybiBpfWZ1bmN0aW9uIGdldFNoYWRvd0hvc3QoKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06e30sdD1lLmNvbnRleHQ7dmFyIHI9Y29udGV4dFRvRWxlbWVudCh7bGFiZWw6XCJnZXQvc2hhZG93LWhvc3RcIixjb250ZXh0OnR9KTt2YXIgbj1udWxsO3doaWxlKHIpe249cjtyPXIucGFyZW50Tm9kZX1pZihuLm5vZGVUeXBlPT09bi5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFJiZuLmhvc3Qpe3JldHVybiBuLmhvc3R9cmV0dXJuIG51bGx9ZnVuY3Rpb24gZ2V0RG9jdW1lbnQoZSl7aWYoIWUpe3JldHVybiBkb2N1bWVudH1pZihlLm5vZGVUeXBlPT09Tm9kZS5ET0NVTUVOVF9OT0RFKXtyZXR1cm4gZX1yZXR1cm4gZS5vd25lckRvY3VtZW50fHxkb2N1bWVudH1mdW5jdGlvbiBpc0FjdGl2ZUVsZW1lbnQoZSl7dmFyIHQ9Y29udGV4dFRvRWxlbWVudCh7bGFiZWw6XCJpcy9hY3RpdmUtZWxlbWVudFwiLHJlc29sdmVEb2N1bWVudDp0cnVlLGNvbnRleHQ6ZX0pO3ZhciByPWdldERvY3VtZW50KHQpO2lmKHIuYWN0aXZlRWxlbWVudD09PXQpe3JldHVybiB0cnVlfXZhciBuPWdldFNoYWRvd0hvc3Qoe2NvbnRleHQ6dH0pO2lmKG4mJm4uc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50PT09dCl7cmV0dXJuIHRydWV9cmV0dXJuIGZhbHNlfWZ1bmN0aW9uIGdldFBhcmVudHMoKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06e30sdD1lLmNvbnRleHQ7dmFyIHI9W107dmFyIG49Y29udGV4dFRvRWxlbWVudCh7bGFiZWw6XCJnZXQvcGFyZW50c1wiLGNvbnRleHQ6dH0pO3doaWxlKG4pe3IucHVzaChuKTtuPW4ucGFyZW50Tm9kZTtpZihuJiZuLm5vZGVUeXBlIT09Tm9kZS5FTEVNRU5UX05PREUpe249bnVsbH19cmV0dXJuIHJ9dmFyIEM9W1wibWF0Y2hlc1wiLFwid2Via2l0TWF0Y2hlc1NlbGVjdG9yXCIsXCJtb3pNYXRjaGVzU2VsZWN0b3JcIixcIm1zTWF0Y2hlc1NlbGVjdG9yXCJdO3ZhciBqPW51bGw7ZnVuY3Rpb24gZmluZE1ldGhvZE5hbWUoZSl7Qy5zb21lKChmdW5jdGlvbih0KXtpZighZVt0XSl7cmV0dXJuIGZhbHNlfWo9dDtyZXR1cm4gdHJ1ZX0pKX1mdW5jdGlvbiBlbGVtZW50TWF0Y2hlcyhlLHQpe2lmKCFqKXtmaW5kTWV0aG9kTmFtZShlKX1yZXR1cm4gZVtqXSh0KX12YXIgQT1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KFMoKSkpO3ZhciBPPUEub3MuZmFtaWx5fHxcIlwiO3ZhciBOPU89PT1cIkFuZHJvaWRcIjt2YXIgST1PLnNsaWNlKDAsNyk9PT1cIldpbmRvd3NcIjt2YXIgRj1PPT09XCJPUyBYXCI7dmFyIEw9Tz09PVwiaU9TXCI7dmFyIEQ9QS5sYXlvdXQ9PT1cIkJsaW5rXCI7dmFyIE09QS5sYXlvdXQ9PT1cIkdlY2tvXCI7dmFyIFI9QS5sYXlvdXQ9PT1cIlRyaWRlbnRcIjt2YXIgej1BLmxheW91dD09PVwiRWRnZUhUTUxcIjt2YXIgQj1BLmxheW91dD09PVwiV2ViS2l0XCI7dmFyIEg9cGFyc2VGbG9hdChBLnZlcnNpb24pO3ZhciBxPU1hdGguZmxvb3IoSCk7QS5tYWpvclZlcnNpb249cTtBLmlzPXtBTkRST0lEOk4sV0lORE9XUzpJLE9TWDpGLElPUzpMLEJMSU5LOkQsR0VDS086TSxUUklERU5UOlIsRURHRTp6LFdFQktJVDpCLElFOTpSJiZxPT09OSxJRTEwOlImJnE9PT0xMCxJRTExOlImJnE9PT0xMX07ZnVuY3Rpb24gYmVmb3JlKCl7dmFyIGU9e2FjdGl2ZUVsZW1lbnQ6ZG9jdW1lbnQuYWN0aXZlRWxlbWVudCx3aW5kb3dTY3JvbGxUb3A6d2luZG93LnNjcm9sbFRvcCx3aW5kb3dTY3JvbGxMZWZ0OndpbmRvdy5zY3JvbGxMZWZ0LGJvZHlTY3JvbGxUb3A6ZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsYm9keVNjcm9sbExlZnQ6ZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0fTt2YXIgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO3Quc2V0QXR0cmlidXRlKFwic3R5bGVcIixcInBvc2l0aW9uOmFic29sdXRlOyBwb3NpdGlvbjpmaXhlZDsgdG9wOjA7IGxlZnQ6LTJweDsgd2lkdGg6MXB4OyBoZWlnaHQ6MXB4OyBvdmVyZmxvdzpoaWRkZW47XCIpO3Quc2V0QXR0cmlidXRlKFwiYXJpYS1saXZlXCIsXCJvZmZcIik7dC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWJ1c3lcIixcInRydWVcIik7dC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLFwidHJ1ZVwiKTtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHQpO3ZhciByPXQuY29udGVudFdpbmRvdzt2YXIgbj1yLmRvY3VtZW50O24ub3BlbigpO24uY2xvc2UoKTt2YXIgYT1uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7bi5ib2R5LmFwcGVuZENoaWxkKGEpO2UuaWZyYW1lPXQ7ZS53cmFwcGVyPWE7ZS53aW5kb3c9cjtlLmRvY3VtZW50PW47cmV0dXJuIGV9ZnVuY3Rpb24gdGVzdChlLHQpe2Uud3JhcHBlci5pbm5lckhUTUw9XCJcIjt2YXIgcj10eXBlb2YgdC5lbGVtZW50PT09XCJzdHJpbmdcIj9lLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodC5lbGVtZW50KTp0LmVsZW1lbnQoZS53cmFwcGVyLGUuZG9jdW1lbnQpO3ZhciBuPXQubXV0YXRlJiZ0Lm11dGF0ZShyLGUud3JhcHBlcixlLmRvY3VtZW50KTtpZighbiYmbiE9PWZhbHNlKXtuPXJ9IXIucGFyZW50Tm9kZSYmZS53cmFwcGVyLmFwcGVuZENoaWxkKHIpO24mJm4uZm9jdXMmJm4uZm9jdXMoKTtyZXR1cm4gdC52YWxpZGF0ZT90LnZhbGlkYXRlKHIsbixlLmRvY3VtZW50KTplLmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ9PT1ufWZ1bmN0aW9uIGFmdGVyKGUpe2lmKGUuYWN0aXZlRWxlbWVudD09PWRvY3VtZW50LmJvZHkpe2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQmJmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1ciYmZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7aWYoQS5pcy5JRTEwKXtkb2N1bWVudC5ib2R5LmZvY3VzKCl9fWVsc2V7ZS5hY3RpdmVFbGVtZW50JiZlLmFjdGl2ZUVsZW1lbnQuZm9jdXMmJmUuYWN0aXZlRWxlbWVudC5mb2N1cygpfWRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZS5pZnJhbWUpO3dpbmRvdy5zY3JvbGxUb3A9ZS53aW5kb3dTY3JvbGxUb3A7d2luZG93LnNjcm9sbExlZnQ9ZS53aW5kb3dTY3JvbGxMZWZ0O2RvY3VtZW50LmJvZHkuc2Nyb2xsVG9wPWUuYm9keVNjcm9sbFRvcDtkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQ9ZS5ib2R5U2Nyb2xsTGVmdH1mdW5jdGlvbiBkZXRlY3RGb2N1cyhlKXt2YXIgdD1iZWZvcmUoKTt2YXIgcj17fTtPYmplY3Qua2V5cyhlKS5tYXAoKGZ1bmN0aW9uKG4pe3Jbbl09dGVzdCh0LGVbbl0pfSkpO2FmdGVyKHQpO3JldHVybiByfXZhciBQPVwiMS40LjFcIjtmdW5jdGlvbiByZWFkTG9jYWxTdG9yYWdlKGUpe3ZhciB0PXZvaWQgMDt0cnl7dD13aW5kb3cubG9jYWxTdG9yYWdlJiZ3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oZSk7dD10P0pTT04ucGFyc2UodCk6e319Y2F0Y2goZSl7dD17fX1yZXR1cm4gdH1mdW5jdGlvbiB3cml0ZUxvY2FsU3RvcmFnZShlLHQpe2lmKCFkb2N1bWVudC5oYXNGb2N1cygpKXt0cnl7d2luZG93LmxvY2FsU3RvcmFnZSYmd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGUpfWNhdGNoKGUpe31yZXR1cm59dHJ5e3dpbmRvdy5sb2NhbFN0b3JhZ2UmJndpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShlLEpTT04uc3RyaW5naWZ5KHQpKX1jYXRjaChlKXt9fXZhciBXPXR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiJiZ3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudHx8XCJcIjt2YXIgVj1cImFsbHktc3VwcG9ydHMtY2FjaGVcIjt2YXIgJD1yZWFkTG9jYWxTdG9yYWdlKFYpO2lmKCQudXNlckFnZW50IT09V3x8JC52ZXJzaW9uIT09UCl7JD17fX0kLnVzZXJBZ2VudD1XOyQudmVyc2lvbj1QO3ZhciBLPXtnZXQ6ZnVuY3Rpb24gZ2V0KCl7cmV0dXJuICR9LHNldDpmdW5jdGlvbiBzZXQoZSl7T2JqZWN0LmtleXMoZSkuZm9yRWFjaCgoZnVuY3Rpb24odCl7JFt0XT1lW3RdfSkpOyQudGltZT0obmV3IERhdGUpLnRvSVNPU3RyaW5nKCk7d3JpdGVMb2NhbFN0b3JhZ2UoViwkKX19O2Z1bmN0aW9uIGNzc1NoYWRvd1BpZXJjaW5nRGVlcENvbWJpbmF0b3IoKXt2YXIgZT12b2lkIDA7dHJ5e2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJodG1sID4+PiA6Zmlyc3QtY2hpbGRcIik7ZT1cIj4+PlwifWNhdGNoKHQpe3RyeXtkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiaHRtbCAvZGVlcC8gOmZpcnN0LWNoaWxkXCIpO2U9XCIvZGVlcC9cIn1jYXRjaCh0KXtlPVwiXCJ9fXJldHVybiBlfXZhciBaPVwiZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBQUFBQVAvLy95SDVCQUVBQUFBQUxBQUFBQUFCQUFFQUFBSUJSQUE3XCI7dmFyIFU9e2VsZW1lbnQ6XCJkaXZcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2UuaW5uZXJIVE1MPSc8bWFwIG5hbWU9XCJpbWFnZS1tYXAtdGFiaW5kZXgtdGVzdFwiPicrJzxhcmVhIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicrJzxpbWcgdXNlbWFwPVwiI2ltYWdlLW1hcC10YWJpbmRleC10ZXN0XCIgdGFiaW5kZXg9XCItMVwiIGFsdD1cIlwiIHNyYz1cIicrWisnXCI+JztyZXR1cm4gZS5xdWVyeVNlbGVjdG9yKFwiYXJlYVwiKX19O3ZhciBHPXtlbGVtZW50OlwiZGl2XCIsbXV0YXRlOmZ1bmN0aW9uIG11dGF0ZShlKXtlLmlubmVySFRNTD0nPG1hcCBuYW1lPVwiaW1hZ2UtbWFwLXRhYmluZGV4LXRlc3RcIj4nKyc8YXJlYSBocmVmPVwiI3ZvaWRcIiB0YWJpbmRleD1cIi0xXCIgc2hhcGU9XCJyZWN0XCIgY29vcmRzPVwiNjMsMTksMTQ0LDQ1XCI+PC9tYXA+JysnPGltZyB1c2VtYXA9XCIjaW1hZ2UtbWFwLXRhYmluZGV4LXRlc3RcIiBhbHQ9XCJcIiBzcmM9XCInK1orJ1wiPic7cmV0dXJuIGZhbHNlfSx2YWxpZGF0ZTpmdW5jdGlvbiB2YWxpZGF0ZShlLHQscil7aWYoQS5pcy5HRUNLTyl7cmV0dXJuIHRydWV9dmFyIG49ZS5xdWVyeVNlbGVjdG9yKFwiYXJlYVwiKTtuLmZvY3VzKCk7cmV0dXJuIHIuYWN0aXZlRWxlbWVudD09PW59fTt2YXIgWD17ZWxlbWVudDpcImRpdlwiLG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSl7ZS5pbm5lckhUTUw9JzxtYXAgbmFtZT1cImltYWdlLW1hcC1hcmVhLWhyZWYtdGVzdFwiPicrJzxhcmVhIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicrJzxpbWcgdXNlbWFwPVwiI2ltYWdlLW1hcC1hcmVhLWhyZWYtdGVzdFwiIGFsdD1cIlwiIHNyYz1cIicrWisnXCI+JztyZXR1cm4gZS5xdWVyeVNlbGVjdG9yKFwiYXJlYVwiKX0sdmFsaWRhdGU6ZnVuY3Rpb24gdmFsaWRhdGUoZSx0LHIpe2lmKEEuaXMuR0VDS08pe3JldHVybiB0cnVlfXJldHVybiByLmFjdGl2ZUVsZW1lbnQ9PT10fX07dmFyIEo9e25hbWU6XCJjYW4tZm9jdXMtYXVkaW8td2l0aG91dC1jb250cm9sc1wiLGVsZW1lbnQ6XCJhdWRpb1wiLG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSl7dHJ5e2Uuc2V0QXR0cmlidXRlKFwic3JjXCIsWil9Y2F0Y2goZSl7fX19O3ZhciBRPVwiZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBQUFBQVAvLy9aWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaXCI7dmFyIFk9e2VsZW1lbnQ6XCJkaXZcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2UuaW5uZXJIVE1MPSc8bWFwIG5hbWU9XCJicm9rZW4taW1hZ2UtbWFwLXRlc3RcIj48YXJlYSBocmVmPVwiI3ZvaWRcIiBzaGFwZT1cInJlY3RcIiBjb29yZHM9XCI2MywxOSwxNDQsNDVcIj48L21hcD4nKyc8aW1nIHVzZW1hcD1cIiNicm9rZW4taW1hZ2UtbWFwLXRlc3RcIiBhbHQ9XCJcIiBzcmM9XCInK1ErJ1wiPic7cmV0dXJuIGUucXVlcnlTZWxlY3RvcihcImFyZWFcIil9fTt2YXIgZWU9e2VsZW1lbnQ6XCJkaXZcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2Uuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIixcIi0xXCIpO2Uuc2V0QXR0cmlidXRlKFwic3R5bGVcIixcImRpc3BsYXk6IC13ZWJraXQtZmxleDsgZGlzcGxheTogLW1zLWZsZXhib3g7IGRpc3BsYXk6IGZsZXg7XCIpO2UuaW5uZXJIVE1MPSc8c3BhbiBzdHlsZT1cImRpc3BsYXk6IGJsb2NrO1wiPmhlbGxvPC9zcGFuPic7cmV0dXJuIGUucXVlcnlTZWxlY3RvcihcInNwYW5cIil9fTt2YXIgdGU9e2VsZW1lbnQ6XCJmaWVsZHNldFwiLG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSl7ZS5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLDApO2Uuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIixcImRpc2FibGVkXCIpfX07dmFyIHJlPXtlbGVtZW50OlwiZmllbGRzZXRcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2UuaW5uZXJIVE1MPVwiPGxlZ2VuZD5sZWdlbmQ8L2xlZ2VuZD48cD5jb250ZW50PC9wPlwifX07dmFyIG5lPXtlbGVtZW50Olwic3BhblwiLG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSl7ZS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLFwiZGlzcGxheTogLXdlYmtpdC1mbGV4OyBkaXNwbGF5OiAtbXMtZmxleGJveDsgZGlzcGxheTogZmxleDtcIik7ZS5pbm5lckhUTUw9JzxzcGFuIHN0eWxlPVwiZGlzcGxheTogYmxvY2s7XCI+aGVsbG88L3NwYW4+J319O3ZhciBhZT17ZWxlbWVudDpcImZvcm1cIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2Uuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwwKTtlLnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsXCJkaXNhYmxlZFwiKX19O3ZhciBvZT17ZWxlbWVudDpcImFcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2UuaHJlZj1cIiN2b2lkXCI7ZS5pbm5lckhUTUw9JzxpbWcgaXNtYXAgc3JjPVwiJytaKydcIiBhbHQ9XCJcIj4nO3JldHVybiBlLnF1ZXJ5U2VsZWN0b3IoXCJpbWdcIil9fTt2YXIgaWU9e2VsZW1lbnQ6XCJkaXZcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2UuaW5uZXJIVE1MPSc8bWFwIG5hbWU9XCJpbWFnZS1tYXAtdGFiaW5kZXgtdGVzdFwiPjxhcmVhIGhyZWY9XCIjdm9pZFwiIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicrJzxpbWcgdXNlbWFwPVwiI2ltYWdlLW1hcC10YWJpbmRleC10ZXN0XCIgdGFiaW5kZXg9XCItMVwiIGFsdD1cIlwiICcrJ3NyYz1cIicrWisnXCI+JztyZXR1cm4gZS5xdWVyeVNlbGVjdG9yKFwiaW1nXCIpfX07dmFyIGxlPXtlbGVtZW50OmZ1bmN0aW9uIGVsZW1lbnQoZSx0KXt2YXIgcj10LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7ZS5hcHBlbmRDaGlsZChyKTt2YXIgbj1yLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7bi5vcGVuKCk7bi5jbG9zZSgpO3JldHVybiByfSxtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2Uuc3R5bGUudmlzaWJpbGl0eT1cImhpZGRlblwiO3ZhciB0PWUuY29udGVudFdpbmRvdy5kb2N1bWVudDt2YXIgcj10LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTt0LmJvZHkuYXBwZW5kQ2hpbGQocik7cmV0dXJuIHJ9LHZhbGlkYXRlOmZ1bmN0aW9uIHZhbGlkYXRlKGUpe3ZhciB0PWUuY29udGVudFdpbmRvdy5kb2N1bWVudDt2YXIgcj10LnF1ZXJ5U2VsZWN0b3IoXCJpbnB1dFwiKTtyZXR1cm4gdC5hY3RpdmVFbGVtZW50PT09cn19O3ZhciBzZT0hQS5pcy5XRUJLSVQ7ZnVuY3Rpb24gZm9jdXNJblplcm9EaW1lbnNpb25PYmplY3QoKXtyZXR1cm4gc2V9dmFyIHVlPXtlbGVtZW50OlwiZGl2XCIsbXV0YXRlOmZ1bmN0aW9uIG11dGF0ZShlKXtlLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsXCJpbnZhbGlkLXZhbHVlXCIpfX07dmFyIGNlPXtlbGVtZW50OlwibGFiZWxcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2Uuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIixcIi0xXCIpfSx2YWxpZGF0ZTpmdW5jdGlvbiB2YWxpZGF0ZShlLHQscil7dmFyIG49ZS5vZmZzZXRIZWlnaHQ7ZS5mb2N1cygpO3JldHVybiByLmFjdGl2ZUVsZW1lbnQ9PT1lfX07dmFyIGRlPVwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhodGJcIitcIkc1ek9uaHNhVzVyUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMM2hzYVc1cklpQnBaRDBpYzNabklqNDhkR1Y0ZENCNFBTSXhNQ0lnZVQwaU1qQWlJR2xrUFNKXCIrXCJ6ZG1jdGJHbHVheTEwWlhoMElqNTBaWGgwUEM5MFpYaDBQand2YzNablBnPT1cIjt2YXIgZmU9e2VsZW1lbnQ6XCJvYmplY3RcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2Uuc2V0QXR0cmlidXRlKFwidHlwZVwiLFwiaW1hZ2Uvc3ZnK3htbFwiKTtlLnNldEF0dHJpYnV0ZShcImRhdGFcIixkZSk7ZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLFwiMjAwXCIpO2Uuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsXCI1MFwiKTtlLnN0eWxlLnZpc2liaWxpdHk9XCJoaWRkZW5cIn19O3ZhciBtZT17bmFtZTpcImNhbi1mb2N1cy1vYmplY3Qtc3ZnXCIsZWxlbWVudDpcIm9iamVjdFwiLG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSl7ZS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsXCJpbWFnZS9zdmcreG1sXCIpO2Uuc2V0QXR0cmlidXRlKFwiZGF0YVwiLGRlKTtlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsXCIyMDBcIik7ZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIixcIjUwXCIpfSx2YWxpZGF0ZTpmdW5jdGlvbiB2YWxpZGF0ZShlLHQscil7aWYoQS5pcy5HRUNLTyl7cmV0dXJuIHRydWV9cmV0dXJuIHIuYWN0aXZlRWxlbWVudD09PWV9fTt2YXIgcGU9IUEuaXMuSUU5O2Z1bmN0aW9uIGZvY3VzT2JqZWN0U3dmKCl7cmV0dXJuIHBlfXZhciBiZT17ZWxlbWVudDpcImRpdlwiLG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSl7ZS5pbm5lckhUTUw9JzxtYXAgbmFtZT1cImZvY3VzLXJlZGlyZWN0LWltZy11c2VtYXBcIj48YXJlYSBocmVmPVwiI3ZvaWRcIiBzaGFwZT1cInJlY3RcIiBjb29yZHM9XCI2MywxOSwxNDQsNDVcIj48L21hcD4nKyc8aW1nIHVzZW1hcD1cIiNmb2N1cy1yZWRpcmVjdC1pbWctdXNlbWFwXCIgYWx0PVwiXCIgJysnc3JjPVwiJytaKydcIj4nO3JldHVybiBlLnF1ZXJ5U2VsZWN0b3IoXCJpbWdcIil9LHZhbGlkYXRlOmZ1bmN0aW9uIHZhbGlkYXRlKGUsdCxyKXt2YXIgbj1lLnF1ZXJ5U2VsZWN0b3IoXCJhcmVhXCIpO3JldHVybiByLmFjdGl2ZUVsZW1lbnQ9PT1ufX07dmFyIHZlPXtlbGVtZW50OlwiZmllbGRzZXRcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2UuaW5uZXJIVE1MPSc8bGVnZW5kPmxlZ2VuZDwvbGVnZW5kPjxpbnB1dCB0YWJpbmRleD1cIi0xXCI+PGlucHV0IHRhYmluZGV4PVwiMFwiPic7cmV0dXJuIGZhbHNlfSx2YWxpZGF0ZTpmdW5jdGlvbiB2YWxpZGF0ZShlLHQscil7dmFyIG49ZS5xdWVyeVNlbGVjdG9yKCdpbnB1dFt0YWJpbmRleD1cIi0xXCJdJyk7dmFyIGE9ZS5xdWVyeVNlbGVjdG9yKCdpbnB1dFt0YWJpbmRleD1cIjBcIl0nKTtlLmZvY3VzKCk7ZS5xdWVyeVNlbGVjdG9yKFwibGVnZW5kXCIpLmZvY3VzKCk7cmV0dXJuIHIuYWN0aXZlRWxlbWVudD09PW4mJlwiZm9jdXNhYmxlXCJ8fHIuYWN0aXZlRWxlbWVudD09PWEmJlwidGFiYmFibGVcInx8XCJcIn19O3ZhciBnZT17ZWxlbWVudDpcImRpdlwiLG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSl7ZS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLFwid2lkdGg6IDEwMHB4OyBoZWlnaHQ6IDUwcHg7IG92ZXJmbG93OiBhdXRvO1wiKTtlLmlubmVySFRNTD0nPGRpdiBzdHlsZT1cIndpZHRoOiA1MDBweDsgaGVpZ2h0OiA0MHB4O1wiPnNjcm9sbGFibGUgY29udGVudDwvZGl2Pic7cmV0dXJuIGUucXVlcnlTZWxlY3RvcihcImRpdlwiKX19O3ZhciBoZT17ZWxlbWVudDpcImRpdlwiLG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSl7ZS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLFwid2lkdGg6IDEwMHB4OyBoZWlnaHQ6IDUwcHg7XCIpO2UuaW5uZXJIVE1MPSc8ZGl2IHN0eWxlPVwid2lkdGg6IDUwMHB4OyBoZWlnaHQ6IDQwcHg7XCI+c2Nyb2xsYWJsZSBjb250ZW50PC9kaXY+J319O3ZhciB4ZT17ZWxlbWVudDpcImRpdlwiLG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSl7ZS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLFwid2lkdGg6IDEwMHB4OyBoZWlnaHQ6IDUwcHg7IG92ZXJmbG93OiBhdXRvO1wiKTtlLmlubmVySFRNTD0nPGRpdiBzdHlsZT1cIndpZHRoOiA1MDBweDsgaGVpZ2h0OiA0MHB4O1wiPnNjcm9sbGFibGUgY29udGVudDwvZGl2Pid9fTt2YXIgeWU9e2VsZW1lbnQ6XCJkZXRhaWxzXCIsbXV0YXRlOmZ1bmN0aW9uIG11dGF0ZShlKXtlLmlubmVySFRNTD1cIjxzdW1tYXJ5PmZvbzwvc3VtbWFyeT48cD5jb250ZW50PC9wPlwiO3JldHVybiBlLmZpcnN0RWxlbWVudENoaWxkfX07ZnVuY3Rpb24gbWFrZUZvY3VzYWJsZUZvcmVpZ25PYmplY3QoKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFwiZm9yZWlnbk9iamVjdFwiKTtlLndpZHRoLmJhc2VWYWwudmFsdWU9MzA7ZS5oZWlnaHQuYmFzZVZhbC52YWx1ZT0zMDtlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSk7ZS5sYXN0Q2hpbGQudHlwZT1cInRleHRcIjtyZXR1cm4gZX1mdW5jdGlvbiBmb2N1c1N2Z0ZvcmVpZ25PYmplY3RIYWNrKGUpe3ZhciB0PWUub3duZXJTVkdFbGVtZW50fHxlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT1cInN2Z1wiO2lmKCF0KXtyZXR1cm4gZmFsc2V9dmFyIHI9bWFrZUZvY3VzYWJsZUZvcmVpZ25PYmplY3QoKTtlLmFwcGVuZENoaWxkKHIpO3ZhciBuPXIucXVlcnlTZWxlY3RvcihcImlucHV0XCIpO24uZm9jdXMoKTtuLmRpc2FibGVkPXRydWU7ZS5yZW1vdmVDaGlsZChyKTtyZXR1cm4gdHJ1ZX1mdW5jdGlvbiBnZW5lcmF0ZShlKXtyZXR1cm4nPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCI+JytlK1wiPC9zdmc+XCJ9ZnVuY3Rpb24gbWFpbnRhaW5fdGFiX2ZvY3VzX2ZvY3VzKGUpe2lmKGUuZm9jdXMpe3JldHVybn10cnl7SFRNTEVsZW1lbnQucHJvdG90eXBlLmZvY3VzLmNhbGwoZSl9Y2F0Y2godCl7Zm9jdXNTdmdGb3JlaWduT2JqZWN0SGFjayhlKX19ZnVuY3Rpb24gdmFsaWRhdGUoZSx0LHIpe21haW50YWluX3RhYl9mb2N1c19mb2N1cyh0KTtyZXR1cm4gci5hY3RpdmVFbGVtZW50PT09dH12YXIgRWU9e2VsZW1lbnQ6XCJkaXZcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2UuaW5uZXJIVE1MPWdlbmVyYXRlKCc8dGV4dCBmb2N1c2FibGU9XCJ0cnVlXCI+YTwvdGV4dD4nKTtyZXR1cm4gZS5xdWVyeVNlbGVjdG9yKFwidGV4dFwiKX0sdmFsaWRhdGU6dmFsaWRhdGV9O3ZhciB3ZT17ZWxlbWVudDpcImRpdlwiLG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSl7ZS5pbm5lckhUTUw9Z2VuZXJhdGUoJzx0ZXh0IHRhYmluZGV4PVwiMFwiPmE8L3RleHQ+Jyk7cmV0dXJuIGUucXVlcnlTZWxlY3RvcihcInRleHRcIil9LHZhbGlkYXRlOnZhbGlkYXRlfTt2YXIga2U9e2VsZW1lbnQ6XCJkaXZcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2UuaW5uZXJIVE1MPWdlbmVyYXRlKCc8dGV4dCB0YWJpbmRleD1cIi0xXCI+YTwvdGV4dD4nKTtyZXR1cm4gZS5xdWVyeVNlbGVjdG9yKFwidGV4dFwiKX0sdmFsaWRhdGU6dmFsaWRhdGV9O3ZhciBTZT17ZWxlbWVudDpcImRpdlwiLG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSl7ZS5pbm5lckhUTUw9Z2VuZXJhdGUoWyc8ZyBpZD1cImFsbHktdGVzdC10YXJnZXRcIj48YSB4bGluazpocmVmPVwiI3ZvaWRcIj48dGV4dD5saW5rPC90ZXh0PjwvYT48L2c+JywnPHVzZSB4bGluazpocmVmPVwiI2FsbHktdGVzdC10YXJnZXRcIiB4PVwiMFwiIHk9XCIwXCIgdGFiaW5kZXg9XCItMVwiIC8+J10uam9pbihcIlwiKSk7cmV0dXJuIGUucXVlcnlTZWxlY3RvcihcInVzZVwiKX0sdmFsaWRhdGU6dmFsaWRhdGV9O3ZhciBfZT17ZWxlbWVudDpcImRpdlwiLG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSl7ZS5pbm5lckhUTUw9Z2VuZXJhdGUoJzxmb3JlaWduT2JqZWN0IHRhYmluZGV4PVwiLTFcIj48aW5wdXQgdHlwZT1cInRleHRcIiAvPjwvZm9yZWlnbk9iamVjdD4nKTtyZXR1cm4gZS5xdWVyeVNlbGVjdG9yKFwiZm9yZWlnbk9iamVjdFwiKXx8ZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImZvcmVpZ25PYmplY3RcIilbMF19LHZhbGlkYXRlOnZhbGlkYXRlfTt2YXIgVGU9Qm9vbGVhbihBLmlzLkdFQ0tPJiZ0eXBlb2YgU1ZHRWxlbWVudCE9PVwidW5kZWZpbmVkXCImJlNWR0VsZW1lbnQucHJvdG90eXBlLmZvY3VzKTtmdW5jdGlvbiBmb2N1c1N2Z0luSWZyYW1lKCl7cmV0dXJuIFRlfXZhciBDZT17ZWxlbWVudDpcImRpdlwiLG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSl7ZS5pbm5lckhUTUw9Z2VuZXJhdGUoXCJcIik7cmV0dXJuIGUuZmlyc3RDaGlsZH0sdmFsaWRhdGU6dmFsaWRhdGV9O3ZhciBqZT17ZWxlbWVudDpcImRpdlwiLG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSl7ZS5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLFwiM3hcIil9fTt2YXIgQWU9e2VsZW1lbnQ6XCJ0YWJsZVwiLG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSx0LHIpe3ZhciBuPXIuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO24uaW5uZXJIVE1MPVwiPHRyPjx0ZD5jZWxsPC90ZD48L3RyPlwiO2UuYXBwZW5kQ2hpbGQobil9fTt2YXIgT2U9e2VsZW1lbnQ6XCJ2aWRlb1wiLG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSl7dHJ5e2Uuc2V0QXR0cmlidXRlKFwic3JjXCIsWil9Y2F0Y2goZSl7fX19O3ZhciBOZT1BLmlzLkdFQ0tPfHxBLmlzLlRSSURFTlR8fEEuaXMuRURHRTtmdW5jdGlvbiB0YWJzZXF1ZW5jZUFyZWFBdEltZ1Bvc2l0aW9uKCl7cmV0dXJuIE5lfXZhciBJZT17Y3NzU2hhZG93UGllcmNpbmdEZWVwQ29tYmluYXRvcjpjc3NTaGFkb3dQaWVyY2luZ0RlZXBDb21iaW5hdG9yLGZvY3VzSW5aZXJvRGltZW5zaW9uT2JqZWN0OmZvY3VzSW5aZXJvRGltZW5zaW9uT2JqZWN0LGZvY3VzT2JqZWN0U3dmOmZvY3VzT2JqZWN0U3dmLGZvY3VzU3ZnSW5JZnJhbWU6Zm9jdXNTdmdJbklmcmFtZSx0YWJzZXF1ZW5jZUFyZWFBdEltZ1Bvc2l0aW9uOnRhYnNlcXVlbmNlQXJlYUF0SW1nUG9zaXRpb259O3ZhciBGZT17Zm9jdXNBcmVhSW1nVGFiaW5kZXg6VSxmb2N1c0FyZWFUYWJpbmRleDpHLGZvY3VzQXJlYVdpdGhvdXRIcmVmOlgsZm9jdXNBdWRpb1dpdGhvdXRDb250cm9sczpKLGZvY3VzQnJva2VuSW1hZ2VNYXA6WSxmb2N1c0NoaWxkcmVuT2ZGb2N1c2FibGVGbGV4Ym94OmVlLGZvY3VzRmllbGRzZXREaXNhYmxlZDp0ZSxmb2N1c0ZpZWxkc2V0OnJlLGZvY3VzRmxleGJveENvbnRhaW5lcjpuZSxmb2N1c0Zvcm1EaXNhYmxlZDphZSxmb2N1c0ltZ0lzbWFwOm9lLGZvY3VzSW1nVXNlbWFwVGFiaW5kZXg6aWUsZm9jdXNJbkhpZGRlbklmcmFtZTpsZSxmb2N1c0ludmFsaWRUYWJpbmRleDp1ZSxmb2N1c0xhYmVsVGFiaW5kZXg6Y2UsZm9jdXNPYmplY3RTdmc6bWUsZm9jdXNPYmplY3RTdmdIaWRkZW46ZmUsZm9jdXNSZWRpcmVjdEltZ1VzZW1hcDpiZSxmb2N1c1JlZGlyZWN0TGVnZW5kOnZlLGZvY3VzU2Nyb2xsQm9keTpnZSxmb2N1c1Njcm9sbENvbnRhaW5lcldpdGhvdXRPdmVyZmxvdzpoZSxmb2N1c1Njcm9sbENvbnRhaW5lcjp4ZSxmb2N1c1N1bW1hcnk6eWUsZm9jdXNTdmdGb2N1c2FibGVBdHRyaWJ1dGU6RWUsZm9jdXNTdmdUYWJpbmRleEF0dHJpYnV0ZTp3ZSxmb2N1c1N2Z05lZ2F0aXZlVGFiaW5kZXhBdHRyaWJ1dGU6a2UsZm9jdXNTdmdVc2VUYWJpbmRleDpTZSxmb2N1c1N2Z0ZvcmVpZ25vYmplY3RUYWJpbmRleDpfZSxmb2N1c1N2ZzpDZSxmb2N1c1RhYmluZGV4VHJhaWxpbmdDaGFyYWN0ZXJzOmplLGZvY3VzVGFibGU6QWUsZm9jdXNWaWRlb1dpdGhvdXRDb250cm9sczpPZX07ZnVuY3Rpb24gZXhlY3V0ZVRlc3RzKCl7dmFyIGU9ZGV0ZWN0Rm9jdXMoRmUpO09iamVjdC5rZXlzKEllKS5mb3JFYWNoKChmdW5jdGlvbih0KXtlW3RdPUllW3RdKCl9KSk7cmV0dXJuIGV9dmFyIExlPW51bGw7ZnVuY3Rpb24gX3N1cHBvcnRzKCl7aWYoTGUpe3JldHVybiBMZX1MZT1LLmdldCgpO2lmKCFMZS50aW1lKXtLLnNldChleGVjdXRlVGVzdHMoKSk7TGU9Sy5nZXQoKX1yZXR1cm4gTGV9dmFyIERlPXZvaWQgMDt2YXIgTWU9L15cXHMqKC18XFwrKT9bMC05XStcXHMqJC87dmFyIFJlPS9eXFxzKigtfFxcKyk/WzAtOV0rLiokLztmdW5jdGlvbiBpc1ZhbGlkVGFiaW5kZXgoZSl7aWYoIURlKXtEZT1fc3VwcG9ydHMoKX12YXIgdD1EZS5mb2N1c1RhYmluZGV4VHJhaWxpbmdDaGFyYWN0ZXJzP1JlOk1lO3ZhciByPWNvbnRleHRUb0VsZW1lbnQoe2xhYmVsOlwiaXMvdmFsaWQtdGFiaW5kZXhcIixyZXNvbHZlRG9jdW1lbnQ6dHJ1ZSxjb250ZXh0OmV9KTt2YXIgbj1yLmhhc0F0dHJpYnV0ZShcInRhYmluZGV4XCIpO3ZhciBhPXIuaGFzQXR0cmlidXRlKFwidGFiSW5kZXhcIik7aWYoIW4mJiFhKXtyZXR1cm4gZmFsc2V9dmFyIG89ci5vd25lclNWR0VsZW1lbnR8fHIubm9kZU5hbWUudG9Mb3dlckNhc2UoKT09PVwic3ZnXCI7aWYobyYmIURlLmZvY3VzU3ZnVGFiaW5kZXhBdHRyaWJ1dGUpe3JldHVybiBmYWxzZX1pZihEZS5mb2N1c0ludmFsaWRUYWJpbmRleCl7cmV0dXJuIHRydWV9dmFyIGk9ci5nZXRBdHRyaWJ1dGUobj9cInRhYmluZGV4XCI6XCJ0YWJJbmRleFwiKTtpZihpPT09XCItMzI3NjhcIil7cmV0dXJuIGZhbHNlfXJldHVybiBCb29sZWFuKGkmJnQudGVzdChpKSl9ZnVuY3Rpb24gdGFiaW5kZXhWYWx1ZShlKXtpZighaXNWYWxpZFRhYmluZGV4KGUpKXtyZXR1cm4gbnVsbH12YXIgdD1lLmhhc0F0dHJpYnV0ZShcInRhYmluZGV4XCIpO3ZhciByPXQ/XCJ0YWJpbmRleFwiOlwidGFiSW5kZXhcIjt2YXIgbj1wYXJzZUludChlLmdldEF0dHJpYnV0ZShyKSwxMCk7cmV0dXJuIGlzTmFOKG4pPy0xOm59ZnVuY3Rpb24gaXNVc2VyTW9kaWZ5V3JpdGFibGUoZSl7dmFyIHQ9ZS53ZWJraXRVc2VyTW9kaWZ5fHxcIlwiO3JldHVybiBCb29sZWFuKHQmJnQuaW5kZXhPZihcIndyaXRlXCIpIT09LTEpfWZ1bmN0aW9uIGhhc0Nzc092ZXJmbG93U2Nyb2xsKGUpe3JldHVybltlLmdldFByb3BlcnR5VmFsdWUoXCJvdmVyZmxvd1wiKSxlLmdldFByb3BlcnR5VmFsdWUoXCJvdmVyZmxvdy14XCIpLGUuZ2V0UHJvcGVydHlWYWx1ZShcIm92ZXJmbG93LXlcIildLnNvbWUoKGZ1bmN0aW9uKGUpe3JldHVybiBlPT09XCJhdXRvXCJ8fGU9PT1cInNjcm9sbFwifSkpfWZ1bmN0aW9uIGhhc0Nzc0Rpc3BsYXlGbGV4KGUpe3JldHVybiBlLmRpc3BsYXkuaW5kZXhPZihcImZsZXhcIik+LTF9ZnVuY3Rpb24gaXNTY3JvbGxhYmxlQ29udGFpbmVyKGUsdCxyLG4pe2lmKHQhPT1cImRpdlwiJiZ0IT09XCJzcGFuXCIpe3JldHVybiBmYWxzZX1pZihyJiZyIT09XCJkaXZcIiYmciE9PVwic3BhblwiJiYhaGFzQ3NzT3ZlcmZsb3dTY3JvbGwobikpe3JldHVybiBmYWxzZX1yZXR1cm4gZS5vZmZzZXRIZWlnaHQ8ZS5zY3JvbGxIZWlnaHR8fGUub2Zmc2V0V2lkdGg8ZS5zY3JvbGxXaWR0aH12YXIgemU9dm9pZCAwO2Z1bmN0aW9uIGlzRm9jdXNSZWxldmFudFJ1bGVzKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzBdOnt9LHQ9ZS5jb250ZXh0LHI9ZS5leGNlcHQsbj1yPT09dW5kZWZpbmVkP3tmbGV4Ym94OmZhbHNlLHNjcm9sbGFibGU6ZmFsc2Usc2hhZG93OmZhbHNlfTpyO2lmKCF6ZSl7emU9X3N1cHBvcnRzKCl9dmFyIGE9Y29udGV4dFRvRWxlbWVudCh7bGFiZWw6XCJpcy9mb2N1cy1yZWxldmFudFwiLHJlc29sdmVEb2N1bWVudDp0cnVlLGNvbnRleHQ6dH0pO2lmKCFuLnNoYWRvdyYmYS5zaGFkb3dSb290KXtyZXR1cm4gdHJ1ZX12YXIgbz1hLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7aWYobz09PVwiaW5wdXRcIiYmYS50eXBlPT09XCJoaWRkZW5cIil7cmV0dXJuIGZhbHNlfWlmKG89PT1cImlucHV0XCJ8fG89PT1cInNlbGVjdFwifHxvPT09XCJidXR0b25cInx8bz09PVwidGV4dGFyZWFcIil7cmV0dXJuIHRydWV9aWYobz09PVwibGVnZW5kXCImJnplLmZvY3VzUmVkaXJlY3RMZWdlbmQpe3JldHVybiB0cnVlfWlmKG89PT1cImxhYmVsXCIpe3JldHVybiB0cnVlfWlmKG89PT1cImFyZWFcIil7cmV0dXJuIHRydWV9aWYobz09PVwiYVwiJiZhLmhhc0F0dHJpYnV0ZShcImhyZWZcIikpe3JldHVybiB0cnVlfWlmKG89PT1cIm9iamVjdFwiJiZhLmhhc0F0dHJpYnV0ZShcInVzZW1hcFwiKSl7cmV0dXJuIGZhbHNlfWlmKG89PT1cIm9iamVjdFwiKXt2YXIgaT1hLmdldEF0dHJpYnV0ZShcInR5cGVcIik7aWYoIXplLmZvY3VzT2JqZWN0U3ZnJiZpPT09XCJpbWFnZS9zdmcreG1sXCIpe3JldHVybiBmYWxzZX1lbHNlIGlmKCF6ZS5mb2N1c09iamVjdFN3ZiYmaT09PVwiYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2hcIil7cmV0dXJuIGZhbHNlfX1pZihvPT09XCJpZnJhbWVcInx8bz09PVwib2JqZWN0XCIpe3JldHVybiB0cnVlfWlmKG89PT1cImVtYmVkXCJ8fG89PT1cImtleWdlblwiKXtyZXR1cm4gdHJ1ZX1pZihhLmhhc0F0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSl7cmV0dXJuIHRydWV9aWYobz09PVwiYXVkaW9cIiYmKHplLmZvY3VzQXVkaW9XaXRob3V0Q29udHJvbHN8fGEuaGFzQXR0cmlidXRlKFwiY29udHJvbHNcIikpKXtyZXR1cm4gdHJ1ZX1pZihvPT09XCJ2aWRlb1wiJiYoemUuZm9jdXNWaWRlb1dpdGhvdXRDb250cm9sc3x8YS5oYXNBdHRyaWJ1dGUoXCJjb250cm9sc1wiKSkpe3JldHVybiB0cnVlfWlmKHplLmZvY3VzU3VtbWFyeSYmbz09PVwic3VtbWFyeVwiKXtyZXR1cm4gdHJ1ZX12YXIgbD1pc1ZhbGlkVGFiaW5kZXgoYSk7aWYobz09PVwiaW1nXCImJmEuaGFzQXR0cmlidXRlKFwidXNlbWFwXCIpKXtyZXR1cm4gbCYmemUuZm9jdXNJbWdVc2VtYXBUYWJpbmRleHx8emUuZm9jdXNSZWRpcmVjdEltZ1VzZW1hcH1pZih6ZS5mb2N1c1RhYmxlJiYobz09PVwidGFibGVcInx8bz09PVwidGRcIikpe3JldHVybiB0cnVlfWlmKHplLmZvY3VzRmllbGRzZXQmJm89PT1cImZpZWxkc2V0XCIpe3JldHVybiB0cnVlfXZhciBzPW89PT1cInN2Z1wiO3ZhciB1PWEub3duZXJTVkdFbGVtZW50O3ZhciBjPWEuZ2V0QXR0cmlidXRlKFwiZm9jdXNhYmxlXCIpO3ZhciBkPXRhYmluZGV4VmFsdWUoYSk7aWYobz09PVwidXNlXCImJmQhPT1udWxsJiYhemUuZm9jdXNTdmdVc2VUYWJpbmRleCl7cmV0dXJuIGZhbHNlfWlmKG89PT1cImZvcmVpZ25vYmplY3RcIil7cmV0dXJuIGQhPT1udWxsJiZ6ZS5mb2N1c1N2Z0ZvcmVpZ25vYmplY3RUYWJpbmRleH1pZihlbGVtZW50TWF0Y2hlcyhhLFwic3ZnIGFcIikmJmEuaGFzQXR0cmlidXRlKFwieGxpbms6aHJlZlwiKSl7cmV0dXJuIHRydWV9aWYoKHN8fHUpJiZhLmZvY3VzJiYhemUuZm9jdXNTdmdOZWdhdGl2ZVRhYmluZGV4QXR0cmlidXRlJiZkPDApe3JldHVybiBmYWxzZX1pZihzKXtyZXR1cm4gbHx8emUuZm9jdXNTdmd8fHplLmZvY3VzU3ZnSW5JZnJhbWV8fEJvb2xlYW4oemUuZm9jdXNTdmdGb2N1c2FibGVBdHRyaWJ1dGUmJmMmJmM9PT1cInRydWVcIil9aWYodSl7aWYoemUuZm9jdXNTdmdUYWJpbmRleEF0dHJpYnV0ZSYmbCl7cmV0dXJuIHRydWV9aWYoemUuZm9jdXNTdmdGb2N1c2FibGVBdHRyaWJ1dGUpe3JldHVybiBjPT09XCJ0cnVlXCJ9fWlmKGwpe3JldHVybiB0cnVlfXZhciBmPXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGEsbnVsbCk7aWYoaXNVc2VyTW9kaWZ5V3JpdGFibGUoZikpe3JldHVybiB0cnVlfWlmKHplLmZvY3VzSW1nSXNtYXAmJm89PT1cImltZ1wiJiZhLmhhc0F0dHJpYnV0ZShcImlzbWFwXCIpKXt2YXIgbT1nZXRQYXJlbnRzKHtjb250ZXh0OmF9KS5zb21lKChmdW5jdGlvbihlKXtyZXR1cm4gZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09XCJhXCImJmUuaGFzQXR0cmlidXRlKFwiaHJlZlwiKX0pKTtpZihtKXtyZXR1cm4gdHJ1ZX19aWYoIW4uc2Nyb2xsYWJsZSYmemUuZm9jdXNTY3JvbGxDb250YWluZXIpe2lmKHplLmZvY3VzU2Nyb2xsQ29udGFpbmVyV2l0aG91dE92ZXJmbG93KXtpZihpc1Njcm9sbGFibGVDb250YWluZXIoYSxvKSl7cmV0dXJuIHRydWV9fWVsc2UgaWYoaGFzQ3NzT3ZlcmZsb3dTY3JvbGwoZikpe3JldHVybiB0cnVlfX1pZighbi5mbGV4Ym94JiZ6ZS5mb2N1c0ZsZXhib3hDb250YWluZXImJmhhc0Nzc0Rpc3BsYXlGbGV4KGYpKXtyZXR1cm4gdHJ1ZX12YXIgcD1hLnBhcmVudEVsZW1lbnQ7aWYoIW4uc2Nyb2xsYWJsZSYmcCl7dmFyIGI9cC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3ZhciB2PXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHAsbnVsbCk7aWYoemUuZm9jdXNTY3JvbGxCb2R5JiZpc1Njcm9sbGFibGVDb250YWluZXIocCxvLGIsdikpe3JldHVybiB0cnVlfWlmKHplLmZvY3VzQ2hpbGRyZW5PZkZvY3VzYWJsZUZsZXhib3gpe2lmKGhhc0Nzc0Rpc3BsYXlGbGV4KHYpKXtyZXR1cm4gdHJ1ZX19fXJldHVybiBmYWxzZX1pc0ZvY3VzUmVsZXZhbnRSdWxlcy5leGNlcHQ9ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06e307dmFyIHQ9ZnVuY3Rpb24gaXNGb2N1c1JlbGV2YW50KHQpe3JldHVybiBpc0ZvY3VzUmVsZXZhbnRSdWxlcyh7Y29udGV4dDp0LGV4Y2VwdDplfSl9O3QucnVsZXM9aXNGb2N1c1JlbGV2YW50UnVsZXM7cmV0dXJuIHR9O3ZhciBCZT1pc0ZvY3VzUmVsZXZhbnRSdWxlcy5leGNlcHQoe30pO2Z1bmN0aW9uIGZpbmRJbmRleChlLHQpe2lmKGUuZmluZEluZGV4KXtyZXR1cm4gZS5maW5kSW5kZXgodCl9dmFyIHI9ZS5sZW5ndGg7aWYocj09PTApe3JldHVybi0xfWZvcih2YXIgbj0wO248cjtuKyspe2lmKHQoZVtuXSxuLGUpKXtyZXR1cm4gbn19cmV0dXJuLTF9ZnVuY3Rpb24gZ2V0Q29udGVudERvY3VtZW50KGUpe3RyeXtyZXR1cm4gZS5jb250ZW50RG9jdW1lbnR8fGUuY29udGVudFdpbmRvdyYmZS5jb250ZW50V2luZG93LmRvY3VtZW50fHxlLmdldFNWR0RvY3VtZW50JiZlLmdldFNWR0RvY3VtZW50KCl8fG51bGx9Y2F0Y2goZSl7cmV0dXJuIG51bGx9fWZ1bmN0aW9uIGdldFdpbmRvdyhlKXt2YXIgdD1nZXREb2N1bWVudChlKTtyZXR1cm4gdC5kZWZhdWx0Vmlld3x8d2luZG93fXZhciBIZT12b2lkIDA7ZnVuY3Rpb24gc2VsZWN0SW5TaGFkb3dzKGUpe2lmKHR5cGVvZiBIZSE9PVwic3RyaW5nXCIpe3ZhciB0PWNzc1NoYWRvd1BpZXJjaW5nRGVlcENvbWJpbmF0b3IoKTtpZih0KXtIZT1cIiwgaHRtbCBcIit0K1wiIFwifX1pZighSGUpe3JldHVybiBlfXJldHVybiBlK0hlK2UucmVwbGFjZSgvXFxzKixcXHMqL2csXCIsXCIpLnNwbGl0KFwiLFwiKS5qb2luKEhlKX12YXIgcWU9dm9pZCAwO2Z1bmN0aW9uIGZpbmREb2N1bWVudEhvc3RFbGVtZW50KGUpe2lmKCFxZSl7cWU9c2VsZWN0SW5TaGFkb3dzKFwib2JqZWN0LCBpZnJhbWVcIil9aWYoZS5fZnJhbWVFbGVtZW50IT09dW5kZWZpbmVkKXtyZXR1cm4gZS5fZnJhbWVFbGVtZW50fWUuX2ZyYW1lRWxlbWVudD1udWxsO3ZhciB0PWUucGFyZW50LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocWUpO1tdLnNvbWUuY2FsbCh0LChmdW5jdGlvbih0KXt2YXIgcj1nZXRDb250ZW50RG9jdW1lbnQodCk7aWYociE9PWUuZG9jdW1lbnQpe3JldHVybiBmYWxzZX1lLl9mcmFtZUVsZW1lbnQ9dDtyZXR1cm4gdHJ1ZX0pKTtyZXR1cm4gZS5fZnJhbWVFbGVtZW50fWZ1bmN0aW9uIGdldEZyYW1lRWxlbWVudChlKXt2YXIgdD1nZXRXaW5kb3coZSk7aWYoIXQucGFyZW50fHx0LnBhcmVudD09PXQpe3JldHVybiBudWxsfXRyeXtyZXR1cm4gdC5mcmFtZUVsZW1lbnR8fGZpbmREb2N1bWVudEhvc3RFbGVtZW50KHQpfWNhdGNoKGUpe3JldHVybiBudWxsfX12YXIgUGU9L14oYXJlYSkkLztmdW5jdGlvbiBjb21wdXRlZFN0eWxlKGUsdCl7cmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGUsbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZSh0KX1mdW5jdGlvbiBub3REaXNwbGF5ZWQoZSl7cmV0dXJuIGUuc29tZSgoZnVuY3Rpb24oZSl7cmV0dXJuIGNvbXB1dGVkU3R5bGUoZSxcImRpc3BsYXlcIik9PT1cIm5vbmVcIn0pKX1mdW5jdGlvbiBub3RWaXNpYmxlKGUpe3ZhciB0PWZpbmRJbmRleChlLChmdW5jdGlvbihlKXt2YXIgdD1jb21wdXRlZFN0eWxlKGUsXCJ2aXNpYmlsaXR5XCIpO3JldHVybiB0PT09XCJoaWRkZW5cInx8dD09PVwiY29sbGFwc2VcIn0pKTtpZih0PT09LTEpe3JldHVybiBmYWxzZX12YXIgcj1maW5kSW5kZXgoZSwoZnVuY3Rpb24oZSl7cmV0dXJuIGNvbXB1dGVkU3R5bGUoZSxcInZpc2liaWxpdHlcIik9PT1cInZpc2libGVcIn0pKTtpZihyPT09LTEpe3JldHVybiB0cnVlfWlmKHQ8cil7cmV0dXJuIHRydWV9cmV0dXJuIGZhbHNlfWZ1bmN0aW9uIGNvbGxhcHNlZFBhcmVudChlKXt2YXIgdD0xO2lmKGVbMF0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKT09PVwic3VtbWFyeVwiKXt0PTJ9cmV0dXJuIGUuc2xpY2UodCkuc29tZSgoZnVuY3Rpb24oZSl7cmV0dXJuIGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKT09PVwiZGV0YWlsc1wiJiZlLm9wZW49PT1mYWxzZX0pKX1mdW5jdGlvbiBpc1Zpc2libGVSdWxlcygpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTp7fSx0PWUuY29udGV4dCxyPWUuZXhjZXB0LG49cj09PXVuZGVmaW5lZD97bm90UmVuZGVyZWQ6ZmFsc2UsY3NzRGlzcGxheTpmYWxzZSxjc3NWaXNpYmlsaXR5OmZhbHNlLGRldGFpbHNFbGVtZW50OmZhbHNlLGJyb3dzaW5nQ29udGV4dDpmYWxzZX06cjt2YXIgYT1jb250ZXh0VG9FbGVtZW50KHtsYWJlbDpcImlzL3Zpc2libGVcIixyZXNvbHZlRG9jdW1lbnQ6dHJ1ZSxjb250ZXh0OnR9KTt2YXIgbz1hLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7aWYoIW4ubm90UmVuZGVyZWQmJlBlLnRlc3Qobykpe3JldHVybiB0cnVlfXZhciBpPWdldFBhcmVudHMoe2NvbnRleHQ6YX0pO3ZhciBsPW89PT1cImF1ZGlvXCImJiFhLmhhc0F0dHJpYnV0ZShcImNvbnRyb2xzXCIpO2lmKCFuLmNzc0Rpc3BsYXkmJm5vdERpc3BsYXllZChsP2kuc2xpY2UoMSk6aSkpe3JldHVybiBmYWxzZX1pZighbi5jc3NWaXNpYmlsaXR5JiZub3RWaXNpYmxlKGkpKXtyZXR1cm4gZmFsc2V9aWYoIW4uZGV0YWlsc0VsZW1lbnQmJmNvbGxhcHNlZFBhcmVudChpKSl7cmV0dXJuIGZhbHNlfWlmKCFuLmJyb3dzaW5nQ29udGV4dCl7dmFyIHM9Z2V0RnJhbWVFbGVtZW50KGEpO3ZhciB1PWlzVmlzaWJsZVJ1bGVzLmV4Y2VwdChuKTtpZihzJiYhdShzKSl7cmV0dXJuIGZhbHNlfX1yZXR1cm4gdHJ1ZX1pc1Zpc2libGVSdWxlcy5leGNlcHQ9ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06e307dmFyIHQ9ZnVuY3Rpb24gaXNWaXNpYmxlKHQpe3JldHVybiBpc1Zpc2libGVSdWxlcyh7Y29udGV4dDp0LGV4Y2VwdDplfSl9O3QucnVsZXM9aXNWaXNpYmxlUnVsZXM7cmV0dXJuIHR9O3ZhciBXZT1pc1Zpc2libGVSdWxlcy5leGNlcHQoe30pO2Z1bmN0aW9uIGdldE1hcEJ5TmFtZShlLHQpe3ZhciByPXQucXVlcnlTZWxlY3RvcignbWFwW25hbWU9XCInK1QoKShlKSsnXCJdJyk7cmV0dXJuIHJ8fG51bGx9ZnVuY3Rpb24gZ2V0SW1hZ2VPZkFyZWEoZSl7dmFyIHQ9ZS5wYXJlbnRFbGVtZW50O2lmKCF0Lm5hbWV8fHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSE9PVwibWFwXCIpe3JldHVybiBudWxsfXZhciByPWdldERvY3VtZW50KGUpO3JldHVybiByLnF1ZXJ5U2VsZWN0b3IoJ2ltZ1t1c2VtYXA9XCIjJytUKCkodC5uYW1lKSsnXCJdJyl8fG51bGx9dmFyIFZlPXZvaWQgMDtmdW5jdGlvbiBpc1ZhbGlkQXJlYShlKXtpZighVmUpe1ZlPV9zdXBwb3J0cygpfXZhciB0PWNvbnRleHRUb0VsZW1lbnQoe2xhYmVsOlwiaXMvdmFsaWQtYXJlYVwiLGNvbnRleHQ6ZX0pO3ZhciByPXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtpZihyIT09XCJhcmVhXCIpe3JldHVybiBmYWxzZX12YXIgbj10Lmhhc0F0dHJpYnV0ZShcInRhYmluZGV4XCIpO2lmKCFWZS5mb2N1c0FyZWFUYWJpbmRleCYmbil7cmV0dXJuIGZhbHNlfXZhciBhPWdldEltYWdlT2ZBcmVhKHQpO2lmKCFhfHwhV2UoYSkpe3JldHVybiBmYWxzZX1pZighVmUuZm9jdXNCcm9rZW5JbWFnZU1hcCYmKCFhLmNvbXBsZXRlfHwhYS5uYXR1cmFsSGVpZ2h0fHxhLm9mZnNldFdpZHRoPD0wfHxhLm9mZnNldEhlaWdodDw9MCkpe3JldHVybiBmYWxzZX1pZighVmUuZm9jdXNBcmVhV2l0aG91dEhyZWYmJiF0LmhyZWYpe3JldHVybiBWZS5mb2N1c0FyZWFUYWJpbmRleCYmbnx8VmUuZm9jdXNBcmVhSW1nVGFiaW5kZXgmJmEuaGFzQXR0cmlidXRlKFwidGFiaW5kZXhcIil9dmFyIG89Z2V0UGFyZW50cyh7Y29udGV4dDphfSkuc2xpY2UoMSkuc29tZSgoZnVuY3Rpb24oZSl7dmFyIHQ9ZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVybiB0PT09XCJidXR0b25cInx8dD09PVwiYVwifSkpO2lmKG8pe3JldHVybiBmYWxzZX1yZXR1cm4gdHJ1ZX12YXIgJGU9dm9pZCAwO3ZhciBLZT12b2lkIDA7dmFyIFplPXtpbnB1dDp0cnVlLHNlbGVjdDp0cnVlLHRleHRhcmVhOnRydWUsYnV0dG9uOnRydWUsZmllbGRzZXQ6dHJ1ZSxmb3JtOnRydWV9O2Z1bmN0aW9uIGlzTmF0aXZlRGlzYWJsZWRTdXBwb3J0ZWQoZSl7aWYoISRlKXskZT1fc3VwcG9ydHMoKTtpZigkZS5mb2N1c0ZpZWxkc2V0RGlzYWJsZWQpe2RlbGV0ZSBaZS5maWVsZHNldH1pZigkZS5mb2N1c0Zvcm1EaXNhYmxlZCl7ZGVsZXRlIFplLmZvcm19S2U9bmV3IFJlZ0V4cChcIl4oXCIrT2JqZWN0LmtleXMoWmUpLmpvaW4oXCJ8XCIpK1wiKSRcIil9dmFyIHQ9Y29udGV4dFRvRWxlbWVudCh7bGFiZWw6XCJpcy9uYXRpdmUtZGlzYWJsZWQtc3VwcG9ydGVkXCIsY29udGV4dDplfSk7dmFyIHI9dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVybiBCb29sZWFuKEtlLnRlc3QocikpfXZhciBVZT12b2lkIDA7ZnVuY3Rpb24gaXNEaXNhYmxlZEZpZWxkc2V0KGUpe3ZhciB0PWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gdD09PVwiZmllbGRzZXRcIiYmZS5kaXNhYmxlZH1mdW5jdGlvbiBpc0Rpc2FibGVkRm9ybShlKXt2YXIgdD1lLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIHQ9PT1cImZvcm1cIiYmZS5kaXNhYmxlZH1mdW5jdGlvbiBpc0Rpc2FibGVkKGUpe2lmKCFVZSl7VWU9X3N1cHBvcnRzKCl9dmFyIHQ9Y29udGV4dFRvRWxlbWVudCh7bGFiZWw6XCJpcy9kaXNhYmxlZFwiLGNvbnRleHQ6ZX0pO2lmKHQuaGFzQXR0cmlidXRlKFwiZGF0YS1hbGx5LWRpc2FibGVkXCIpKXtyZXR1cm4gdHJ1ZX1pZighaXNOYXRpdmVEaXNhYmxlZFN1cHBvcnRlZCh0KSl7cmV0dXJuIGZhbHNlfWlmKHQuZGlzYWJsZWQpe3JldHVybiB0cnVlfXZhciByPWdldFBhcmVudHMoe2NvbnRleHQ6dH0pO2lmKHIuc29tZShpc0Rpc2FibGVkRmllbGRzZXQpKXtyZXR1cm4gdHJ1ZX1pZighVWUuZm9jdXNGb3JtRGlzYWJsZWQmJnIuc29tZShpc0Rpc2FibGVkRm9ybSkpe3JldHVybiB0cnVlfXJldHVybiBmYWxzZX1mdW5jdGlvbiBpc09ubHlUYWJiYWJsZVJ1bGVzKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzBdOnt9LHQ9ZS5jb250ZXh0LHI9ZS5leGNlcHQsbj1yPT09dW5kZWZpbmVkP3tvbmx5Rm9jdXNhYmxlQnJvd3NpbmdDb250ZXh0OmZhbHNlLHZpc2libGU6ZmFsc2V9OnI7dmFyIGE9Y29udGV4dFRvRWxlbWVudCh7bGFiZWw6XCJpcy9vbmx5LXRhYmJhYmxlXCIscmVzb2x2ZURvY3VtZW50OnRydWUsY29udGV4dDp0fSk7aWYoIW4udmlzaWJsZSYmIVdlKGEpKXtyZXR1cm4gZmFsc2V9aWYoIW4ub25seUZvY3VzYWJsZUJyb3dzaW5nQ29udGV4dCYmKEEuaXMuR0VDS098fEEuaXMuVFJJREVOVHx8QS5pcy5FREdFKSl7dmFyIG89Z2V0RnJhbWVFbGVtZW50KGEpO2lmKG8pe2lmKHRhYmluZGV4VmFsdWUobyk8MCl7cmV0dXJuIGZhbHNlfX19dmFyIGk9YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3ZhciBsPXRhYmluZGV4VmFsdWUoYSk7aWYoaT09PVwibGFiZWxcIiYmQS5pcy5HRUNLTyl7cmV0dXJuIGwhPT1udWxsJiZsPj0wfWlmKEEuaXMuR0VDS08mJmEub3duZXJTVkdFbGVtZW50JiYhYS5mb2N1cyl7aWYoaT09PVwiYVwiJiZhLmhhc0F0dHJpYnV0ZShcInhsaW5rOmhyZWZcIikpe2lmKEEuaXMuR0VDS08pe3JldHVybiB0cnVlfX19cmV0dXJuIGZhbHNlfWlzT25seVRhYmJhYmxlUnVsZXMuZXhjZXB0PWZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzBdOnt9O3ZhciB0PWZ1bmN0aW9uIGlzT25seVRhYmJhYmxlKHQpe3JldHVybiBpc09ubHlUYWJiYWJsZVJ1bGVzKHtjb250ZXh0OnQsZXhjZXB0OmV9KX07dC5ydWxlcz1pc09ubHlUYWJiYWJsZVJ1bGVzO3JldHVybiB0fTt2YXIgR2U9aXNPbmx5VGFiYmFibGVSdWxlcy5leGNlcHQoe30pO3ZhciBYZT12b2lkIDA7ZnVuY3Rpb24gaXNPbmx5Rm9jdXNSZWxldmFudChlKXt2YXIgdD1lLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7aWYodD09PVwiZW1iZWRcInx8dD09PVwia2V5Z2VuXCIpe3JldHVybiB0cnVlfXZhciByPXRhYmluZGV4VmFsdWUoZSk7aWYoZS5zaGFkb3dSb290JiZyPT09bnVsbCl7cmV0dXJuIHRydWV9aWYodD09PVwibGFiZWxcIil7cmV0dXJuIVhlLmZvY3VzTGFiZWxUYWJpbmRleHx8cj09PW51bGx9aWYodD09PVwibGVnZW5kXCIpe3JldHVybiByPT09bnVsbH1pZihYZS5mb2N1c1N2Z0ZvY3VzYWJsZUF0dHJpYnV0ZSYmKGUub3duZXJTVkdFbGVtZW50fHx0PT09XCJzdmdcIikpe3ZhciBuPWUuZ2V0QXR0cmlidXRlKFwiZm9jdXNhYmxlXCIpO3JldHVybiBuJiZuPT09XCJmYWxzZVwifWlmKHQ9PT1cImltZ1wiJiZlLmhhc0F0dHJpYnV0ZShcInVzZW1hcFwiKSl7cmV0dXJuIHI9PT1udWxsfHwhWGUuZm9jdXNJbWdVc2VtYXBUYWJpbmRleH1pZih0PT09XCJhcmVhXCIpe3JldHVybiFpc1ZhbGlkQXJlYShlKX1yZXR1cm4gZmFsc2V9ZnVuY3Rpb24gaXNGb2N1c2FibGVSdWxlcygpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTp7fSx0PWUuY29udGV4dCxyPWUuZXhjZXB0LG49cj09PXVuZGVmaW5lZD97ZGlzYWJsZWQ6ZmFsc2UsdmlzaWJsZTpmYWxzZSxvbmx5VGFiYmFibGU6ZmFsc2V9OnI7aWYoIVhlKXtYZT1fc3VwcG9ydHMoKX12YXIgYT1HZS5ydWxlcy5leGNlcHQoe29ubHlGb2N1c2FibGVCcm93c2luZ0NvbnRleHQ6dHJ1ZSx2aXNpYmxlOm4udmlzaWJsZX0pO3ZhciBvPWNvbnRleHRUb0VsZW1lbnQoe2xhYmVsOlwiaXMvZm9jdXNhYmxlXCIscmVzb2x2ZURvY3VtZW50OnRydWUsY29udGV4dDp0fSk7dmFyIGk9QmUucnVsZXMoe2NvbnRleHQ6byxleGNlcHQ6bn0pO2lmKCFpfHxpc09ubHlGb2N1c1JlbGV2YW50KG8pKXtyZXR1cm4gZmFsc2V9aWYoIW4uZGlzYWJsZWQmJmlzRGlzYWJsZWQobykpe3JldHVybiBmYWxzZX1pZighbi5vbmx5VGFiYmFibGUmJmEobykpe3JldHVybiBmYWxzZX1pZighbi52aXNpYmxlKXt2YXIgbD17Y29udGV4dDpvLGV4Y2VwdDp7fX07aWYoWGUuZm9jdXNJbkhpZGRlbklmcmFtZSl7bC5leGNlcHQuYnJvd3NpbmdDb250ZXh0PXRydWV9aWYoWGUuZm9jdXNPYmplY3RTdmdIaWRkZW4pe3ZhciBzPW8ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtpZihzPT09XCJvYmplY3RcIil7bC5leGNlcHQuY3NzVmlzaWJpbGl0eT10cnVlfX1pZighV2UucnVsZXMobCkpe3JldHVybiBmYWxzZX19dmFyIHU9Z2V0RnJhbWVFbGVtZW50KG8pO2lmKHUpe3ZhciBjPXUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtpZihjPT09XCJvYmplY3RcIiYmIVhlLmZvY3VzSW5aZXJvRGltZW5zaW9uT2JqZWN0KXtpZighdS5vZmZzZXRXaWR0aHx8IXUub2Zmc2V0SGVpZ2h0KXtyZXR1cm4gZmFsc2V9fX12YXIgZD1vLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7aWYoZD09PVwic3ZnXCImJlhlLmZvY3VzU3ZnSW5JZnJhbWUmJiF1JiZvLmdldEF0dHJpYnV0ZShcInRhYmluZGV4XCIpPT09bnVsbCl7cmV0dXJuIGZhbHNlfXJldHVybiB0cnVlfWlzRm9jdXNhYmxlUnVsZXMuZXhjZXB0PWZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzBdOnt9O3ZhciB0PWZ1bmN0aW9uIGlzRm9jdXNhYmxlKHQpe3JldHVybiBpc0ZvY3VzYWJsZVJ1bGVzKHtjb250ZXh0OnQsZXhjZXB0OmV9KX07dC5ydWxlcz1pc0ZvY3VzYWJsZVJ1bGVzO3JldHVybiB0fTt2YXIgSmU9aXNGb2N1c2FibGVSdWxlcy5leGNlcHQoe30pO2Z1bmN0aW9uIGNyZWF0ZUZpbHRlcihlKXt2YXIgdD1mdW5jdGlvbiBmaWx0ZXIodCl7aWYodC5zaGFkb3dSb290KXtyZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUfWlmKGUodCkpe3JldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFR9cmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1NLSVB9O3QuYWNjZXB0Tm9kZT10O3JldHVybiB0fXZhciBRZT1jcmVhdGVGaWx0ZXIoQmUpO2Z1bmN0aW9uIHF1ZXJ5Rm9jdXNhYmxlU3RyaWN0KCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzBdOnt9LHQ9ZS5jb250ZXh0LHI9ZS5pbmNsdWRlQ29udGV4dCxuPWUuaW5jbHVkZU9ubHlUYWJiYWJsZSxhPWUuc3RyYXRlZ3k7aWYoIXQpe3Q9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50fXZhciBvPUplLnJ1bGVzLmV4Y2VwdCh7b25seVRhYmJhYmxlOm59KTt2YXIgaT1nZXREb2N1bWVudCh0KTt2YXIgbD1pLmNyZWF0ZVRyZWVXYWxrZXIodCxOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCxhPT09XCJhbGxcIj9RZTpjcmVhdGVGaWx0ZXIobyksZmFsc2UpO3ZhciBzPVtdO3doaWxlKGwubmV4dE5vZGUoKSl7aWYobC5jdXJyZW50Tm9kZS5zaGFkb3dSb290KXtpZihvKGwuY3VycmVudE5vZGUpKXtzLnB1c2gobC5jdXJyZW50Tm9kZSl9cz1zLmNvbmNhdChxdWVyeUZvY3VzYWJsZVN0cmljdCh7Y29udGV4dDpsLmN1cnJlbnROb2RlLnNoYWRvd1Jvb3QsaW5jbHVkZU9ubHlUYWJiYWJsZTpuLHN0cmF0ZWd5OmF9KSl9ZWxzZXtzLnB1c2gobC5jdXJyZW50Tm9kZSl9fWlmKHIpe2lmKGE9PT1cImFsbFwiKXtpZihCZSh0KSl7cy51bnNoaWZ0KHQpfX1lbHNlIGlmKG8odCkpe3MudW5zaGlmdCh0KX19cmV0dXJuIHN9dmFyIFllPXZvaWQgMDt2YXIgZXQ9dm9pZCAwO2Z1bmN0aW9uIHNlbGVjdG9yJDIoKXtpZighWWUpe1llPV9zdXBwb3J0cygpfWlmKHR5cGVvZiBldD09PVwic3RyaW5nXCIpe3JldHVybiBldH1ldD1cIlwiKyhZZS5mb2N1c1RhYmxlP1widGFibGUsIHRkLFwiOlwiXCIpKyhZZS5mb2N1c0ZpZWxkc2V0P1wiZmllbGRzZXQsXCI6XCJcIikrXCJzdmcgYSxcIitcImFbaHJlZl0sXCIrXCJhcmVhW2hyZWZdLFwiK1wiaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIGJ1dHRvbixcIitcImlmcmFtZSwgb2JqZWN0LCBlbWJlZCxcIitcImtleWdlbixcIisoWWUuZm9jdXNBdWRpb1dpdGhvdXRDb250cm9scz9cImF1ZGlvLFwiOlwiYXVkaW9bY29udHJvbHNdLFwiKSsoWWUuZm9jdXNWaWRlb1dpdGhvdXRDb250cm9scz9cInZpZGVvLFwiOlwidmlkZW9bY29udHJvbHNdLFwiKSsoWWUuZm9jdXNTdW1tYXJ5P1wic3VtbWFyeSxcIjpcIlwiKStcIlt0YWJpbmRleF0sXCIrXCJbY29udGVudGVkaXRhYmxlXVwiO2V0PXNlbGVjdEluU2hhZG93cyhldCk7cmV0dXJuIGV0fWZ1bmN0aW9uIHF1ZXJ5Rm9jdXNhYmxlUXVpY2soKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06e30sdD1lLmNvbnRleHQscj1lLmluY2x1ZGVDb250ZXh0LG49ZS5pbmNsdWRlT25seVRhYmJhYmxlO3ZhciBhPXNlbGVjdG9yJDIoKTt2YXIgbz10LnF1ZXJ5U2VsZWN0b3JBbGwoYSk7dmFyIGk9SmUucnVsZXMuZXhjZXB0KHtvbmx5VGFiYmFibGU6bn0pO3ZhciBsPVtdLmZpbHRlci5jYWxsKG8saSk7aWYociYmaSh0KSl7bC51bnNoaWZ0KHQpfXJldHVybiBsfWZ1bmN0aW9uIHF1ZXJ5Rm9jdXNhYmxlKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzBdOnt9LHQ9ZS5jb250ZXh0LHI9ZS5pbmNsdWRlQ29udGV4dCxuPWUuaW5jbHVkZU9ubHlUYWJiYWJsZSxhPWUuc3RyYXRlZ3ksbz1hPT09dW5kZWZpbmVkP1wicXVpY2tcIjphO3ZhciBpPWNvbnRleHRUb0VsZW1lbnQoe2xhYmVsOlwicXVlcnkvZm9jdXNhYmxlXCIscmVzb2x2ZURvY3VtZW50OnRydWUsZGVmYXVsdFRvRG9jdW1lbnQ6dHJ1ZSxjb250ZXh0OnR9KTt2YXIgbD17Y29udGV4dDppLGluY2x1ZGVDb250ZXh0OnIsaW5jbHVkZU9ubHlUYWJiYWJsZTpuLHN0cmF0ZWd5Om99O2lmKG89PT1cInF1aWNrXCIpe3JldHVybiBxdWVyeUZvY3VzYWJsZVF1aWNrKGwpfWVsc2UgaWYobz09PVwic3RyaWN0XCJ8fG89PT1cImFsbFwiKXtyZXR1cm4gcXVlcnlGb2N1c2FibGVTdHJpY3QobCl9dGhyb3cgbmV3IFR5cGVFcnJvcigncXVlcnkvZm9jdXNhYmxlIHJlcXVpcmVzIG9wdGlvbi5zdHJhdGVneSB0byBiZSBvbmUgb2YgW1wicXVpY2tcIiwgXCJzdHJpY3RcIiwgXCJhbGxcIl0nKX12YXIgdHQ9dm9pZCAwO3ZhciBydD0vXihmaWVsZHNldHx0YWJsZXx0ZHxib2R5KSQvO2Z1bmN0aW9uIGlzVGFiYmFibGVSdWxlcygpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTp7fSx0PWUuY29udGV4dCxyPWUuZXhjZXB0LG49cj09PXVuZGVmaW5lZD97ZmxleGJveDpmYWxzZSxzY3JvbGxhYmxlOmZhbHNlLHNoYWRvdzpmYWxzZSx2aXNpYmxlOmZhbHNlLG9ubHlUYWJiYWJsZTpmYWxzZX06cjtpZighdHQpe3R0PV9zdXBwb3J0cygpfXZhciBhPWNvbnRleHRUb0VsZW1lbnQoe2xhYmVsOlwiaXMvdGFiYmFibGVcIixyZXNvbHZlRG9jdW1lbnQ6dHJ1ZSxjb250ZXh0OnR9KTtpZihBLmlzLkJMSU5LJiZBLmlzLkFORFJPSUQmJkEubWFqb3JWZXJzaW9uPjQyKXtyZXR1cm4gZmFsc2V9dmFyIG89Z2V0RnJhbWVFbGVtZW50KGEpO2lmKG8pe2lmKEEuaXMuV0VCS0lUJiZBLmlzLklPUyl7cmV0dXJuIGZhbHNlfWlmKHRhYmluZGV4VmFsdWUobyk8MCl7cmV0dXJuIGZhbHNlfWlmKCFuLnZpc2libGUmJihBLmlzLkJMSU5LfHxBLmlzLldFQktJVCkmJiFXZShvKSl7cmV0dXJuIGZhbHNlfXZhciBpPW8ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtpZihpPT09XCJvYmplY3RcIil7dmFyIGw9QS5uYW1lPT09XCJDaHJvbWVcIiYmQS5tYWpvclZlcnNpb24+PTU0fHxBLm5hbWU9PT1cIk9wZXJhXCImJkEubWFqb3JWZXJzaW9uPj00MTtpZihBLmlzLldFQktJVHx8QS5pcy5CTElOSyYmIWwpe3JldHVybiBmYWxzZX19fXZhciBzPWEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTt2YXIgdT10YWJpbmRleFZhbHVlKGEpO3ZhciBjPXU9PT1udWxsP251bGw6dT49MDtpZihBLmlzLkVER0UmJkEubWFqb3JWZXJzaW9uPj0xNCYmbyYmYS5vd25lclNWR0VsZW1lbnQmJnU8MCl7cmV0dXJuIHRydWV9dmFyIGQ9YyE9PWZhbHNlO3ZhciBmPXUhPT1udWxsJiZ1Pj0wO2lmKGEuaGFzQXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpKXtyZXR1cm4gZH1pZihydC50ZXN0KHMpJiZjIT09dHJ1ZSl7cmV0dXJuIGZhbHNlfWlmKEEuaXMuV0VCS0lUJiZBLmlzLklPUyl7dmFyIG09cz09PVwiaW5wdXRcIiYmYS50eXBlPT09XCJ0ZXh0XCJ8fGEudHlwZT09PVwicGFzc3dvcmRcInx8cz09PVwic2VsZWN0XCJ8fHM9PT1cInRleHRhcmVhXCJ8fGEuaGFzQXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpO2lmKCFtKXt2YXIgcD13aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShhLG51bGwpO209aXNVc2VyTW9kaWZ5V3JpdGFibGUocCl9aWYoIW0pe3JldHVybiBmYWxzZX19aWYocz09PVwidXNlXCImJnUhPT1udWxsKXtpZihBLmlzLkJMSU5LfHxBLmlzLldFQktJVCYmQS5tYWpvclZlcnNpb249PT05KXtyZXR1cm4gdHJ1ZX19aWYoZWxlbWVudE1hdGNoZXMoYSxcInN2ZyBhXCIpJiZhLmhhc0F0dHJpYnV0ZShcInhsaW5rOmhyZWZcIikpe2lmKGQpe3JldHVybiB0cnVlfWlmKGEuZm9jdXMmJiF0dC5mb2N1c1N2Z05lZ2F0aXZlVGFiaW5kZXhBdHRyaWJ1dGUpe3JldHVybiB0cnVlfX1pZihzPT09XCJzdmdcIiYmdHQuZm9jdXNTdmdJbklmcmFtZSYmZCl7cmV0dXJuIHRydWV9aWYoQS5pcy5UUklERU5UfHxBLmlzLkVER0Upe2lmKHM9PT1cInN2Z1wiKXtpZih0dC5mb2N1c1N2Zyl7cmV0dXJuIHRydWV9cmV0dXJuIGEuaGFzQXR0cmlidXRlKFwiZm9jdXNhYmxlXCIpfHxmfWlmKGEub3duZXJTVkdFbGVtZW50KXtpZih0dC5mb2N1c1N2Z1RhYmluZGV4QXR0cmlidXRlJiZmKXtyZXR1cm4gdHJ1ZX1yZXR1cm4gYS5oYXNBdHRyaWJ1dGUoXCJmb2N1c2FibGVcIil9fWlmKGEudGFiSW5kZXg9PT11bmRlZmluZWQpe3JldHVybiBCb29sZWFuKG4ub25seVRhYmJhYmxlKX1pZihzPT09XCJhdWRpb1wiKXtpZighYS5oYXNBdHRyaWJ1dGUoXCJjb250cm9sc1wiKSl7cmV0dXJuIGZhbHNlfWVsc2UgaWYoQS5pcy5CTElOSyl7cmV0dXJuIHRydWV9fWlmKHM9PT1cInZpZGVvXCIpe2lmKCFhLmhhc0F0dHJpYnV0ZShcImNvbnRyb2xzXCIpKXtpZihBLmlzLlRSSURFTlR8fEEuaXMuRURHRSl7cmV0dXJuIGZhbHNlfX1lbHNlIGlmKEEuaXMuQkxJTkt8fEEuaXMuR0VDS08pe3JldHVybiB0cnVlfX1pZihzPT09XCJvYmplY3RcIil7aWYoQS5pcy5CTElOS3x8QS5pcy5XRUJLSVQpe3JldHVybiBmYWxzZX19aWYocz09PVwiaWZyYW1lXCIpe3JldHVybiBmYWxzZX1pZighbi5zY3JvbGxhYmxlJiZBLmlzLkdFQ0tPKXt2YXIgYj13aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShhLG51bGwpO2lmKGhhc0Nzc092ZXJmbG93U2Nyb2xsKGIpKXtyZXR1cm4gZH19aWYoQS5pcy5UUklERU5UfHxBLmlzLkVER0Upe2lmKHM9PT1cImFyZWFcIil7dmFyIHY9Z2V0SW1hZ2VPZkFyZWEoYSk7aWYodiYmdGFiaW5kZXhWYWx1ZSh2KTwwKXtyZXR1cm4gZmFsc2V9fXZhciBnPXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGEsbnVsbCk7aWYoaXNVc2VyTW9kaWZ5V3JpdGFibGUoZykpe3JldHVybiBhLnRhYkluZGV4Pj0wfWlmKCFuLmZsZXhib3gmJmhhc0Nzc0Rpc3BsYXlGbGV4KGcpKXtpZih1IT09bnVsbCl7cmV0dXJuIGZ9cmV0dXJuIG50KGEpJiZhdChhKX1pZihpc1Njcm9sbGFibGVDb250YWluZXIoYSxzKSl7cmV0dXJuIGZhbHNlfXZhciBoPWEucGFyZW50RWxlbWVudDtpZihoKXt2YXIgeD1oLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7dmFyIHk9d2luZG93LmdldENvbXB1dGVkU3R5bGUoaCxudWxsKTtpZihpc1Njcm9sbGFibGVDb250YWluZXIoaCxzLHgseSkpe3JldHVybiBmYWxzZX1pZihoYXNDc3NEaXNwbGF5RmxleCh5KSl7cmV0dXJuIGZ9fX1yZXR1cm4gYS50YWJJbmRleD49MH1pc1RhYmJhYmxlUnVsZXMuZXhjZXB0PWZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzBdOnt9O3ZhciB0PWZ1bmN0aW9uIGlzVGFiYmFibGUodCl7cmV0dXJuIGlzVGFiYmFibGVSdWxlcyh7Y29udGV4dDp0LGV4Y2VwdDplfSl9O3QucnVsZXM9aXNUYWJiYWJsZVJ1bGVzO3JldHVybiB0fTt2YXIgbnQ9QmUucnVsZXMuZXhjZXB0KHtmbGV4Ym94OnRydWV9KTt2YXIgYXQ9aXNUYWJiYWJsZVJ1bGVzLmV4Y2VwdCh7ZmxleGJveDp0cnVlfSk7dmFyIG90PWlzVGFiYmFibGVSdWxlcy5leGNlcHQoe30pO2Z1bmN0aW9uIHF1ZXJ5VGFiYmFibGUoKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06e30sdD1lLmNvbnRleHQscj1lLmluY2x1ZGVDb250ZXh0LG49ZS5pbmNsdWRlT25seVRhYmJhYmxlLGE9ZS5zdHJhdGVneTt2YXIgbz1vdC5ydWxlcy5leGNlcHQoe29ubHlUYWJiYWJsZTpufSk7cmV0dXJuIHF1ZXJ5Rm9jdXNhYmxlKHtjb250ZXh0OnQsaW5jbHVkZUNvbnRleHQ6cixpbmNsdWRlT25seVRhYmJhYmxlOm4sc3RyYXRlZ3k6YX0pLmZpbHRlcihvKX1mdW5jdGlvbiBjb21wYXJlRG9tUG9zaXRpb24oZSx0KXtyZXR1cm4gZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0KSZOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORz8tMToxfWZ1bmN0aW9uIHNvcnREb21PcmRlcihlKXtyZXR1cm4gZS5zb3J0KGNvbXBhcmVEb21Qb3NpdGlvbil9ZnVuY3Rpb24gZ2V0Rmlyc3RTdWNjZXNzb3JPZmZzZXQoZSx0KXtyZXR1cm4gZmluZEluZGV4KGUsKGZ1bmN0aW9uKGUpe3JldHVybiB0LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGUpJk5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HfSkpfWZ1bmN0aW9uIGZpbmRJbnNlcnRpb25PZmZzZXRzKGUsdCxyKXt2YXIgbj1bXTt0LmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBhPXRydWU7dmFyIG89ZS5pbmRleE9mKHQpO2lmKG89PT0tMSl7bz1nZXRGaXJzdFN1Y2Nlc3Nvck9mZnNldChlLHQpO2E9ZmFsc2V9aWYobz09PS0xKXtvPWUubGVuZ3RofXZhciBpPW5vZGVBcnJheShyP3IodCk6dCk7aWYoIWkubGVuZ3RoKXtyZXR1cm59bi5wdXNoKHtvZmZzZXQ6byxyZXBsYWNlOmEsZWxlbWVudHM6aX0pfSkpO3JldHVybiBufWZ1bmN0aW9uIGluc2VydEVsZW1lbnRzQXRPZmZzZXRzKGUsdCl7dmFyIHI9MDt0LnNvcnQoKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUub2Zmc2V0LXQub2Zmc2V0fSkpO3QuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIG49dC5yZXBsYWNlPzE6MDt2YXIgYT1bdC5vZmZzZXQrcixuXS5jb25jYXQodC5lbGVtZW50cyk7ZS5zcGxpY2UuYXBwbHkoZSxhKTtyKz10LmVsZW1lbnRzLmxlbmd0aC1ufSkpfWZ1bmN0aW9uIG1lcmdlSW5Eb21PcmRlcigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTp7fSx0PWUubGlzdCxyPWUuZWxlbWVudHMsbj1lLnJlc29sdmVFbGVtZW50O3ZhciBhPXQuc2xpY2UoMCk7dmFyIG89bm9kZUFycmF5KHIpLnNsaWNlKDApO3NvcnREb21PcmRlcihvKTt2YXIgaT1maW5kSW5zZXJ0aW9uT2Zmc2V0cyhhLG8sbik7aW5zZXJ0RWxlbWVudHNBdE9mZnNldHMoYSxpKTtyZXR1cm4gYX12YXIgaXQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGUsdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBuPXRbcl07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ZmFsc2U7bi5jb25maWd1cmFibGU9dHJ1ZTtpZihcInZhbHVlXCJpbiBuKW4ud3JpdGFibGU9dHJ1ZTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLmtleSxuKX19cmV0dXJuIGZ1bmN0aW9uKGUsdCxyKXtpZih0KWRlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsdCk7aWYocilkZWZpbmVQcm9wZXJ0aWVzKGUscik7cmV0dXJuIGV9fSgpO2Z1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfX12YXIgbHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBNYXBzKGUpe19jbGFzc0NhbGxDaGVjayh0aGlzLE1hcHMpO3RoaXMuX2RvY3VtZW50PWdldERvY3VtZW50KGUpO3RoaXMubWFwcz17fX1pdChNYXBzLFt7a2V5OlwiZ2V0QXJlYXNGb3JcIix2YWx1ZTpmdW5jdGlvbiBnZXRBcmVhc0ZvcihlKXtpZighdGhpcy5tYXBzW2VdKXt0aGlzLmFkZE1hcEJ5TmFtZShlKX1yZXR1cm4gdGhpcy5tYXBzW2VdfX0se2tleTpcImFkZE1hcEJ5TmFtZVwiLHZhbHVlOmZ1bmN0aW9uIGFkZE1hcEJ5TmFtZShlKXt2YXIgdD1nZXRNYXBCeU5hbWUoZSx0aGlzLl9kb2N1bWVudCk7aWYoIXQpe3JldHVybn10aGlzLm1hcHNbdC5uYW1lXT1xdWVyeVRhYmJhYmxlKHtjb250ZXh0OnR9KX19LHtrZXk6XCJleHRyYWN0QXJlYXNGcm9tTGlzdFwiLHZhbHVlOmZ1bmN0aW9uIGV4dHJhY3RBcmVhc0Zyb21MaXN0KGUpe3JldHVybiBlLmZpbHRlcigoZnVuY3Rpb24oZSl7dmFyIHQ9ZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO2lmKHQhPT1cImFyZWFcIil7cmV0dXJuIHRydWV9dmFyIHI9ZS5wYXJlbnROb2RlO2lmKCF0aGlzLm1hcHNbci5uYW1lXSl7dGhpcy5tYXBzW3IubmFtZV09W119dGhpcy5tYXBzW3IubmFtZV0ucHVzaChlKTtyZXR1cm4gZmFsc2V9KSx0aGlzKX19XSk7cmV0dXJuIE1hcHN9KCk7ZnVuY3Rpb24gc29ydEFyZWEoZSx0KXt2YXIgcj10LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbWdbdXNlbWFwXVwiKTt2YXIgbj1uZXcgbHQodCk7dmFyIGE9bi5leHRyYWN0QXJlYXNGcm9tTGlzdChlKTtpZighci5sZW5ndGgpe3JldHVybiBhfXJldHVybiBtZXJnZUluRG9tT3JkZXIoe2xpc3Q6YSxlbGVtZW50czpyLHJlc29sdmVFbGVtZW50OmZ1bmN0aW9uIHJlc29sdmVFbGVtZW50KGUpe3ZhciB0PWUuZ2V0QXR0cmlidXRlKFwidXNlbWFwXCIpLnNsaWNlKDEpO3JldHVybiBuLmdldEFyZWFzRm9yKHQpfX0pfXZhciBzdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoZSx0KXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG49dFtyXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHxmYWxzZTtuLmNvbmZpZ3VyYWJsZT10cnVlO2lmKFwidmFsdWVcImluIG4pbi53cml0YWJsZT10cnVlO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4ua2V5LG4pfX1yZXR1cm4gZnVuY3Rpb24oZSx0LHIpe2lmKHQpZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSx0KTtpZihyKWRlZmluZVByb3BlcnRpZXMoZSxyKTtyZXR1cm4gZX19KCk7ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrJDEoZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX19dmFyIHV0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gU2hhZG93cyhlLHQpe19jbGFzc0NhbGxDaGVjayQxKHRoaXMsU2hhZG93cyk7dGhpcy5jb250ZXh0PWU7dGhpcy5zb3J0RWxlbWVudHM9dDt0aGlzLmhvc3RDb3VudGVyPTE7dGhpcy5pbkhvc3Q9e307dGhpcy5pbkRvY3VtZW50PVtdO3RoaXMuaG9zdHM9e307dGhpcy5lbGVtZW50cz17fX1zdChTaGFkb3dzLFt7a2V5OlwiX3JlZ2lzdGVySG9zdFwiLHZhbHVlOmZ1bmN0aW9uIF9yZWdpc3Rlckhvc3QoZSl7aWYoZS5fc29ydGluZ0lkKXtyZXR1cm59ZS5fc29ydGluZ0lkPVwic2hhZG93LVwiK3RoaXMuaG9zdENvdW50ZXIrKzt0aGlzLmhvc3RzW2UuX3NvcnRpbmdJZF09ZTt2YXIgdD1nZXRTaGFkb3dIb3N0KHtjb250ZXh0OmV9KTtpZih0KXt0aGlzLl9yZWdpc3Rlckhvc3QodCk7dGhpcy5fcmVnaXN0ZXJIb3N0UGFyZW50KGUsdCl9ZWxzZXt0aGlzLmluRG9jdW1lbnQucHVzaChlKX19fSx7a2V5OlwiX3JlZ2lzdGVySG9zdFBhcmVudFwiLHZhbHVlOmZ1bmN0aW9uIF9yZWdpc3Rlckhvc3RQYXJlbnQoZSx0KXtpZighdGhpcy5pbkhvc3RbdC5fc29ydGluZ0lkXSl7dGhpcy5pbkhvc3RbdC5fc29ydGluZ0lkXT1bXX10aGlzLmluSG9zdFt0Ll9zb3J0aW5nSWRdLnB1c2goZSl9fSx7a2V5OlwiX3JlZ2lzdGVyRWxlbWVudFwiLHZhbHVlOmZ1bmN0aW9uIF9yZWdpc3RlckVsZW1lbnQoZSx0KXtpZighdGhpcy5lbGVtZW50c1t0Ll9zb3J0aW5nSWRdKXt0aGlzLmVsZW1lbnRzW3QuX3NvcnRpbmdJZF09W119dGhpcy5lbGVtZW50c1t0Ll9zb3J0aW5nSWRdLnB1c2goZSl9fSx7a2V5OlwiZXh0cmFjdEVsZW1lbnRzXCIsdmFsdWU6ZnVuY3Rpb24gZXh0cmFjdEVsZW1lbnRzKGUpe3JldHVybiBlLmZpbHRlcigoZnVuY3Rpb24oZSl7dmFyIHQ9Z2V0U2hhZG93SG9zdCh7Y29udGV4dDplfSk7aWYoIXQpe3JldHVybiB0cnVlfXRoaXMuX3JlZ2lzdGVySG9zdCh0KTt0aGlzLl9yZWdpc3RlckVsZW1lbnQoZSx0KTtyZXR1cm4gZmFsc2V9KSx0aGlzKX19LHtrZXk6XCJzb3J0XCIsdmFsdWU6ZnVuY3Rpb24gc29ydChlKXt2YXIgdD10aGlzLl9pbmplY3RIb3N0cyhlKTt0PXRoaXMuX3JlcGxhY2VIb3N0cyh0KTt0aGlzLl9jbGVhbnVwKCk7cmV0dXJuIHR9fSx7a2V5OlwiX2luamVjdEhvc3RzXCIsdmFsdWU6ZnVuY3Rpb24gX2luamVjdEhvc3RzKGUpe09iamVjdC5rZXlzKHRoaXMuaG9zdHMpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuZWxlbWVudHNbZV07dmFyIHI9dGhpcy5pbkhvc3RbZV07dmFyIG49dGhpcy5ob3N0c1tlXS5zaGFkb3dSb290O3RoaXMuZWxlbWVudHNbZV09dGhpcy5fbWVyZ2UodCxyLG4pfSksdGhpcyk7cmV0dXJuIHRoaXMuX21lcmdlKGUsdGhpcy5pbkRvY3VtZW50LHRoaXMuY29udGV4dCl9fSx7a2V5OlwiX21lcmdlXCIsdmFsdWU6ZnVuY3Rpb24gX21lcmdlKGUsdCxyKXt2YXIgbj1tZXJnZUluRG9tT3JkZXIoe2xpc3Q6ZSxlbGVtZW50czp0fSk7cmV0dXJuIHRoaXMuc29ydEVsZW1lbnRzKG4scil9fSx7a2V5OlwiX3JlcGxhY2VIb3N0c1wiLHZhbHVlOmZ1bmN0aW9uIF9yZXBsYWNlSG9zdHMoZSl7cmV0dXJuIG1lcmdlSW5Eb21PcmRlcih7bGlzdDplLGVsZW1lbnRzOnRoaXMuaW5Eb2N1bWVudCxyZXNvbHZlRWxlbWVudDp0aGlzLl9yZXNvbHZlSG9zdEVsZW1lbnQuYmluZCh0aGlzKX0pfX0se2tleTpcIl9yZXNvbHZlSG9zdEVsZW1lbnRcIix2YWx1ZTpmdW5jdGlvbiBfcmVzb2x2ZUhvc3RFbGVtZW50KGUpe3ZhciB0PW1lcmdlSW5Eb21PcmRlcih7bGlzdDp0aGlzLmVsZW1lbnRzW2UuX3NvcnRpbmdJZF0sZWxlbWVudHM6dGhpcy5pbkhvc3RbZS5fc29ydGluZ0lkXSxyZXNvbHZlRWxlbWVudDp0aGlzLl9yZXNvbHZlSG9zdEVsZW1lbnQuYmluZCh0aGlzKX0pO3ZhciByPXRhYmluZGV4VmFsdWUoZSk7aWYociE9PW51bGwmJnI+LTEpe3JldHVybltlXS5jb25jYXQodCl9cmV0dXJuIHR9fSx7a2V5OlwiX2NsZWFudXBcIix2YWx1ZTpmdW5jdGlvbiBfY2xlYW51cCgpe09iamVjdC5rZXlzKHRoaXMuaG9zdHMpLmZvckVhY2goKGZ1bmN0aW9uKGUpe2RlbGV0ZSB0aGlzLmhvc3RzW2VdLl9zb3J0aW5nSWR9KSx0aGlzKX19XSk7cmV0dXJuIFNoYWRvd3N9KCk7ZnVuY3Rpb24gc29ydFNoYWRvd2VkKGUsdCxyKXt2YXIgbj1uZXcgdXQodCxyKTt2YXIgYT1uLmV4dHJhY3RFbGVtZW50cyhlKTtpZihhLmxlbmd0aD09PWUubGVuZ3RoKXtyZXR1cm4gcihlKX1yZXR1cm4gbi5zb3J0KGEpfWZ1bmN0aW9uIHNvcnRUYWJpbmRleChlKXt2YXIgdD17fTt2YXIgcj1bXTt2YXIgbj1lLmZpbHRlcigoZnVuY3Rpb24oZSl7dmFyIG49ZS50YWJJbmRleDtpZihuPT09dW5kZWZpbmVkKXtuPXRhYmluZGV4VmFsdWUoZSl9aWYobjw9MHx8bj09PW51bGx8fG49PT11bmRlZmluZWQpe3JldHVybiB0cnVlfWlmKCF0W25dKXt0W25dPVtdO3IucHVzaChuKX10W25dLnB1c2goZSk7cmV0dXJuIGZhbHNlfSkpO3ZhciBhPXIuc29ydCgpLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIHRbZV19KSkucmVkdWNlUmlnaHQoKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQuY29uY2F0KGUpfSksbik7cmV0dXJuIGF9dmFyIGN0PXZvaWQgMDtmdW5jdGlvbiBtb3ZlQ29udGV4dFRvQmVnaW5uaW5nKGUsdCl7dmFyIHI9ZS5pbmRleE9mKHQpO2lmKHI+MCl7dmFyIG49ZS5zcGxpY2UociwxKTtyZXR1cm4gbi5jb25jYXQoZSl9cmV0dXJuIGV9ZnVuY3Rpb24gc29ydEVsZW1lbnRzKGUsdCl7aWYoY3QudGFic2VxdWVuY2VBcmVhQXRJbWdQb3NpdGlvbil7ZT1zb3J0QXJlYShlLHQpfWU9c29ydFRhYmluZGV4KGUpO3JldHVybiBlfWZ1bmN0aW9uIHF1ZXJ5VGFic2VxdWVuY2UoKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06e30sdD1lLmNvbnRleHQscj1lLmluY2x1ZGVDb250ZXh0LG49ZS5pbmNsdWRlT25seVRhYmJhYmxlLGE9ZS5zdHJhdGVneTtpZighY3Qpe2N0PV9zdXBwb3J0cygpfXZhciBvPW5vZGVBcnJheSh0KVswXXx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O3ZhciBpPXF1ZXJ5VGFiYmFibGUoe2NvbnRleHQ6byxpbmNsdWRlQ29udGV4dDpyLGluY2x1ZGVPbmx5VGFiYmFibGU6bixzdHJhdGVneTphfSk7aWYoZG9jdW1lbnQuYm9keS5jcmVhdGVTaGFkb3dSb290JiZBLmlzLkJMSU5LKXtpPXNvcnRTaGFkb3dlZChpLG8sc29ydEVsZW1lbnRzKX1lbHNle2k9c29ydEVsZW1lbnRzKGksbyl9aWYocil7aT1tb3ZlQ29udGV4dFRvQmVnaW5uaW5nKGksbyl9cmV0dXJuIGl9dmFyIGR0PXt0YWI6OSxsZWZ0OjM3LHVwOjM4LHJpZ2h0OjM5LGRvd246NDAscGFnZVVwOjMzLFwicGFnZS11cFwiOjMzLHBhZ2VEb3duOjM0LFwicGFnZS1kb3duXCI6MzQsZW5kOjM1LGhvbWU6MzYsZW50ZXI6MTMsZXNjYXBlOjI3LHNwYWNlOjMyLHNoaWZ0OjE2LGNhcHNMb2NrOjIwLFwiY2Fwcy1sb2NrXCI6MjAsY3RybDoxNyxhbHQ6MTgsbWV0YTo5MSxwYXVzZToxOSxpbnNlcnQ6NDUsZGVsZXRlOjQ2LGJhY2tzcGFjZTo4LF9hbGlhczp7OTE6WzkyLDkzLDIyNF19fTtmb3IodmFyIGZ0PTE7ZnQ8MjY7ZnQrKyl7ZHRbXCJmXCIrZnRdPWZ0KzExMX1mb3IodmFyIG10PTA7bXQ8MTA7bXQrKyl7dmFyIHB0PW10KzQ4O3ZhciBidD1tdCs5NjtkdFttdF09cHQ7ZHRbXCJudW0tXCIrbXRdPWJ0O2R0Ll9hbGlhc1twdF09W2J0XX1mb3IodmFyIHZ0PTA7dnQ8MjY7dnQrKyl7dmFyIGd0PXZ0KzY1O3ZhciBodD1TdHJpbmcuZnJvbUNoYXJDb2RlKGd0KS50b0xvd2VyQ2FzZSgpO2R0W2h0XT1ndH12YXIgeHQ9e2FsdDpcImFsdEtleVwiLGN0cmw6XCJjdHJsS2V5XCIsbWV0YTpcIm1ldGFLZXlcIixzaGlmdDpcInNoaWZ0S2V5XCJ9O3ZhciB5dD1PYmplY3Qua2V5cyh4dCkubWFwKChmdW5jdGlvbihlKXtyZXR1cm4geHRbZV19KSk7ZnVuY3Rpb24gY3JlYXRlRXhwZWN0ZWRNb2RpZmllcnMoZSl7dmFyIHQ9ZT9udWxsOmZhbHNlO3JldHVybnthbHRLZXk6dCxjdHJsS2V5OnQsbWV0YUtleTp0LHNoaWZ0S2V5OnR9fWZ1bmN0aW9uIHJlc29sdmVNb2RpZmllcnMoZSl7dmFyIHQ9ZS5pbmRleE9mKFwiKlwiKSE9PS0xO3ZhciByPWNyZWF0ZUV4cGVjdGVkTW9kaWZpZXJzKHQpO2UuZm9yRWFjaCgoZnVuY3Rpb24oZSl7aWYoZT09PVwiKlwiKXtyZXR1cm59dmFyIHQ9dHJ1ZTt2YXIgbj1lLnNsaWNlKDAsMSk7aWYobj09PVwiP1wiKXt0PW51bGx9ZWxzZSBpZihuPT09XCIhXCIpe3Q9ZmFsc2V9aWYodCE9PXRydWUpe2U9ZS5zbGljZSgxKX12YXIgYT14dFtlXTtpZighYSl7dGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBtb2RpZmllciBcIicrZSsnXCInKX1yW2FdPXR9KSk7cmV0dXJuIHJ9ZnVuY3Rpb24gcmVzb2x2ZUtleShlKXt2YXIgdD1kdFtlXXx8cGFyc2VJbnQoZSwxMCk7aWYoIXR8fHR5cGVvZiB0IT09XCJudW1iZXJcInx8aXNOYU4odCkpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24ga2V5IFwiJytlKydcIicpfXJldHVyblt0XS5jb25jYXQoZHQuX2FsaWFzW3RdfHxbXSl9ZnVuY3Rpb24gbWF0Y2hNb2RpZmllcnMoZSx0KXtyZXR1cm4heXQuc29tZSgoZnVuY3Rpb24ocil7cmV0dXJuIHR5cGVvZiBlW3JdPT09XCJib29sZWFuXCImJkJvb2xlYW4odFtyXSkhPT1lW3JdfSkpfWZ1bmN0aW9uIGtleUJpbmRpbmcoZSl7cmV0dXJuIGUuc3BsaXQoL1xccysvKS5tYXAoKGZ1bmN0aW9uKGUpe3ZhciB0PWUuc3BsaXQoXCIrXCIpO3ZhciByPXJlc29sdmVNb2RpZmllcnModC5zbGljZSgwLC0xKSk7dmFyIG49cmVzb2x2ZUtleSh0LnNsaWNlKC0xKSk7cmV0dXJue2tleUNvZGVzOm4sbW9kaWZpZXJzOnIsbWF0Y2hNb2RpZmllcnM6bWF0Y2hNb2RpZmllcnMuYmluZChudWxsLHIpfX0pKX1mdW5jdGlvbiBnZXRQYXJlbnRDb21wYXJhdG9yKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzBdOnt9LHQ9ZS5wYXJlbnQscj1lLmVsZW1lbnQsbj1lLmluY2x1ZGVTZWxmO2lmKHQpe3JldHVybiBmdW5jdGlvbiBpc0NoaWxkT2YoZSl7cmV0dXJuIEJvb2xlYW4obiYmZT09PXR8fHQuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZSkmTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkpfX1lbHNlIGlmKHIpe3JldHVybiBmdW5jdGlvbiBpc1BhcmVudE9mKGUpe3JldHVybiBCb29sZWFuKG4mJnI9PT1lfHxlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHIpJk5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZKX19dGhyb3cgbmV3IFR5cGVFcnJvcihcInV0aWwvY29tcGFyZS1wb3NpdGlvbiNnZXRQYXJlbnRDb21wYXJhdG9yIHJlcXVpcmVkIGVpdGhlciBvcHRpb25zLnBhcmVudCBvciBvcHRpb25zLmVsZW1lbnRcIil9ZnVuY3Rpb24gd2hlbktleSgpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTp7fTt2YXIgdD17fTt2YXIgcj1ub2RlQXJyYXkoZS5jb250ZXh0KVswXXx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O2RlbGV0ZSBlLmNvbnRleHQ7dmFyIG49bm9kZUFycmF5KGUuZmlsdGVyKTtkZWxldGUgZS5maWx0ZXI7dmFyIGE9T2JqZWN0LmtleXMoZSk7aWYoIWEubGVuZ3RoKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwid2hlbi9rZXkgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIG9wdGlvbiBrZXlcIil9dmFyIG89ZnVuY3Rpb24gcmVnaXN0ZXJCaW5kaW5nKGUpe2Uua2V5Q29kZXMuZm9yRWFjaCgoZnVuY3Rpb24ocil7aWYoIXRbcl0pe3Rbcl09W119dFtyXS5wdXNoKGUpfSkpfTthLmZvckVhY2goKGZ1bmN0aW9uKHQpe2lmKHR5cGVvZiBlW3RdIT09XCJmdW5jdGlvblwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCd3aGVuL2tleSByZXF1aXJlcyBvcHRpb25bXCInK3QrJ1wiXSB0byBiZSBhIGZ1bmN0aW9uJyl9dmFyIHI9ZnVuY3Rpb24gYWRkQ2FsbGJhY2socil7ci5jYWxsYmFjaz1lW3RdO3JldHVybiByfTtrZXlCaW5kaW5nKHQpLm1hcChyKS5mb3JFYWNoKG8pfSkpO3ZhciBpPWZ1bmN0aW9uIGhhbmRsZUtleURvd24oZSl7aWYoZS5kZWZhdWx0UHJldmVudGVkKXtyZXR1cm59aWYobi5sZW5ndGgpe3ZhciBhPWdldFBhcmVudENvbXBhcmF0b3Ioe2VsZW1lbnQ6ZS50YXJnZXQsaW5jbHVkZVNlbGY6dHJ1ZX0pO2lmKG4uc29tZShhKSl7cmV0dXJufX12YXIgbz1lLmtleUNvZGV8fGUud2hpY2g7aWYoIXRbb10pe3JldHVybn10W29dLmZvckVhY2goKGZ1bmN0aW9uKHQpe2lmKCF0Lm1hdGNoTW9kaWZpZXJzKGUpKXtyZXR1cm59dC5jYWxsYmFjay5jYWxsKHIsZSxsKX0pKX07ci5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLGksZmFsc2UpO3ZhciBsPWZ1bmN0aW9uIGRpc2VuZ2FnZSgpe3IucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIixpLGZhbHNlKX07cmV0dXJue2Rpc2VuZ2FnZTpsfX1mdW5jdGlvbiBtYWludGFpbl90YWJfZm9jdXMoe2NvbnRleHQ6ZX09e30pe2lmKCFlKXtlPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudH1xdWVyeVRhYnNlcXVlbmNlKCk7cmV0dXJuIHdoZW5LZXkoe1wiP2FsdCs/c2hpZnQrdGFiXCI6ZnVuY3Rpb24gYWx0U2hpZnRUYWIodCl7dC5wcmV2ZW50RGVmYXVsdCgpO3ZhciByPXF1ZXJ5VGFic2VxdWVuY2Uoe2NvbnRleHQ6ZX0pO3ZhciBuPXQuc2hpZnRLZXk7dmFyIGE9clswXTt2YXIgbz1yW3IubGVuZ3RoLTFdO3ZhciBpPW4/YTpvO3ZhciBsPW4/bzphO2lmKGlzQWN0aXZlRWxlbWVudChpKSl7bC5mb2N1cygpO3JldHVybn12YXIgcz12b2lkIDA7dmFyIHU9ci5zb21lKChmdW5jdGlvbihlLHQpe2lmKCFpc0FjdGl2ZUVsZW1lbnQoZSkpe3JldHVybiBmYWxzZX1zPXQ7cmV0dXJuIHRydWV9KSk7aWYoIXUpe2EuZm9jdXMoKTtyZXR1cm59dmFyIGM9bj8tMToxO3JbcytjXS5mb2N1cygpfX0pfWxldCBFdDtsZXQgd3Q7bGV0IGt0PTA7ZnVuY3Rpb24gbG9jaygpe3NldFRpbWVvdXQoKCgpPT57aWYoa3QrKz4wKXtyZXR1cm59Y29uc3QgZT13aW5kb3cuaW5uZXJXaWR0aC1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7aWYoZT4wKXtFdD1kb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodDtkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodD1gJHtlfXB4YH13dD1kb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93O2RvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3c9XCJoaWRkZW5cIn0pKX1mdW5jdGlvbiB1bmxvY2soKXtzZXRUaW1lb3V0KCgoKT0+e2lmKGt0PT09MHx8LS1rdCE9PTApe3JldHVybn1pZihFdCE9PXVuZGVmaW5lZCl7ZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQ9RXQ7RXQ9dW5kZWZpbmVkfWlmKHd0IT09dW5kZWZpbmVkKXtkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93PXd0O3d0PXVuZGVmaW5lZH19KSl9Y29uc3QgU3Q9ZnVuY3Rpb24gT3ZlcmxheSh7Y2xhc3NOYW1lOmUsY2hpbGRyZW46dCxmaXhlZDpyfSl7cC51c2VFZmZlY3QoKCgpPT57bG9jaygpO3JldHVybigpPT57dW5sb2NrKCl9fSksW10pO2NvbnN0W24sYV09cC51c2VTdGF0ZShudWxsKTtjb25zdCBvPXAudXNlQ2FsbGJhY2soKGU9PnthKGUpfSksW10pO3AudXNlRWZmZWN0KCgoKT0+e2lmKG49PW51bGwpe3JldHVybn1jb25zdCBlPW1haW50YWluX3RhYl9mb2N1cyh7Y29udGV4dDpufSk7cmV0dXJuKCk9PntlLmRpc2VuZ2FnZSgpfX0pLFtuXSk7cmV0dXJuIHAuY3JlYXRlRWxlbWVudChcImRpdlwiLHtcImRhdGEtbmV4dGpzLWRpYWxvZy1vdmVybGF5XCI6dHJ1ZSxjbGFzc05hbWU6ZSxyZWY6b30scC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse1wiZGF0YS1uZXh0anMtZGlhbG9nLWJhY2tkcm9wXCI6dHJ1ZSxcImRhdGEtbmV4dGpzLWRpYWxvZy1iYWNrZHJvcC1maXhlZFwiOnI/dHJ1ZTp1bmRlZmluZWR9KSx0KX07dmFyIF90PXJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvYW5zZXJcIik7dmFyIFR0PV9fbmNjd3Bja19yZXF1aXJlX18ubihfdCk7Y29uc3QgQ3Q9ZnVuY3Rpb24gVGVybWluYWwoe2NvbnRlbnQ6ZX0pe2NvbnN0IHQ9cC51c2VNZW1vKCgoKT0+VHQoKS5hbnNpVG9Kc29uKGUse2pzb246dHJ1ZSx1c2VfY2xhc3Nlczp0cnVlLHJlbW92ZV9lbXB0eTp0cnVlfSkpLFtlXSk7cmV0dXJuIHAuY3JlYXRlRWxlbWVudChcImRpdlwiLHtcImRhdGEtbmV4dGpzLXRlcm1pbmFsXCI6dHJ1ZX0scC5jcmVhdGVFbGVtZW50KFwicHJlXCIsbnVsbCx0Lm1hcCgoKGUsdCk9PnAuY3JlYXRlRWxlbWVudChcInNwYW5cIix7a2V5OmB0ZXJtaW5hbC1lbnRyeS0ke3R9YCxzdHlsZTp7Y29sb3I6ZS5mZz9gdmFyKC0tY29sb3ItJHtlLmZnfSlgOnVuZGVmaW5lZCwuLi5lLmRlY29yYXRpb249PT1cImJvbGRcIj97Zm9udFdlaWdodDo4MDB9OmUuZGVjb3JhdGlvbj09PVwiaXRhbGljXCI/e2ZvbnRTdHlsZTpcIml0YWxpY1wifTp1bmRlZmluZWR9fSxlLmNvbnRlbnQpKSkpKX07Y29uc3QganQ9ZnVuY3Rpb24gQnVpbGRFcnJvcih7bWVzc2FnZTplfSl7Y29uc3QgdD1wLnVzZUNhbGxiYWNrKCgoKT0+e30pLFtdKTtyZXR1cm4gcC5jcmVhdGVFbGVtZW50KFN0LHtmaXhlZDp0cnVlfSxwLmNyZWF0ZUVsZW1lbnQoaCx7dHlwZTpcImVycm9yXCIsXCJhcmlhLWxhYmVsbGVkYnlcIjpcIm5leHRqc19fY29udGFpbmVyX2J1aWxkX2Vycm9yX2xhYmVsXCIsXCJhcmlhLWRlc2NyaWJlZGJ5XCI6XCJuZXh0anNfX2NvbnRhaW5lcl9idWlsZF9lcnJvcl9kZXNjXCIsb25DbG9zZTp0fSxwLmNyZWF0ZUVsZW1lbnQoeSxudWxsLHAuY3JlYXRlRWxlbWVudChFLHtjbGFzc05hbWU6XCJuZXh0anMtY29udGFpbmVyLWJ1aWxkLWVycm9yLWhlYWRlclwifSxwLmNyZWF0ZUVsZW1lbnQoXCJoNFwiLHtpZDpcIm5leHRqc19fY29udGFpbmVyX2J1aWxkX2Vycm9yX2xhYmVsXCJ9LFwiRmFpbGVkIHRvIGNvbXBpbGVcIikpLHAuY3JlYXRlRWxlbWVudCh4LHtjbGFzc05hbWU6XCJuZXh0anMtY29udGFpbmVyLWJ1aWxkLWVycm9yLWJvZHlcIn0scC5jcmVhdGVFbGVtZW50KEN0LHtjb250ZW50OmV9KSxwLmNyZWF0ZUVsZW1lbnQoXCJmb290ZXJcIixudWxsLHAuY3JlYXRlRWxlbWVudChcInBcIix7aWQ6XCJuZXh0anNfX2NvbnRhaW5lcl9idWlsZF9lcnJvcl9kZXNjXCJ9LHAuY3JlYXRlRWxlbWVudChcInNtYWxsXCIsbnVsbCxcIlRoaXMgZXJyb3Igb2NjdXJyZWQgZHVyaW5nIHRoZSBidWlsZCBwcm9jZXNzIGFuZCBjYW4gb25seSBiZSBkaXNtaXNzZWQgYnkgZml4aW5nIHRoZSBlcnJvci5cIikpKSkpKSl9O2NvbnN0IEF0PW5vb3BgXG4gIC5uZXh0anMtY29udGFpbmVyLWJ1aWxkLWVycm9yLWhlYWRlciA+IGg0IHtcbiAgICBsaW5lLWhlaWdodDogMS41O1xuICAgIG1hcmdpbjogMDtcbiAgICBwYWRkaW5nOiAwO1xuICB9XG5cbiAgLm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItYm9keSBmb290ZXIge1xuICAgIG1hcmdpbi10b3A6IHZhcigtLXNpemUtZ2FwKTtcbiAgfVxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1ib2R5IGZvb3RlciBwIHtcbiAgICBtYXJnaW46IDA7XG4gIH1cblxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1ib2R5IHNtYWxsIHtcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItZm9udCk7XG4gIH1cbmA7Y29uc3QgQ2xvc2VJY29uPSgpPT5wLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIix7d2lkdGg6XCIyNFwiLGhlaWdodDpcIjI0XCIsdmlld0JveDpcIjAgMCAyNCAyNFwiLGZpbGw6XCJub25lXCIseG1sbnM6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wifSxwLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIse2Q6XCJNMTggNkw2IDE4XCIsc3Ryb2tlOlwiY3VycmVudENvbG9yXCIsc3Ryb2tlV2lkdGg6XCIyXCIsc3Ryb2tlTGluZWNhcDpcInJvdW5kXCIsc3Ryb2tlTGluZWpvaW46XCJyb3VuZFwifSkscC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLHtkOlwiTTYgNkwxOCAxOFwiLHN0cm9rZTpcImN1cnJlbnRDb2xvclwiLHN0cm9rZVdpZHRoOlwiMlwiLHN0cm9rZUxpbmVjYXA6XCJyb3VuZFwiLHN0cm9rZUxpbmVqb2luOlwicm91bmRcIn0pKTtjb25zdCBPdD1mdW5jdGlvbiBMZWZ0UmlnaHREaWFsb2dIZWFkZXIoe2NoaWxkcmVuOmUsY2xhc3NOYW1lOnQscHJldmlvdXM6cixuZXh0Om4sY2xvc2U6YX0pe2NvbnN0IG89cC51c2VSZWYobnVsbCk7Y29uc3QgaT1wLnVzZVJlZihudWxsKTtjb25zdCBsPXAudXNlUmVmKG51bGwpO2NvbnN0W3MsdV09cC51c2VTdGF0ZShudWxsKTtjb25zdCBjPXAudXNlQ2FsbGJhY2soKGU9Pnt1KGUpfSksW10pO3AudXNlRWZmZWN0KCgoKT0+e2lmKHM9PW51bGwpe3JldHVybn1jb25zdCBlPXMuZ2V0Um9vdE5vZGUoKTtjb25zdCB0PXNlbGYuZG9jdW1lbnQ7ZnVuY3Rpb24gaGFuZGxlcih0KXtpZih0LmtleT09PVwiQXJyb3dMZWZ0XCIpe3Quc3RvcFByb3BhZ2F0aW9uKCk7aWYoby5jdXJyZW50KXtvLmN1cnJlbnQuZm9jdXMoKX1yJiZyKCl9ZWxzZSBpZih0LmtleT09PVwiQXJyb3dSaWdodFwiKXt0LnN0b3BQcm9wYWdhdGlvbigpO2lmKGkuY3VycmVudCl7aS5jdXJyZW50LmZvY3VzKCl9biYmbigpfWVsc2UgaWYodC5rZXk9PT1cIkVzY2FwZVwiKXt0LnN0b3BQcm9wYWdhdGlvbigpO2lmKGUgaW5zdGFuY2VvZiBTaGFkb3dSb290KXtjb25zdCB0PWUuYWN0aXZlRWxlbWVudDtpZih0JiZ0IT09bC5jdXJyZW50JiZ0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpe3QuYmx1cigpO3JldHVybn19aWYoYSl7YSgpfX19ZS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLGhhbmRsZXIpO2lmKGUhPT10KXt0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsaGFuZGxlcil9cmV0dXJuIGZ1bmN0aW9uKCl7ZS5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLGhhbmRsZXIpO2lmKGUhPT10KXt0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsaGFuZGxlcil9fX0pLFthLHMsbixyXSk7cC51c2VFZmZlY3QoKCgpPT57aWYocz09bnVsbCl7cmV0dXJufWNvbnN0IGU9cy5nZXRSb290Tm9kZSgpO2lmKGUgaW5zdGFuY2VvZiBTaGFkb3dSb290KXtjb25zdCB0PWUuYWN0aXZlRWxlbWVudDtpZihyPT1udWxsKXtpZihvLmN1cnJlbnQmJnQ9PT1vLmN1cnJlbnQpe28uY3VycmVudC5ibHVyKCl9fWVsc2UgaWYobj09bnVsbCl7aWYoaS5jdXJyZW50JiZ0PT09aS5jdXJyZW50KXtpLmN1cnJlbnQuYmx1cigpfX19fSksW3MsbixyXSk7cmV0dXJuIHAuY3JlYXRlRWxlbWVudChcImRpdlwiLHtcImRhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XCI6dHJ1ZSxjbGFzc05hbWU6dH0scC5jcmVhdGVFbGVtZW50KFwibmF2XCIse3JlZjpjfSxwLmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIix7cmVmOm8sdHlwZTpcImJ1dHRvblwiLGRpc2FibGVkOnI9PW51bGw/dHJ1ZTp1bmRlZmluZWQsXCJhcmlhLWRpc2FibGVkXCI6cj09bnVsbD90cnVlOnVuZGVmaW5lZCxvbkNsaWNrOnI/P3VuZGVmaW5lZH0scC5jcmVhdGVFbGVtZW50KFwic3ZnXCIse3ZpZXdCb3g6XCIwIDAgMTQgMTRcIixmaWxsOlwibm9uZVwiLHhtbG5zOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIn0scC5jcmVhdGVFbGVtZW50KFwidGl0bGVcIixudWxsLFwicHJldmlvdXNcIikscC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLHtkOlwiTTYuOTk5OTYgMS4xNjY2NkwxLjE2NjYzIDYuOTk5OTlMNi45OTk5NiAxMi44MzMzTTEyLjgzMzMgNi45OTk5OUgxLjk5OTk2SDEyLjgzMzNaXCIsc3Ryb2tlOlwiY3VycmVudENvbG9yXCIsc3Ryb2tlV2lkdGg6XCIyXCIsc3Ryb2tlTGluZWNhcDpcInJvdW5kXCIsc3Ryb2tlTGluZWpvaW46XCJyb3VuZFwifSkpKSxwLmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIix7cmVmOmksdHlwZTpcImJ1dHRvblwiLGRpc2FibGVkOm49PW51bGw/dHJ1ZTp1bmRlZmluZWQsXCJhcmlhLWRpc2FibGVkXCI6bj09bnVsbD90cnVlOnVuZGVmaW5lZCxvbkNsaWNrOm4/P3VuZGVmaW5lZH0scC5jcmVhdGVFbGVtZW50KFwic3ZnXCIse3ZpZXdCb3g6XCIwIDAgMTQgMTRcIixmaWxsOlwibm9uZVwiLHhtbG5zOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIn0scC5jcmVhdGVFbGVtZW50KFwidGl0bGVcIixudWxsLFwibmV4dFwiKSxwLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIse2Q6XCJNNi45OTk5NiAxLjE2NjY2TDEyLjgzMzMgNi45OTk5OUw2Ljk5OTk2IDEyLjgzMzNNMS4xNjY2MyA2Ljk5OTk5SDEySDEuMTY2NjNaXCIsc3Ryb2tlOlwiY3VycmVudENvbG9yXCIsc3Ryb2tlV2lkdGg6XCIyXCIsc3Ryb2tlTGluZWNhcDpcInJvdW5kXCIsc3Ryb2tlTGluZWpvaW46XCJyb3VuZFwifSkpKSxcIsKgXCIsZSksYT9wLmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIix7XCJkYXRhLW5leHRqcy1lcnJvcnMtZGlhbG9nLWxlZnQtcmlnaHQtY2xvc2UtYnV0dG9uXCI6dHJ1ZSxyZWY6bCx0eXBlOlwiYnV0dG9uXCIsb25DbGljazphLFwiYXJpYS1sYWJlbFwiOlwiQ2xvc2VcIn0scC5jcmVhdGVFbGVtZW50KFwic3BhblwiLHtcImFyaWEtaGlkZGVuXCI6XCJ0cnVlXCJ9LHAuY3JlYXRlRWxlbWVudChDbG9zZUljb24sbnVsbCkpKTpudWxsKX07Y29uc3QgTnQ9bm9vcGBcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xuICAgIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgfVxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gbmF2ID4gYnV0dG9uIHtcbiAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXG4gICAgd2lkdGg6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwKSk7XG4gICAgaGVpZ2h0OiBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcCkpO1xuICAgIGZvbnQtc2l6ZTogMDtcbiAgICBib3JkZXI6IG5vbmU7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDg1LCA4NSwgMC4xKTtcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDAuMjVzIGVhc2U7XG4gIH1cbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbiA+IHN2ZyB7XG4gICAgd2lkdGg6IGF1dG87XG4gICAgaGVpZ2h0OiBjYWxjKHZhcigtLXNpemUtZ2FwKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcbiAgfVxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gbmF2ID4gYnV0dG9uOmhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgODUsIDg1LCAwLjIpO1xuICB9XG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b246ZGlzYWJsZWQge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCA4NSwgODUsIDAuMSk7XG4gICAgY29sb3I6IHJnYmEoMjU1LCA4NSwgODUsIDAuNCk7XG4gICAgY3Vyc29yOiBub3QtYWxsb3dlZDtcbiAgfVxuXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b246Zmlyc3Qtb2YtdHlwZSB7XG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZikgMCAwIHZhcigtLXNpemUtZ2FwLWhhbGYpO1xuICAgIG1hcmdpbi1yaWdodDogMXB4O1xuICB9XG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b246bGFzdC1vZi10eXBlIHtcbiAgICBib3JkZXItcmFkaXVzOiAwIHZhcigtLXNpemUtZ2FwLWhhbGYpIHZhcigtLXNpemUtZ2FwLWhhbGYpIDA7XG4gIH1cblxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gYnV0dG9uOmxhc3Qtb2YtdHlwZSB7XG4gICAgYm9yZGVyOiAwO1xuICAgIHBhZGRpbmc6IDA7XG5cbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICBhcHBlYXJhbmNlOiBub25lO1xuXG4gICAgb3BhY2l0eTogMC40O1xuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4yNXMgZWFzZTtcblxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1mb250KTtcbiAgfVxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gYnV0dG9uOmxhc3Qtb2YtdHlwZTpob3ZlciB7XG4gICAgb3BhY2l0eTogMC43O1xuICB9XG5gO2NvbnN0IEl0PW5vb3BgXG4gIFtkYXRhLW5leHRqcy10b2FzdF0ge1xuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICBib3R0b206IHZhcigtLXNpemUtZ2FwLWRvdWJsZSk7XG4gICAgbGVmdDogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcbiAgICBtYXgtd2lkdGg6IDQyMHB4O1xuICAgIHotaW5kZXg6IDkwMDA7XG4gIH1cblxuICBAbWVkaWEgKG1heC13aWR0aDogNDQwcHgpIHtcbiAgICBbZGF0YS1uZXh0anMtdG9hc3RdIHtcbiAgICAgIG1heC13aWR0aDogOTB2dztcbiAgICAgIGxlZnQ6IDV2dztcbiAgICB9XG4gIH1cblxuICBbZGF0YS1uZXh0anMtdG9hc3Qtd3JhcHBlcl0ge1xuICAgIHBhZGRpbmc6IDE2cHg7XG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1icmlnaHQtd2hpdGUpO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktcmVkKTtcbiAgICBib3gtc2hhZG93OiAwcHggdmFyKC0tc2l6ZS1nYXAtZG91YmxlKSB2YXIoLS1zaXplLWdhcC1xdWFkKVxuICAgICAgcmdiYSgwLCAwLCAwLCAwLjI1KTtcbiAgfVxuYDtjb25zdCBGdD1mdW5jdGlvbiBUb2FzdCh7b25DbGljazplLGNoaWxkcmVuOnQsY2xhc3NOYW1lOnJ9KXtyZXR1cm4gcC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse1wiZGF0YS1uZXh0anMtdG9hc3RcIjp0cnVlLG9uQ2xpY2s6ZSxjbGFzc05hbWU6cn0scC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse1wiZGF0YS1uZXh0anMtdG9hc3Qtd3JhcHBlclwiOnRydWV9LHQpKX07dmFyIEx0PXJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvc3RyaXAtYW5zaVwiKTt2YXIgRHQ9X19uY2N3cGNrX3JlcXVpcmVfXy5uKEx0KTtjb25zdCBNdD1mdW5jdGlvbiBDb2RlRnJhbWUoe3N0YWNrRnJhbWU6ZSxjb2RlRnJhbWU6dH0pe2NvbnN0IHI9cC51c2VNZW1vKCgoKT0+e2NvbnN0IGU9dC5zcGxpdCgvXFxyP1xcbi9nKTtjb25zdCByPWUubWFwKChlPT4vXj4/ICtcXGQrICtcXHwgWyBdKy8uZXhlYyhEdCgpKGUpKT09PW51bGw/bnVsbDovXj4/ICtcXGQrICtcXHwgKCAqKS8uZXhlYyhEdCgpKGUpKSkpLmZpbHRlcihCb29sZWFuKS5tYXAoKGU9PmUucG9wKCkpKS5yZWR1Y2UoKChlLHQpPT5pc05hTihlKT90Lmxlbmd0aDpNYXRoLm1pbihlLHQubGVuZ3RoKSksTmFOKTtpZihyPjEpe2NvbnN0IHQ9XCIgXCIucmVwZWF0KHIpO3JldHVybiBlLm1hcCgoKGUscik9Pn4ocj1lLmluZGV4T2YoXCJ8XCIpKT9lLnN1YnN0cmluZygwLHIpK2Uuc3Vic3RyaW5nKHIpLnJlcGxhY2UodCxcIlwiKTplKSkuam9pbihcIlxcblwiKX1yZXR1cm4gZS5qb2luKFwiXFxuXCIpfSksW3RdKTtjb25zdCBuPXAudXNlTWVtbygoKCk9PlR0KCkuYW5zaVRvSnNvbihyLHtqc29uOnRydWUsdXNlX2NsYXNzZXM6dHJ1ZSxyZW1vdmVfZW1wdHk6dHJ1ZX0pKSxbcl0pO2NvbnN0IGE9cC51c2VDYWxsYmFjaygoKCk9Pntjb25zdCB0PW5ldyBVUkxTZWFyY2hQYXJhbXM7Zm9yKGNvbnN0IHIgaW4gZSl7dC5hcHBlbmQociwoZVtyXT8/XCJcIikudG9TdHJpbmcoKSl9c2VsZi5mZXRjaChgJHtwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIfHxcIlwifS9fX25leHRqc19sYXVuY2gtZWRpdG9yPyR7dC50b1N0cmluZygpfWApLnRoZW4oKCgpPT57fSksKCgpPT57Y29uc29sZS5lcnJvcihcIlRoZXJlIHdhcyBhbiBpc3N1ZSBvcGVuaW5nIHRoaXMgY29kZSBpbiB5b3VyIGVkaXRvci5cIil9KSl9KSxbZV0pO3JldHVybiBwLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7XCJkYXRhLW5leHRqcy1jb2RlZnJhbWVcIjp0cnVlfSxwLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIixudWxsLHAuY3JlYXRlRWxlbWVudChcInBcIix7cm9sZTpcImxpbmtcIixvbkNsaWNrOmEsdGFiSW5kZXg6MSx0aXRsZTpcIkNsaWNrIHRvIG9wZW4gaW4geW91ciBlZGl0b3JcIn0scC5jcmVhdGVFbGVtZW50KFwic3BhblwiLG51bGwsZ2V0RnJhbWVTb3VyY2UoZSksXCIgQCBcIixlLm1ldGhvZE5hbWUpLHAuY3JlYXRlRWxlbWVudChcInN2Z1wiLHt4bWxuczpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsdmlld0JveDpcIjAgMCAyNCAyNFwiLGZpbGw6XCJub25lXCIsc3Ryb2tlOlwiY3VycmVudENvbG9yXCIsc3Ryb2tlV2lkdGg6XCIyXCIsc3Ryb2tlTGluZWNhcDpcInJvdW5kXCIsc3Ryb2tlTGluZWpvaW46XCJyb3VuZFwifSxwLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIse2Q6XCJNMTggMTN2NmEyIDIgMCAwIDEtMiAySDVhMiAyIDAgMCAxLTItMlY4YTIgMiAwIDAgMSAyLTJoNlwifSkscC5jcmVhdGVFbGVtZW50KFwicG9seWxpbmVcIix7cG9pbnRzOlwiMTUgMyAyMSAzIDIxIDlcIn0pLHAuY3JlYXRlRWxlbWVudChcImxpbmVcIix7eDE6XCIxMFwiLHkxOlwiMTRcIix4MjpcIjIxXCIseTI6XCIzXCJ9KSkpKSxwLmNyZWF0ZUVsZW1lbnQoXCJwcmVcIixudWxsLG4ubWFwKCgoZSx0KT0+cC5jcmVhdGVFbGVtZW50KFwic3BhblwiLHtrZXk6YGZyYW1lLSR7dH1gLHN0eWxlOntjb2xvcjplLmZnP2B2YXIoLS1jb2xvci0ke2UuZmd9KWA6dW5kZWZpbmVkLC4uLmUuZGVjb3JhdGlvbj09PVwiYm9sZFwiP3tmb250V2VpZ2h0OjgwMH06ZS5kZWNvcmF0aW9uPT09XCJpdGFsaWNcIj97Zm9udFN0eWxlOlwiaXRhbGljXCJ9OnVuZGVmaW5lZH19LGUuY29udGVudCkpKSkpfTtjb25zdCBSdD1mdW5jdGlvbiBDYWxsU3RhY2tGcmFtZSh7ZnJhbWU6ZX0pe2NvbnN0IHQ9ZS5vcmlnaW5hbFN0YWNrRnJhbWU/P2Uuc291cmNlU3RhY2tGcmFtZTtjb25zdCByPUJvb2xlYW4oZS5vcmlnaW5hbENvZGVGcmFtZSk7Y29uc3Qgbj1wLnVzZUNhbGxiYWNrKCgoKT0+e2lmKCFyKXJldHVybjtjb25zdCBlPW5ldyBVUkxTZWFyY2hQYXJhbXM7Zm9yKGNvbnN0IHIgaW4gdCl7ZS5hcHBlbmQociwodFtyXT8/XCJcIikudG9TdHJpbmcoKSl9c2VsZi5mZXRjaChgJHtwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIfHxcIlwifS9fX25leHRqc19sYXVuY2gtZWRpdG9yPyR7ZS50b1N0cmluZygpfWApLnRoZW4oKCgpPT57fSksKCgpPT57Y29uc29sZS5lcnJvcihcIlRoZXJlIHdhcyBhbiBpc3N1ZSBvcGVuaW5nIHRoaXMgY29kZSBpbiB5b3VyIGVkaXRvci5cIil9KSl9KSxbcix0XSk7cmV0dXJuIHAuY3JlYXRlRWxlbWVudChcImRpdlwiLHtcImRhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVcIjp0cnVlfSxwLmNyZWF0ZUVsZW1lbnQoXCJoM1wiLHtcImRhdGEtbmV4dGpzLWZyYW1lLWV4cGFuZGVkXCI6Qm9vbGVhbihlLmV4cGFuZGVkKX0sdC5tZXRob2ROYW1lKSxwLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7XCJkYXRhLWhhcy1zb3VyY2VcIjpyP1widHJ1ZVwiOnVuZGVmaW5lZCx0YWJJbmRleDpyPzEwOnVuZGVmaW5lZCxyb2xlOnI/XCJsaW5rXCI6dW5kZWZpbmVkLG9uQ2xpY2s6bix0aXRsZTpyP1wiQ2xpY2sgdG8gb3BlbiBpbiB5b3VyIGVkaXRvclwiOnVuZGVmaW5lZH0scC5jcmVhdGVFbGVtZW50KFwic3BhblwiLG51bGwsZ2V0RnJhbWVTb3VyY2UodCkpLHAuY3JlYXRlRWxlbWVudChcInN2Z1wiLHt4bWxuczpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsdmlld0JveDpcIjAgMCAyNCAyNFwiLGZpbGw6XCJub25lXCIsc3Ryb2tlOlwiY3VycmVudENvbG9yXCIsc3Ryb2tlV2lkdGg6XCIyXCIsc3Ryb2tlTGluZWNhcDpcInJvdW5kXCIsc3Ryb2tlTGluZWpvaW46XCJyb3VuZFwifSxwLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIse2Q6XCJNMTggMTN2NmEyIDIgMCAwIDEtMiAySDVhMiAyIDAgMCAxLTItMlY4YTIgMiAwIDAgMSAyLTJoNlwifSkscC5jcmVhdGVFbGVtZW50KFwicG9seWxpbmVcIix7cG9pbnRzOlwiMTUgMyAyMSAzIDIxIDlcIn0pLHAuY3JlYXRlRWxlbWVudChcImxpbmVcIix7eDE6XCIxMFwiLHkxOlwiMTRcIix4MjpcIjIxXCIseTI6XCIzXCJ9KSkpKX07Y29uc3QgenQ9ZnVuY3Rpb24gUnVudGltZUVycm9yKHtlcnJvcjplfSl7Y29uc3QgdD1wLnVzZU1lbW8oKCgpPT5lLmZyYW1lcy5maW5kSW5kZXgoKGU9PmUuZXhwYW5kZWQmJkJvb2xlYW4oZS5vcmlnaW5hbENvZGVGcmFtZSkmJkJvb2xlYW4oZS5vcmlnaW5hbFN0YWNrRnJhbWUpKSkpLFtlLmZyYW1lc10pO2NvbnN0IHI9cC51c2VNZW1vKCgoKT0+ZS5mcmFtZXNbdF0/P251bGwpLFtlLmZyYW1lcyx0XSk7Y29uc3Qgbj1wLnVzZU1lbW8oKCgpPT50PDA/W106ZS5mcmFtZXMuc2xpY2UoMCx0KSksW2UuZnJhbWVzLHRdKTtjb25zdFthLG9dPXAudXNlU3RhdGUocj09bnVsbCk7Y29uc3QgaT1wLnVzZUNhbGxiYWNrKCgoKT0+e28oKGU9PiFlKSl9KSxbXSk7Y29uc3QgbD1wLnVzZU1lbW8oKCgpPT5uLmZpbHRlcigoZT0+ZS5leHBhbmRlZHx8YSkpKSxbYSxuXSk7Y29uc3Qgcz1wLnVzZU1lbW8oKCgpPT5lLmZyYW1lcy5zbGljZSh0KzEpKSxbZS5mcmFtZXMsdF0pO2NvbnN0IHU9cC51c2VNZW1vKCgoKT0+cy5maWx0ZXIoKGU9PmUuZXhwYW5kZWR8fGEpKSksW2Esc10pO2NvbnN0IGM9cC51c2VNZW1vKCgoKT0+cy5sZW5ndGghPT11Lmxlbmd0aHx8YSYmciE9bnVsbCksW2Escy5sZW5ndGgscix1Lmxlbmd0aF0pO3JldHVybiBwLmNyZWF0ZUVsZW1lbnQocC5GcmFnbWVudCxudWxsLHI/cC5jcmVhdGVFbGVtZW50KHAuRnJhZ21lbnQsbnVsbCxwLmNyZWF0ZUVsZW1lbnQoXCJoMlwiLG51bGwsXCJTb3VyY2VcIiksbC5tYXAoKChlLHQpPT5wLmNyZWF0ZUVsZW1lbnQoUnQse2tleTpgbGVhZGluZy1mcmFtZS0ke3R9LSR7YX1gLGZyYW1lOmV9KSkpLHAuY3JlYXRlRWxlbWVudChNdCx7c3RhY2tGcmFtZTpyLm9yaWdpbmFsU3RhY2tGcmFtZSxjb2RlRnJhbWU6ci5vcmlnaW5hbENvZGVGcmFtZX0pKTp1bmRlZmluZWQsZS5jb21wb25lbnRTdGFjaz9wLmNyZWF0ZUVsZW1lbnQocC5GcmFnbWVudCxudWxsLHAuY3JlYXRlRWxlbWVudChcImgyXCIsbnVsbCxcIkNvbXBvbmVudCBTdGFja1wiKSxlLmNvbXBvbmVudFN0YWNrLm1hcCgoKGUsdCk9PnAuY3JlYXRlRWxlbWVudChcImRpdlwiLHtrZXk6dCxcImRhdGEtbmV4dGpzLWNvbXBvbmVudC1zdGFjay1mcmFtZVwiOnRydWV9LHAuY3JlYXRlRWxlbWVudChcImgzXCIsbnVsbCxlKSkpKSk6bnVsbCx1Lmxlbmd0aD9wLmNyZWF0ZUVsZW1lbnQocC5GcmFnbWVudCxudWxsLHAuY3JlYXRlRWxlbWVudChcImgyXCIsbnVsbCxcIkNhbGwgU3RhY2tcIiksdS5tYXAoKChlLHQpPT5wLmNyZWF0ZUVsZW1lbnQoUnQse2tleTpgY2FsbC1zdGFjay0ke3R9LSR7YX1gLGZyYW1lOmV9KSkpKTp1bmRlZmluZWQsYz9wLmNyZWF0ZUVsZW1lbnQocC5GcmFnbWVudCxudWxsLHAuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLHt0YWJJbmRleDoxMCxcImRhdGEtbmV4dGpzLWRhdGEtcnVudGltZS1lcnJvci1jb2xsYXBzZWQtYWN0aW9uXCI6dHJ1ZSx0eXBlOlwiYnV0dG9uXCIsb25DbGljazppfSxhP1wiSGlkZVwiOlwiU2hvd1wiLFwiIGNvbGxhcHNlZCBmcmFtZXNcIikpOnVuZGVmaW5lZCl9O2NvbnN0IEJ0PW5vb3BgXG4gIGJ1dHRvbltkYXRhLW5leHRqcy1kYXRhLXJ1bnRpbWUtZXJyb3ItY29sbGFwc2VkLWFjdGlvbl0ge1xuICAgIGJhY2tncm91bmQ6IG5vbmU7XG4gICAgYm9yZGVyOiBub25lO1xuICAgIHBhZGRpbmc6IDA7XG4gICAgZm9udC1zaXplOiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xuICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtYmlnZ2VyKTtcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYWNjZW50cy0zKTtcbiAgfVxuXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXTpub3QoOmxhc3QtY2hpbGQpLFxuICBbZGF0YS1uZXh0anMtY29tcG9uZW50LXN0YWNrLWZyYW1lXTpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xuICB9XG5cbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gaDMsXG4gIFtkYXRhLW5leHRqcy1jb21wb25lbnQtc3RhY2stZnJhbWVdID4gaDMge1xuICAgIG1hcmdpbi10b3A6IDA7XG4gICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc2l6ZS1nYXApO1xuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LXN0YWNrLW1vbm9zcGFjZSk7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLXN0YWNrLWg2KTtcbiAgfVxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBoM1tkYXRhLW5leHRqcy1mcmFtZS1leHBhbmRlZD0nZmFsc2UnXSB7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLXN0YWNrLWhlYWRsaW5lKTtcbiAgfVxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXYge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBwYWRkaW5nLWxlZnQ6IGNhbGModmFyKC0tc2l6ZS1nYXApICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpO1xuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LXNtYWxsKTtcbiAgICBjb2xvcjogdmFyKC0tY29sb3Itc3RhY2stc3VibGluZSk7XG4gIH1cbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2ID4gc3ZnIHtcbiAgICB3aWR0aDogYXV0bztcbiAgICBoZWlnaHQ6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XG4gICAgbWFyZ2luLWxlZnQ6IHZhcigtLXNpemUtZ2FwKTtcblxuICAgIGRpc3BsYXk6IG5vbmU7XG4gIH1cblxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXZbZGF0YS1oYXMtc291cmNlXSB7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICB9XG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdltkYXRhLWhhcy1zb3VyY2VdOmhvdmVyIHtcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XG4gIH1cbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2W2RhdGEtaGFzLXNvdXJjZV0gPiBzdmcge1xuICAgIGRpc3BsYXk6IHVuc2V0O1xuICB9XG5gO2Z1bmN0aW9uIGdldEVycm9yU2lnbmF0dXJlKGUpe2NvbnN0e2V2ZW50OnR9PWU7c3dpdGNoKHQudHlwZSl7Y2FzZSBvOmNhc2UgaTp7cmV0dXJuYCR7dC5yZWFzb24ubmFtZX06OiR7dC5yZWFzb24ubWVzc2FnZX06OiR7dC5yZWFzb24uc3RhY2t9YH1kZWZhdWx0Ont9fWNvbnN0IHI9dDtyZXR1cm5cIlwifWNvbnN0IEh0PWZ1bmN0aW9uIEhvdGxpbmtlZFRleHQoZSl7Y29uc3R7dGV4dDp0fT1lO2NvbnN0IHI9L2h0dHBzPzpcXC9cXC9bXlxccy8kLj8jXS5bXlxccyknXCJdKi9pO3JldHVybiBwLmNyZWF0ZUVsZW1lbnQocC5GcmFnbWVudCxudWxsLHIudGVzdCh0KT90LnNwbGl0KFwiIFwiKS5tYXAoKChlLHQsbik9PntpZihyLnRlc3QoZSkpe2NvbnN0IGE9ci5leGVjKGUpO3JldHVybiBwLmNyZWF0ZUVsZW1lbnQocC5GcmFnbWVudCx7a2V5OmBsaW5rLSR7dH1gfSxhJiZwLmNyZWF0ZUVsZW1lbnQoXCJhXCIse2hyZWY6YVswXSx0YXJnZXQ6XCJfYmxhbmtcIixyZWw6XCJub3JlZmVycmVyIG5vb3BlbmVyXCJ9LGUpLHQ9PT1uLmxlbmd0aC0xP1wiXCI6XCIgXCIpfXJldHVybiB0PT09bi5sZW5ndGgtMT9wLmNyZWF0ZUVsZW1lbnQocC5GcmFnbWVudCx7a2V5OmB0ZXh0LSR7dH1gfSxlKTpwLmNyZWF0ZUVsZW1lbnQocC5GcmFnbWVudCx7a2V5OmB0ZXh0LSR7dH1gfSxlLFwiIFwiKX0pKTp0KX07Y29uc3QgcXQ9ZnVuY3Rpb24gRXJyb3JzKHtlcnJvcnM6ZX0pe2NvbnN0W3Qscl09cC51c2VTdGF0ZSh7fSk7Y29uc3RbbixhXT1wLnVzZU1lbW8oKCgpPT57bGV0IHI9W107bGV0IG49bnVsbDtmb3IobGV0IGE9MDthPGUubGVuZ3RoOysrYSl7Y29uc3Qgbz1lW2FdO2NvbnN0e2lkOml9PW87aWYoaSBpbiB0KXtyLnB1c2godFtpXSk7Y29udGludWV9aWYoYT4wKXtjb25zdCB0PWVbYS0xXTtpZihnZXRFcnJvclNpZ25hdHVyZSh0KT09PWdldEVycm9yU2lnbmF0dXJlKG8pKXtjb250aW51ZX19bj1vO2JyZWFrfXJldHVybltyLG5dfSksW2UsdF0pO2NvbnN0IG89cC51c2VNZW1vKCgoKT0+bi5sZW5ndGg8MSYmQm9vbGVhbihlLmxlbmd0aCkpLFtlLmxlbmd0aCxuLmxlbmd0aF0pO3AudXNlRWZmZWN0KCgoKT0+e2lmKGE9PW51bGwpe3JldHVybn1sZXQgZT10cnVlO2dldEVycm9yQnlUeXBlKGEpLnRoZW4oKHQ9PntpZihlKXtyKChlPT4oey4uLmUsW3QuaWRdOnR9KSkpfX0pLCgoKT0+e30pKTtyZXR1cm4oKT0+e2U9ZmFsc2V9fSksW2FdKTtjb25zdFtpLGxdPXAudXNlU3RhdGUoXCJmdWxsc2NyZWVuXCIpO2NvbnN0W3MsdV09cC51c2VTdGF0ZSgwKTtjb25zdCBjPXAudXNlQ2FsbGJhY2soKGU9PntlPy5wcmV2ZW50RGVmYXVsdCgpO3UoKGU9Pk1hdGgubWF4KDAsZS0xKSkpfSksW10pO2NvbnN0IGQ9cC51c2VDYWxsYmFjaygoZT0+e2U/LnByZXZlbnREZWZhdWx0KCk7dSgoZT0+TWF0aC5tYXgoMCxNYXRoLm1pbihuLmxlbmd0aC0xLGUrMSkpKSl9KSxbbi5sZW5ndGhdKTtjb25zdCBmPXAudXNlTWVtbygoKCk9Pm5bc10/P251bGwpLFtzLG5dKTtwLnVzZUVmZmVjdCgoKCk9PntpZihlLmxlbmd0aDwxKXtyKHt9KTtsKFwiaGlkZGVuXCIpO3UoMCl9fSksW2UubGVuZ3RoXSk7Y29uc3QgbT1wLnVzZUNhbGxiYWNrKChlPT57ZT8ucHJldmVudERlZmF1bHQoKTtsKFwibWluaW1pemVkXCIpfSksW10pO2NvbnN0IGI9cC51c2VDYWxsYmFjaygoZT0+e2U/LnByZXZlbnREZWZhdWx0KCk7bChcImhpZGRlblwiKX0pLFtdKTtjb25zdCB2PXAudXNlQ2FsbGJhY2soKGU9PntlPy5wcmV2ZW50RGVmYXVsdCgpO2woXCJmdWxsc2NyZWVuXCIpfSksW10pO2lmKGUubGVuZ3RoPDF8fGY9PW51bGwpe3JldHVybiBudWxsfWlmKG8pe3JldHVybiBwLmNyZWF0ZUVsZW1lbnQoU3QsbnVsbCl9aWYoaT09PVwiaGlkZGVuXCIpe3JldHVybiBudWxsfWlmKGk9PT1cIm1pbmltaXplZFwiKXtyZXR1cm4gcC5jcmVhdGVFbGVtZW50KEZ0LHtjbGFzc05hbWU6XCJuZXh0anMtdG9hc3QtZXJyb3JzLXBhcmVudFwiLG9uQ2xpY2s6dn0scC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2NsYXNzTmFtZTpcIm5leHRqcy10b2FzdC1lcnJvcnNcIn0scC5jcmVhdGVFbGVtZW50KFwic3ZnXCIse3htbG5zOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIix3aWR0aDpcIjI0XCIsaGVpZ2h0OlwiMjRcIix2aWV3Qm94OlwiMCAwIDI0IDI0XCIsZmlsbDpcIm5vbmVcIixzdHJva2U6XCJjdXJyZW50Q29sb3JcIixzdHJva2VXaWR0aDpcIjJcIixzdHJva2VMaW5lY2FwOlwicm91bmRcIixzdHJva2VMaW5lam9pbjpcInJvdW5kXCJ9LHAuY3JlYXRlRWxlbWVudChcImNpcmNsZVwiLHtjeDpcIjEyXCIsY3k6XCIxMlwiLHI6XCIxMFwifSkscC5jcmVhdGVFbGVtZW50KFwibGluZVwiLHt4MTpcIjEyXCIseTE6XCI4XCIseDI6XCIxMlwiLHkyOlwiMTJcIn0pLHAuY3JlYXRlRWxlbWVudChcImxpbmVcIix7eDE6XCIxMlwiLHkxOlwiMTZcIix4MjpcIjEyLjAxXCIseTI6XCIxNlwifSkpLHAuY3JlYXRlRWxlbWVudChcInNwYW5cIixudWxsLG4ubGVuZ3RoLFwiIGVycm9yXCIsbi5sZW5ndGg+MT9cInNcIjpcIlwiKSxwLmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIix7XCJkYXRhLW5leHRqcy10b2FzdC1lcnJvcnMtaGlkZS1idXR0b25cIjp0cnVlLGNsYXNzTmFtZTpcIm5leHRqcy10b2FzdC1lcnJvcnMtaGlkZS1idXR0b25cIix0eXBlOlwiYnV0dG9uXCIsb25DbGljazplPT57ZS5zdG9wUHJvcGFnYXRpb24oKTtiKCl9LFwiYXJpYS1sYWJlbFwiOlwiSGlkZSBFcnJvcnNcIn0scC5jcmVhdGVFbGVtZW50KENsb3NlSWNvbixudWxsKSkpKX1jb25zdCBnPVtcInNlcnZlclwiLFwiZWRnZS1zZXJ2ZXJcIl0uaW5jbHVkZXMoZ2V0RXJyb3JTb3VyY2UoZi5lcnJvcil8fFwiXCIpO3JldHVybiBwLmNyZWF0ZUVsZW1lbnQoU3QsbnVsbCxwLmNyZWF0ZUVsZW1lbnQoaCx7dHlwZTpcImVycm9yXCIsXCJhcmlhLWxhYmVsbGVkYnlcIjpcIm5leHRqc19fY29udGFpbmVyX2Vycm9yc19sYWJlbFwiLFwiYXJpYS1kZXNjcmliZWRieVwiOlwibmV4dGpzX19jb250YWluZXJfZXJyb3JzX2Rlc2NcIixvbkNsb3NlOmc/dW5kZWZpbmVkOm19LHAuY3JlYXRlRWxlbWVudCh5LG51bGwscC5jcmVhdGVFbGVtZW50KEUse2NsYXNzTmFtZTpcIm5leHRqcy1jb250YWluZXItZXJyb3JzLWhlYWRlclwifSxwLmNyZWF0ZUVsZW1lbnQoT3Qse3ByZXZpb3VzOnM+MD9jOm51bGwsbmV4dDpzPG4ubGVuZ3RoLTE/ZDpudWxsLGNsb3NlOmc/dW5kZWZpbmVkOm19LHAuY3JlYXRlRWxlbWVudChcInNtYWxsXCIsbnVsbCxwLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsbnVsbCxzKzEpLFwiIG9mXCIsXCIgXCIscC5jcmVhdGVFbGVtZW50KFwic3BhblwiLG51bGwsbi5sZW5ndGgpLFwiIHVuaGFuZGxlZCBlcnJvclwiLG4ubGVuZ3RoPDI/XCJcIjpcInNcIikpLHAuY3JlYXRlRWxlbWVudChcImgxXCIse2lkOlwibmV4dGpzX19jb250YWluZXJfZXJyb3JzX2xhYmVsXCJ9LGc/XCJTZXJ2ZXIgRXJyb3JcIjpcIlVuaGFuZGxlZCBSdW50aW1lIEVycm9yXCIpLHAuY3JlYXRlRWxlbWVudChcInBcIix7aWQ6XCJuZXh0anNfX2NvbnRhaW5lcl9lcnJvcnNfZGVzY1wifSxmLmVycm9yLm5hbWUsXCI6XCIsXCIgXCIscC5jcmVhdGVFbGVtZW50KEh0LHt0ZXh0OmYuZXJyb3IubWVzc2FnZX0pKSxnP3AuY3JlYXRlRWxlbWVudChcImRpdlwiLG51bGwscC5jcmVhdGVFbGVtZW50KFwic21hbGxcIixudWxsLFwiVGhpcyBlcnJvciBoYXBwZW5lZCB3aGlsZSBnZW5lcmF0aW5nIHRoZSBwYWdlLiBBbnkgY29uc29sZSBsb2dzIHdpbGwgYmUgZGlzcGxheWVkIGluIHRoZSB0ZXJtaW5hbCB3aW5kb3cuXCIpKTp1bmRlZmluZWQpLHAuY3JlYXRlRWxlbWVudCh4LHtjbGFzc05hbWU6XCJuZXh0anMtY29udGFpbmVyLWVycm9ycy1ib2R5XCJ9LHAuY3JlYXRlRWxlbWVudCh6dCx7a2V5OmYuaWQudG9TdHJpbmcoKSxlcnJvcjpmfSkpKSkpfTtjb25zdCBQdD1ub29wYFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtaGVhZGVyID4gaDEge1xuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LWJpZyk7XG4gICAgbGluZS1oZWlnaHQ6IHZhcigtLXNpemUtZm9udC1iaWdnZXIpO1xuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgIG1hcmdpbjogMDtcbiAgICBtYXJnaW4tdG9wOiBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSk7XG4gIH1cbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWhlYWRlciBzbWFsbCB7XG4gICAgZm9udC1zaXplOiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hY2NlbnRzLTEpO1xuICAgIG1hcmdpbi1sZWZ0OiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xuICB9XG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgc21hbGwgPiBzcGFuIHtcbiAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1zdGFjay1tb25vc3BhY2UpO1xuICB9XG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgPiBwIHtcbiAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1zdGFjay1tb25vc3BhY2UpO1xuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LXNtYWxsKTtcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tc2l6ZS1mb250LWJpZyk7XG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgbWFyZ2luOiAwO1xuICAgIG1hcmdpbi10b3A6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXJlZCk7XG4gICAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xuICB9XG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgPiBkaXYgPiBzbWFsbCB7XG4gICAgbWFyZ2luOiAwO1xuICAgIG1hcmdpbi10b3A6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xuICB9XG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgPiBwID4gYSB7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktcmVkKTtcbiAgfVxuXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1ib2R5ID4gaDI6bm90KDpmaXJzdC1jaGlsZCkge1xuICAgIG1hcmdpbi10b3A6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwKSk7XG4gIH1cbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWJvZHkgPiBoMiB7XG4gICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc2l6ZS1nYXApO1xuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LWJpZyk7XG4gIH1cblxuICAubmV4dGpzLXRvYXN0LWVycm9ycy1wYXJlbnQge1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4ycyBlYXNlO1xuICB9XG4gIC5uZXh0anMtdG9hc3QtZXJyb3JzLXBhcmVudDpob3ZlciB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxLjEpO1xuICB9XG4gIC5uZXh0anMtdG9hc3QtZXJyb3JzIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xuICB9XG4gIC5uZXh0anMtdG9hc3QtZXJyb3JzID4gc3ZnIHtcbiAgICBtYXJnaW4tcmlnaHQ6IHZhcigtLXNpemUtZ2FwKTtcbiAgfVxuICAubmV4dGpzLXRvYXN0LWVycm9ycy1oaWRlLWJ1dHRvbiB7XG4gICAgbWFyZ2luLWxlZnQ6IHZhcigtLXNpemUtZ2FwLXRyaXBsZSk7XG4gICAgYm9yZGVyOiBub25lO1xuICAgIGJhY2tncm91bmQ6IG5vbmU7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYnJpZ2h0LXdoaXRlKTtcbiAgICBwYWRkaW5nOiAwO1xuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4yNXMgZWFzZTtcbiAgICBvcGFjaXR5OiAwLjc7XG4gIH1cbiAgLm5leHRqcy10b2FzdC1lcnJvcnMtaGlkZS1idXR0b246aG92ZXIge1xuICAgIG9wYWNpdHk6IDE7XG4gIH1cbmA7Y2xhc3MgRXJyb3JCb3VuZGFyeSBleHRlbmRzIGIoKS5QdXJlQ29tcG9uZW50e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKTt0aGlzLnN0YXRlPXtlcnJvcjpudWxsfX1zdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGUpe3JldHVybntlcnJvcjplfX1jb21wb25lbnREaWRDYXRjaChlLHQpe3RoaXMucHJvcHMub25FcnJvcihlLHQ/LmNvbXBvbmVudFN0YWNrfHxudWxsKTtpZighdGhpcy5wcm9wcy5nbG9iYWxPdmVybGF5KXt0aGlzLnNldFN0YXRlKHtlcnJvcjplfSl9fXJlbmRlcigpe3JldHVybiB0aGlzLnN0YXRlLmVycm9yfHx0aGlzLnByb3BzLmdsb2JhbE92ZXJsYXkmJnRoaXMucHJvcHMuaXNNb3VudGVkP3RoaXMucHJvcHMuZ2xvYmFsT3ZlcmxheT9iKCkuY3JlYXRlRWxlbWVudChcImh0bWxcIixudWxsLGIoKS5jcmVhdGVFbGVtZW50KFwiaGVhZFwiLG51bGwpLGIoKS5jcmVhdGVFbGVtZW50KFwiYm9keVwiLG51bGwpKTpudWxsOnRoaXMucHJvcHMuY2hpbGRyZW59fWZ1bmN0aW9uIEJhc2UoKXtyZXR1cm4gcC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIixudWxsLG5vb3BgXG4gICAgICAgIDpob3N0IHtcbiAgICAgICAgICAtLXNpemUtZ2FwLWhhbGY6IDRweDtcbiAgICAgICAgICAtLXNpemUtZ2FwOiA4cHg7XG4gICAgICAgICAgLS1zaXplLWdhcC1kb3VibGU6IDE2cHg7XG4gICAgICAgICAgLS1zaXplLWdhcC10cmlwbGU6IDI0cHg7XG4gICAgICAgICAgLS1zaXplLWdhcC1xdWFkOiAzMnB4O1xuXG4gICAgICAgICAgLS1zaXplLWZvbnQtc21hbGw6IDE0cHg7XG4gICAgICAgICAgLS1zaXplLWZvbnQ6IDE2cHg7XG4gICAgICAgICAgLS1zaXplLWZvbnQtYmlnOiAyMHB4O1xuICAgICAgICAgIC0tc2l6ZS1mb250LWJpZ2dlcjogMjRweDtcblxuICAgICAgICAgIC0tY29sb3ItYmFja2dyb3VuZDogd2hpdGU7XG4gICAgICAgICAgLS1jb2xvci1mb250OiAjNzU3NTc1O1xuICAgICAgICAgIC0tY29sb3ItYmFja2Ryb3A6IHJnYmEoMTcsIDE3LCAxNywgMC4yKTtcblxuICAgICAgICAgIC0tY29sb3Itc3RhY2staDY6ICMyMjI7XG4gICAgICAgICAgLS1jb2xvci1zdGFjay1oZWFkbGluZTogIzY2NjtcbiAgICAgICAgICAtLWNvbG9yLXN0YWNrLXN1YmxpbmU6ICM5OTk7XG5cbiAgICAgICAgICAtLWNvbG9yLWFjY2VudHMtMTogIzgwODA4MDtcbiAgICAgICAgICAtLWNvbG9yLWFjY2VudHMtMjogIzIyMjIyMjtcbiAgICAgICAgICAtLWNvbG9yLWFjY2VudHMtMzogIzQwNDA0MDtcblxuICAgICAgICAgIC0tZm9udC1zdGFjay1tb25vc3BhY2U6ICdTRk1vbm8tUmVndWxhcicsIENvbnNvbGFzLCAnTGliZXJhdGlvbiBNb25vJyxcbiAgICAgICAgICAgIE1lbmxvLCBDb3VyaWVyLCBtb25vc3BhY2U7XG5cbiAgICAgICAgICAtLWNvbG9yLWFuc2ktc2VsZWN0aW9uOiByZ2JhKDk1LCAxMjYsIDE1MSwgMC40OCk7XG4gICAgICAgICAgLS1jb2xvci1hbnNpLWJnOiAjMTExMTExO1xuICAgICAgICAgIC0tY29sb3ItYW5zaS1mZzogI2NjY2NjYztcblxuICAgICAgICAgIC0tY29sb3ItYW5zaS13aGl0ZTogIzc3Nzc3NztcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktYmxhY2s6ICMxNDE0MTQ7XG4gICAgICAgICAgLS1jb2xvci1hbnNpLWJsdWU6ICMwMGFhZmY7XG4gICAgICAgICAgLS1jb2xvci1hbnNpLWN5YW46ICM4OGRkZmY7XG4gICAgICAgICAgLS1jb2xvci1hbnNpLWdyZWVuOiAjOThlYzY1O1xuICAgICAgICAgIC0tY29sb3ItYW5zaS1tYWdlbnRhOiAjYWE4OGZmO1xuICAgICAgICAgIC0tY29sb3ItYW5zaS1yZWQ6ICNmZjU1NTU7XG4gICAgICAgICAgLS1jb2xvci1hbnNpLXllbGxvdzogI2ZmY2MzMztcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LXdoaXRlOiAjZmZmZmZmO1xuICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtYmxhY2s6ICM3Nzc3Nzc7XG4gICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1ibHVlOiAjMzNiYmZmO1xuICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtY3lhbjogI2JiZWNmZjtcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LWdyZWVuOiAjYjZmMjkyO1xuICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtbWFnZW50YTogI2NlYmJmZjtcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LXJlZDogI2ZmODg4ODtcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LXllbGxvdzogI2ZmZDk2NjtcbiAgICAgICAgfVxuXG4gICAgICAgIEBtZWRpYSAocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspIHtcbiAgICAgICAgICA6aG9zdCB7XG4gICAgICAgICAgICAtLWNvbG9yLWJhY2tncm91bmQ6IHJnYigyOCwgMjgsIDMwKTtcbiAgICAgICAgICAgIC0tY29sb3ItZm9udDogd2hpdGU7XG4gICAgICAgICAgICAtLWNvbG9yLWJhY2tkcm9wOiByZ2IoNDQsIDQ0LCA0Nik7XG5cbiAgICAgICAgICAgIC0tY29sb3Itc3RhY2staDY6IHJnYigyMDAsIDIwMCwgMjA0KTtcbiAgICAgICAgICAgIC0tY29sb3Itc3RhY2staGVhZGxpbmU6IHJnYig5OSwgOTksIDEwMik7XG4gICAgICAgICAgICAtLWNvbG9yLXN0YWNrLXN1YmxpbmU6IHJnYmEoMTQyLCAxNDIsIDE0Nyk7XG5cbiAgICAgICAgICAgIC0tY29sb3ItYWNjZW50cy0zOiByZ2IoMTE4LCAxMTgsIDExOCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLm1vbm8ge1xuICAgICAgICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LXN0YWNrLW1vbm9zcGFjZSk7XG4gICAgICAgIH1cblxuICAgICAgICBoMSxcbiAgICAgICAgaDIsXG4gICAgICAgIGgzLFxuICAgICAgICBoNCxcbiAgICAgICAgaDUsXG4gICAgICAgIGg2IHtcbiAgICAgICAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcCk7XG4gICAgICAgICAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgICAgICAgICBsaW5lLWhlaWdodDogMS41O1xuICAgICAgICB9XG4gICAgICBgKX1jb25zdCBXdD1ub29wYFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSB7XG4gICAgb3ZlcmZsb3c6IGF1dG87XG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1iZyk7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktZmcpO1xuICB9XG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdOjpzZWxlY3Rpb24sXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdICo6OnNlbGVjdGlvbiB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1zZWxlY3Rpb24pO1xuICB9XG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdICoge1xuICAgIGNvbG9yOiBpbmhlcml0O1xuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LXN0YWNrLW1vbm9zcGFjZSk7XG4gIH1cblxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSA+ICoge1xuICAgIG1hcmdpbjogMDtcbiAgICBwYWRkaW5nOiBjYWxjKHZhcigtLXNpemUtZ2FwKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKVxuICAgICAgY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpO1xuICB9XG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdID4gZGl2IHtcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgd2lkdGg6IGF1dG87XG4gICAgbWluLXdpZHRoOiAxMDAlO1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCB2YXIoLS1jb2xvci1hbnNpLWJyaWdodC1ibGFjayk7XG4gIH1cbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gPiBkaXYgPiBwIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBtYXJnaW46IDA7XG4gIH1cbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gPiBkaXYgPiBwOmhvdmVyIHtcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XG4gIH1cbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gZGl2ID4gcCA+IHN2ZyB7XG4gICAgd2lkdGg6IGF1dG87XG4gICAgaGVpZ2h0OiAxZW07XG4gICAgbWFyZ2luLWxlZnQ6IDhweDtcbiAgfVxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSBkaXYgPiBwcmUge1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICB9XG5gO2NvbnN0IFZ0PW5vb3BgXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctb3ZlcmxheV0ge1xuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICB0b3A6IDA7XG4gICAgcmlnaHQ6IDA7XG4gICAgYm90dG9tOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgb3ZlcmZsb3c6IGF1dG87XG4gICAgei1pbmRleDogOTAwMDtcblxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBwYWRkaW5nOiAxMHZoIDE1cHggMDtcbiAgfVxuXG4gIEBtZWRpYSAobWF4LWhlaWdodDogODEycHgpIHtcbiAgICBbZGF0YS1uZXh0anMtZGlhbG9nLW92ZXJsYXldIHtcbiAgICAgIHBhZGRpbmc6IDE1cHggMTVweCAwO1xuICAgIH1cbiAgfVxuXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFja2Ryb3BdIHtcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgdG9wOiAwO1xuICAgIHJpZ2h0OiAwO1xuICAgIGJvdHRvbTogMDtcbiAgICBsZWZ0OiAwO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWJhY2tkcm9wKTtcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xuICAgIHotaW5kZXg6IC0xO1xuICB9XG5cbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYWNrZHJvcC1maXhlZF0ge1xuICAgIGN1cnNvcjogbm90LWFsbG93ZWQ7XG4gICAgLXdlYmtpdC1iYWNrZHJvcC1maWx0ZXI6IGJsdXIoOHB4KTtcbiAgICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoOHB4KTtcbiAgfVxuYDtjb25zdCAkdD1ub29wYFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdIHtcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1zaXplLWdhcC1oYWxmKTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLWJnKTtcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1mZyk7XG4gIH1cbiAgW2RhdGEtbmV4dGpzLXRlcm1pbmFsXTo6c2VsZWN0aW9uLFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdICo6OnNlbGVjdGlvbiB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1zZWxlY3Rpb24pO1xuICB9XG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gKiB7XG4gICAgY29sb3I6IGluaGVyaXQ7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcbiAgfVxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdID4gKiB7XG4gICAgbWFyZ2luOiAwO1xuICAgIHBhZGRpbmc6IGNhbGModmFyKC0tc2l6ZS1nYXApICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpXG4gICAgICBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSk7XG4gIH1cblxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdIHByZSB7XG4gICAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xuICAgIHdvcmQtYnJlYWs6IGJyZWFrLXdvcmQ7XG4gIH1cbmA7ZnVuY3Rpb24gQ29tcG9uZW50U3R5bGVzKCl7cmV0dXJuIHAuY3JlYXRlRWxlbWVudChcInN0eWxlXCIsbnVsbCxub29wYFxuICAgICAgICAke1Z0fVxuICAgICAgICAke0l0fVxuICAgICAgICAke3d9XG4gICAgICAgICR7TnR9XG4gICAgICAgICR7V3R9XG4gICAgICAgICR7JHR9XG4gICAgICAgIFxuICAgICAgICAke0F0fVxuICAgICAgICAke1B0fVxuICAgICAgICAke0J0fVxuICAgICAgYCl9ZnVuY3Rpb24gQ3NzUmVzZXQoKXtyZXR1cm4gcC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIixudWxsLG5vb3BgXG4gICAgICAgIDpob3N0IHtcbiAgICAgICAgICBhbGw6IGluaXRpYWw7XG5cbiAgICAgICAgICAvKiB0aGUgZGlyZWN0aW9uIHByb3BlcnR5IGlzIG5vdCByZXNldCBieSAnYWxsJyAqL1xuICAgICAgICAgIGRpcmVjdGlvbjogbHRyO1xuICAgICAgICB9XG5cbiAgICAgICAgLyohXG4gICAgICAgICAqIEJvb3RzdHJhcCBSZWJvb3QgdjQuNC4xIChodHRwczovL2dldGJvb3RzdHJhcC5jb20vKVxuICAgICAgICAgKiBDb3B5cmlnaHQgMjAxMS0yMDE5IFRoZSBCb290c3RyYXAgQXV0aG9yc1xuICAgICAgICAgKiBDb3B5cmlnaHQgMjAxMS0yMDE5IFR3aXR0ZXIsIEluYy5cbiAgICAgICAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAgICAgICAgICogRm9ya2VkIGZyb20gTm9ybWFsaXplLmNzcywgbGljZW5zZWQgTUlUIChodHRwczovL2dpdGh1Yi5jb20vbmVjb2xhcy9ub3JtYWxpemUuY3NzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQpXG4gICAgICAgICAqL1xuICAgICAgICAqLFxuICAgICAgICAqOjpiZWZvcmUsXG4gICAgICAgICo6OmFmdGVyIHtcbiAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICB9XG5cbiAgICAgICAgOmhvc3Qge1xuICAgICAgICAgIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xuICAgICAgICAgIGxpbmUtaGVpZ2h0OiAxLjE1O1xuICAgICAgICAgIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogMTAwJTtcbiAgICAgICAgICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBhcnRpY2xlLFxuICAgICAgICBhc2lkZSxcbiAgICAgICAgZmlnY2FwdGlvbixcbiAgICAgICAgZmlndXJlLFxuICAgICAgICBmb290ZXIsXG4gICAgICAgIGhlYWRlcixcbiAgICAgICAgaGdyb3VwLFxuICAgICAgICBtYWluLFxuICAgICAgICBuYXYsXG4gICAgICAgIHNlY3Rpb24ge1xuICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICB9XG5cbiAgICAgICAgOmhvc3Qge1xuICAgICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgICBmb250LWZhbWlseTogLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCAnU2Vnb2UgVUknLCBSb2JvdG8sXG4gICAgICAgICAgICAnSGVsdmV0aWNhIE5ldWUnLCBBcmlhbCwgJ05vdG8gU2FucycsIHNhbnMtc2VyaWYsXG4gICAgICAgICAgICAnQXBwbGUgQ29sb3IgRW1vamknLCAnU2Vnb2UgVUkgRW1vamknLCAnU2Vnb2UgVUkgU3ltYm9sJyxcbiAgICAgICAgICAgICdOb3RvIENvbG9yIEVtb2ppJztcbiAgICAgICAgICBmb250LXNpemU6IDE2cHg7XG4gICAgICAgICAgZm9udC13ZWlnaHQ6IDQwMDtcbiAgICAgICAgICBsaW5lLWhlaWdodDogMS41O1xuICAgICAgICAgIGNvbG9yOiB2YXIoLS1jb2xvci1mb250KTtcbiAgICAgICAgICB0ZXh0LWFsaWduOiBsZWZ0O1xuICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XG4gICAgICAgIH1cblxuICAgICAgICBbdGFiaW5kZXg9Jy0xJ106Zm9jdXM6bm90KDpmb2N1cy12aXNpYmxlKSB7XG4gICAgICAgICAgb3V0bGluZTogMCAhaW1wb3J0YW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaHIge1xuICAgICAgICAgIGJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xuICAgICAgICAgIGhlaWdodDogMDtcbiAgICAgICAgICBvdmVyZmxvdzogdmlzaWJsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGgxLFxuICAgICAgICBoMixcbiAgICAgICAgaDMsXG4gICAgICAgIGg0LFxuICAgICAgICBoNSxcbiAgICAgICAgaDYge1xuICAgICAgICAgIG1hcmdpbi10b3A6IDA7XG4gICAgICAgICAgbWFyZ2luLWJvdHRvbTogOHB4O1xuICAgICAgICB9XG5cbiAgICAgICAgcCB7XG4gICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxNnB4O1xuICAgICAgICB9XG5cbiAgICAgICAgYWJiclt0aXRsZV0sXG4gICAgICAgIGFiYnJbZGF0YS1vcmlnaW5hbC10aXRsZV0ge1xuICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xuICAgICAgICAgIC13ZWJraXQtdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xuICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcbiAgICAgICAgICBjdXJzb3I6IGhlbHA7XG4gICAgICAgICAgYm9yZGVyLWJvdHRvbTogMDtcbiAgICAgICAgICAtd2Via2l0LXRleHQtZGVjb3JhdGlvbi1za2lwLWluazogbm9uZTtcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb24tc2tpcC1pbms6IG5vbmU7XG4gICAgICAgIH1cblxuICAgICAgICBhZGRyZXNzIHtcbiAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxNnB4O1xuICAgICAgICAgIGZvbnQtc3R5bGU6IG5vcm1hbDtcbiAgICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIG9sLFxuICAgICAgICB1bCxcbiAgICAgICAgZGwge1xuICAgICAgICAgIG1hcmdpbi10b3A6IDA7XG4gICAgICAgICAgbWFyZ2luLWJvdHRvbTogMTZweDtcbiAgICAgICAgfVxuXG4gICAgICAgIG9sIG9sLFxuICAgICAgICB1bCB1bCxcbiAgICAgICAgb2wgdWwsXG4gICAgICAgIHVsIG9sIHtcbiAgICAgICAgICBtYXJnaW4tYm90dG9tOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZHQge1xuICAgICAgICAgIGZvbnQtd2VpZ2h0OiA3MDA7XG4gICAgICAgIH1cblxuICAgICAgICBkZCB7XG4gICAgICAgICAgbWFyZ2luLWJvdHRvbTogOHB4O1xuICAgICAgICAgIG1hcmdpbi1sZWZ0OiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgYmxvY2txdW90ZSB7XG4gICAgICAgICAgbWFyZ2luOiAwIDAgMTZweDtcbiAgICAgICAgfVxuXG4gICAgICAgIGIsXG4gICAgICAgIHN0cm9uZyB7XG4gICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNtYWxsIHtcbiAgICAgICAgICBmb250LXNpemU6IDgwJTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1YixcbiAgICAgICAgc3VwIHtcbiAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgICAgZm9udC1zaXplOiA3NSU7XG4gICAgICAgICAgbGluZS1oZWlnaHQ6IDA7XG4gICAgICAgICAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xuICAgICAgICB9XG5cbiAgICAgICAgc3ViIHtcbiAgICAgICAgICBib3R0b206IC0wLjI1ZW07XG4gICAgICAgIH1cblxuICAgICAgICBzdXAge1xuICAgICAgICAgIHRvcDogLTAuNWVtO1xuICAgICAgICB9XG5cbiAgICAgICAgYSB7XG4gICAgICAgICAgY29sb3I6ICMwMDdiZmY7XG4gICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgYTpob3ZlciB7XG4gICAgICAgICAgY29sb3I6ICMwMDU2YjM7XG4gICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG4gICAgICAgIH1cblxuICAgICAgICBhOm5vdChbaHJlZl0pIHtcbiAgICAgICAgICBjb2xvcjogaW5oZXJpdDtcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XG4gICAgICAgIH1cblxuICAgICAgICBhOm5vdChbaHJlZl0pOmhvdmVyIHtcbiAgICAgICAgICBjb2xvcjogaW5oZXJpdDtcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XG4gICAgICAgIH1cblxuICAgICAgICBwcmUsXG4gICAgICAgIGNvZGUsXG4gICAgICAgIGtiZCxcbiAgICAgICAgc2FtcCB7XG4gICAgICAgICAgZm9udC1mYW1pbHk6IFNGTW9uby1SZWd1bGFyLCBNZW5sbywgTW9uYWNvLCBDb25zb2xhcyxcbiAgICAgICAgICAgICdMaWJlcmF0aW9uIE1vbm8nLCAnQ291cmllciBOZXcnLCBtb25vc3BhY2U7XG4gICAgICAgICAgZm9udC1zaXplOiAxZW07XG4gICAgICAgIH1cblxuICAgICAgICBwcmUge1xuICAgICAgICAgIG1hcmdpbi10b3A6IDA7XG4gICAgICAgICAgbWFyZ2luLWJvdHRvbTogMTZweDtcbiAgICAgICAgICBvdmVyZmxvdzogYXV0bztcbiAgICAgICAgfVxuXG4gICAgICAgIGZpZ3VyZSB7XG4gICAgICAgICAgbWFyZ2luOiAwIDAgMTZweDtcbiAgICAgICAgfVxuXG4gICAgICAgIGltZyB7XG4gICAgICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbiAgICAgICAgICBib3JkZXItc3R5bGU6IG5vbmU7XG4gICAgICAgIH1cblxuICAgICAgICBzdmcge1xuICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhYmxlIHtcbiAgICAgICAgICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FwdGlvbiB7XG4gICAgICAgICAgcGFkZGluZy10b3A6IDEycHg7XG4gICAgICAgICAgcGFkZGluZy1ib3R0b206IDEycHg7XG4gICAgICAgICAgY29sb3I6ICM2Yzc1N2Q7XG4gICAgICAgICAgdGV4dC1hbGlnbjogbGVmdDtcbiAgICAgICAgICBjYXB0aW9uLXNpZGU6IGJvdHRvbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoIHtcbiAgICAgICAgICB0ZXh0LWFsaWduOiBpbmhlcml0O1xuICAgICAgICB9XG5cbiAgICAgICAgbGFiZWwge1xuICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgICBtYXJnaW4tYm90dG9tOiA4cHg7XG4gICAgICAgIH1cblxuICAgICAgICBidXR0b24ge1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDA7XG4gICAgICAgIH1cblxuICAgICAgICBidXR0b246Zm9jdXMge1xuICAgICAgICAgIG91dGxpbmU6IDFweCBkb3R0ZWQ7XG4gICAgICAgICAgb3V0bGluZTogNXB4IGF1dG8gLXdlYmtpdC1mb2N1cy1yaW5nLWNvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXQsXG4gICAgICAgIGJ1dHRvbixcbiAgICAgICAgc2VsZWN0LFxuICAgICAgICBvcHRncm91cCxcbiAgICAgICAgdGV4dGFyZWEge1xuICAgICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgICBmb250LWZhbWlseTogaW5oZXJpdDtcbiAgICAgICAgICBmb250LXNpemU6IGluaGVyaXQ7XG4gICAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XG4gICAgICAgIH1cblxuICAgICAgICBidXR0b24sXG4gICAgICAgIGlucHV0IHtcbiAgICAgICAgICBvdmVyZmxvdzogdmlzaWJsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1dHRvbixcbiAgICAgICAgc2VsZWN0IHtcbiAgICAgICAgICB0ZXh0LXRyYW5zZm9ybTogbm9uZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGVjdCB7XG4gICAgICAgICAgd29yZC13cmFwOiBub3JtYWw7XG4gICAgICAgIH1cblxuICAgICAgICBidXR0b24sXG4gICAgICAgIFt0eXBlPSdidXR0b24nXSxcbiAgICAgICAgW3R5cGU9J3Jlc2V0J10sXG4gICAgICAgIFt0eXBlPSdzdWJtaXQnXSB7XG4gICAgICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247XG4gICAgICAgIH1cblxuICAgICAgICBidXR0b246bm90KDpkaXNhYmxlZCksXG4gICAgICAgIFt0eXBlPSdidXR0b24nXTpub3QoOmRpc2FibGVkKSxcbiAgICAgICAgW3R5cGU9J3Jlc2V0J106bm90KDpkaXNhYmxlZCksXG4gICAgICAgIFt0eXBlPSdzdWJtaXQnXTpub3QoOmRpc2FibGVkKSB7XG4gICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgYnV0dG9uOjotbW96LWZvY3VzLWlubmVyLFxuICAgICAgICBbdHlwZT0nYnV0dG9uJ106Oi1tb3otZm9jdXMtaW5uZXIsXG4gICAgICAgIFt0eXBlPSdyZXNldCddOjotbW96LWZvY3VzLWlubmVyLFxuICAgICAgICBbdHlwZT0nc3VibWl0J106Oi1tb3otZm9jdXMtaW5uZXIge1xuICAgICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgICAgYm9yZGVyLXN0eWxlOiBub25lO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXRbdHlwZT0ncmFkaW8nXSxcbiAgICAgICAgaW5wdXRbdHlwZT0nY2hlY2tib3gnXSB7XG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXRbdHlwZT0nZGF0ZSddLFxuICAgICAgICBpbnB1dFt0eXBlPSd0aW1lJ10sXG4gICAgICAgIGlucHV0W3R5cGU9J2RhdGV0aW1lLWxvY2FsJ10sXG4gICAgICAgIGlucHV0W3R5cGU9J21vbnRoJ10ge1xuICAgICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogbGlzdGJveDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRleHRhcmVhIHtcbiAgICAgICAgICBvdmVyZmxvdzogYXV0bztcbiAgICAgICAgICByZXNpemU6IHZlcnRpY2FsO1xuICAgICAgICB9XG5cbiAgICAgICAgZmllbGRzZXQge1xuICAgICAgICAgIG1pbi13aWR0aDogMDtcbiAgICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgICBib3JkZXI6IDA7XG4gICAgICAgIH1cblxuICAgICAgICBsZWdlbmQge1xuICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgIG1heC13aWR0aDogMTAwJTtcbiAgICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICAgIG1hcmdpbi1ib3R0b206IDhweDtcbiAgICAgICAgICBmb250LXNpemU6IDI0cHg7XG4gICAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XG4gICAgICAgICAgY29sb3I6IGluaGVyaXQ7XG4gICAgICAgICAgd2hpdGUtc3BhY2U6IG5vcm1hbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb2dyZXNzIHtcbiAgICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XG4gICAgICAgIH1cblxuICAgICAgICBbdHlwZT0nbnVtYmVyJ106Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24sXG4gICAgICAgIFt0eXBlPSdudW1iZXInXTo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbiB7XG4gICAgICAgICAgaGVpZ2h0OiBhdXRvO1xuICAgICAgICB9XG5cbiAgICAgICAgW3R5cGU9J3NlYXJjaCddIHtcbiAgICAgICAgICBvdXRsaW5lLW9mZnNldDogLTJweDtcbiAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XG4gICAgICAgIH1cblxuICAgICAgICBbdHlwZT0nc2VhcmNoJ106Oi13ZWJraXQtc2VhcmNoLWRlY29yYXRpb24ge1xuICAgICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcbiAgICAgICAgfVxuXG4gICAgICAgIDo6LXdlYmtpdC1maWxlLXVwbG9hZC1idXR0b24ge1xuICAgICAgICAgIGZvbnQ6IGluaGVyaXQ7XG4gICAgICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247XG4gICAgICAgIH1cblxuICAgICAgICBvdXRwdXQge1xuICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgfVxuXG4gICAgICAgIHN1bW1hcnkge1xuICAgICAgICAgIGRpc3BsYXk6IGxpc3QtaXRlbTtcbiAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIH1cblxuICAgICAgICB0ZW1wbGF0ZSB7XG4gICAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgICAgfVxuXG4gICAgICAgIFtoaWRkZW5dIHtcbiAgICAgICAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XG4gICAgICAgIH1cbiAgICAgIGApfWZ1bmN0aW9uIHB1c2hFcnJvckZpbHRlckR1cGxpY2F0ZXMoZSx0KXtyZXR1cm5bLi4uZS5maWx0ZXIoKGU9PmUuZXZlbnQucmVhc29uIT09dC5ldmVudC5yZWFzb24pKSx0XX1mdW5jdGlvbiByZWR1Y2VyKHIsbCl7c3dpdGNoKGwudHlwZSl7Y2FzZSBlOntyZXR1cm57Li4ucixidWlsZEVycm9yOm51bGx9fWNhc2UgdDp7cmV0dXJuey4uLnIsYnVpbGRFcnJvcjpsLm1lc3NhZ2V9fWNhc2UgYTp7cmV0dXJuey4uLnIscmVmcmVzaFN0YXRlOnt0eXBlOlwicGVuZGluZ1wiLGVycm9yczpbXX19fWNhc2Ugbjp7cmV0dXJuey4uLnIsYnVpbGRFcnJvcjpudWxsLGVycm9yczpyLnJlZnJlc2hTdGF0ZS50eXBlPT09XCJwZW5kaW5nXCI/ci5yZWZyZXNoU3RhdGUuZXJyb3JzOltdLHJlZnJlc2hTdGF0ZTp7dHlwZTpcImlkbGVcIn19fWNhc2UgbzpjYXNlIGk6e3N3aXRjaChyLnJlZnJlc2hTdGF0ZS50eXBlKXtjYXNlXCJpZGxlXCI6e3JldHVybnsuLi5yLG5leHRJZDpyLm5leHRJZCsxLGVycm9yczpwdXNoRXJyb3JGaWx0ZXJEdXBsaWNhdGVzKHIuZXJyb3JzLHtpZDpyLm5leHRJZCxldmVudDpsfSl9fWNhc2VcInBlbmRpbmdcIjp7cmV0dXJuey4uLnIsbmV4dElkOnIubmV4dElkKzEscmVmcmVzaFN0YXRlOnsuLi5yLnJlZnJlc2hTdGF0ZSxlcnJvcnM6cHVzaEVycm9yRmlsdGVyRHVwbGljYXRlcyhyLnJlZnJlc2hTdGF0ZS5lcnJvcnMse2lkOnIubmV4dElkLGV2ZW50Omx9KX19fWRlZmF1bHQ6Y29uc3QgZT1yLnJlZnJlc2hTdGF0ZTtyZXR1cm4gcn19ZGVmYXVsdDp7Y29uc3QgZT1sO3JldHVybiByfX19Y29uc3Qgc2hvdWxkUHJldmVudERpc3BsYXk9KGUsdCk9PntpZighdHx8IWUpe3JldHVybiBmYWxzZX1yZXR1cm4gdC5pbmNsdWRlcyhlKX07Y29uc3QgS3Q9ZnVuY3Rpb24gUmVhY3REZXZPdmVybGF5KHtjaGlsZHJlbjplLHByZXZlbnREaXNwbGF5OnQsZ2xvYmFsT3ZlcmxheTpyfSl7Y29uc3RbbixhXT1wLnVzZVJlZHVjZXIocmVkdWNlcix7bmV4dElkOjEsYnVpbGRFcnJvcjpudWxsLGVycm9yczpbXSxyZWZyZXNoU3RhdGU6e3R5cGU6XCJpZGxlXCJ9fSk7cC51c2VFZmZlY3QoKCgpPT57b24oYSk7cmV0dXJuIGZ1bmN0aW9uKCl7b2ZmKGEpfX0pLFthXSk7Y29uc3Qgbz1wLnVzZUNhbGxiYWNrKCgoZSx0KT0+e30pLFtdKTtjb25zdCBpPW4uYnVpbGRFcnJvciE9bnVsbDtjb25zdCBsPUJvb2xlYW4obi5lcnJvcnMubGVuZ3RoKTtjb25zdCBzPWk/XCJidWlsZFwiOmw/XCJydW50aW1lXCI6bnVsbDtjb25zdCB1PXMhPT1udWxsO3JldHVybiBwLmNyZWF0ZUVsZW1lbnQocC5GcmFnbWVudCxudWxsLHAuY3JlYXRlRWxlbWVudChFcnJvckJvdW5kYXJ5LHtnbG9iYWxPdmVybGF5OnIsaXNNb3VudGVkOnUsb25FcnJvcjpvfSxlPz9udWxsKSx1P3AuY3JlYXRlRWxlbWVudChnLHtnbG9iYWxPdmVybGF5OnJ9LHAuY3JlYXRlRWxlbWVudChDc3NSZXNldCxudWxsKSxwLmNyZWF0ZUVsZW1lbnQoQmFzZSxudWxsKSxwLmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50U3R5bGVzLG51bGwpLHNob3VsZFByZXZlbnREaXNwbGF5KHMsdCk/bnVsbDppP3AuY3JlYXRlRWxlbWVudChqdCx7bWVzc2FnZTpuLmJ1aWxkRXJyb3J9KTpsP3AuY3JlYXRlRWxlbWVudChxdCx7ZXJyb3JzOm4uZXJyb3JzfSk6dW5kZWZpbmVkKTp1bmRlZmluZWQpfTt2YXIgWnQ9S3Q7KDAsZi5wYXRjaENvbnNvbGVFcnJvcikoKTtsZXQgVXQ9ZmFsc2U7bGV0IEd0PXVuZGVmaW5lZDtmdW5jdGlvbiBvblVuaGFuZGxlZEVycm9yKGUpe2NvbnN0IHQ9ZT8uZXJyb3I7aWYoIXR8fCEodCBpbnN0YW5jZW9mIEVycm9yKXx8dHlwZW9mIHQuc3RhY2shPT1cInN0cmluZ1wiKXtyZXR1cm59aWYodC5tZXNzYWdlLm1hdGNoKC8oaHlkcmF0aW9ufGNvbnRlbnQgZG9lcyBub3QgbWF0Y2h8ZGlkIG5vdCBtYXRjaCkvaSkpe2lmKGYuaHlkcmF0aW9uRXJyb3JXYXJuaW5nKXt0Lm1lc3NhZ2UrPVwiXFxuXFxuXCIrZi5oeWRyYXRpb25FcnJvcldhcm5pbmd9dC5tZXNzYWdlKz1gXFxuXFxuU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9yZWFjdC1oeWRyYXRpb24tZXJyb3JgfWNvbnN0IHI9dDtjb25zdCBuPXR5cGVvZiBmLmh5ZHJhdGlvbkVycm9yQ29tcG9uZW50U3RhY2s9PT1cInN0cmluZ1wiPygwLGQucGFyc2VDb21wb25lbnRTdGFjaykoZi5oeWRyYXRpb25FcnJvckNvbXBvbmVudFN0YWNrKS5tYXAoKGU9PmUuY29tcG9uZW50KSk6dW5kZWZpbmVkO2VtaXQoe3R5cGU6byxyZWFzb246dCxmcmFtZXM6cGFyc2VTdGFjayhyLnN0YWNrKSxjb21wb25lbnRTdGFjazpufSl9ZnVuY3Rpb24gb25VbmhhbmRsZWRSZWplY3Rpb24oZSl7Y29uc3QgdD1lPy5yZWFzb247aWYoIXR8fCEodCBpbnN0YW5jZW9mIEVycm9yKXx8dHlwZW9mIHQuc3RhY2shPT1cInN0cmluZ1wiKXtyZXR1cm59Y29uc3Qgcj10O2VtaXQoe3R5cGU6aSxyZWFzb246dCxmcmFtZXM6cGFyc2VTdGFjayhyLnN0YWNrKX0pfWZ1bmN0aW9uIHJlZ2lzdGVyKCl7aWYoVXQpe3JldHVybn1VdD10cnVlO3RyeXtjb25zdCBlPUVycm9yLnN0YWNrVHJhY2VMaW1pdDtFcnJvci5zdGFja1RyYWNlTGltaXQ9NTA7R3Q9ZX1jYXRjaHt9d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLG9uVW5oYW5kbGVkRXJyb3IpO3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidW5oYW5kbGVkcmVqZWN0aW9uXCIsb25VbmhhbmRsZWRSZWplY3Rpb24pfWZ1bmN0aW9uIHVucmVnaXN0ZXIoKXtpZighVXQpe3JldHVybn1VdD1mYWxzZTtpZihHdCE9PXVuZGVmaW5lZCl7dHJ5e0Vycm9yLnN0YWNrVHJhY2VMaW1pdD1HdH1jYXRjaHt9R3Q9dW5kZWZpbmVkfXdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIixvblVuaGFuZGxlZEVycm9yKTt3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInVuaGFuZGxlZHJlamVjdGlvblwiLG9uVW5oYW5kbGVkUmVqZWN0aW9uKX1mdW5jdGlvbiBvbkJ1aWxkT2soKXtlbWl0KHt0eXBlOmV9KX1mdW5jdGlvbiBvbkJ1aWxkRXJyb3IoZSl7ZW1pdCh7dHlwZTp0LG1lc3NhZ2U6ZX0pfWZ1bmN0aW9uIG9uUmVmcmVzaCgpe2VtaXQoe3R5cGU6bn0pfWZ1bmN0aW9uIG9uQmVmb3JlUmVmcmVzaCgpe2VtaXQoe3R5cGU6YX0pfX0oKTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/@next/react-dev-overlay/dist/client.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/dev/dev-build-watcher.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/dev-build-watcher.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* eslint-disable @typescript-eslint/no-use-before-define */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return initializeBuildWatcher;\n    }\n}));\nconst _websocket = __webpack_require__(/*! ./error-overlay/websocket */ \"./node_modules/next/dist/client/dev/error-overlay/websocket.js\");\nfunction initializeBuildWatcher(toggleCallback, position) {\n    if (position === void 0) position = \"bottom-right\";\n    const shadowHost = document.createElement(\"div\");\n    const [verticalProperty, horizontalProperty] = position.split(\"-\");\n    shadowHost.id = \"__next-build-watcher\";\n    // Make sure container is fixed and on a high zIndex so it shows\n    shadowHost.style.position = \"fixed\";\n    // Ensure container's position to be top or bottom (default)\n    shadowHost.style[verticalProperty] = \"10px\";\n    // Ensure container's position to be left or right (default)\n    shadowHost.style[horizontalProperty] = \"20px\";\n    shadowHost.style.width = \"0\";\n    shadowHost.style.height = \"0\";\n    shadowHost.style.zIndex = \"99999\";\n    document.body.appendChild(shadowHost);\n    let shadowRoot;\n    let prefix = \"\";\n    if (shadowHost.attachShadow) {\n        shadowRoot = shadowHost.attachShadow({\n            mode: \"open\"\n        });\n    } else {\n        // If attachShadow is undefined then the browser does not support\n        // the Shadow DOM, we need to prefix all the names so there\n        // will be no conflicts\n        shadowRoot = shadowHost;\n        prefix = \"__next-build-watcher-\";\n    }\n    // Container\n    const container = createContainer(prefix);\n    shadowRoot.appendChild(container);\n    // CSS\n    const css = createCss(prefix, {\n        horizontalProperty,\n        verticalProperty\n    });\n    shadowRoot.appendChild(css);\n    // State\n    let isVisible = false;\n    let isBuilding = false;\n    let timeoutId = null;\n    // Handle events\n    (0, _websocket.addMessageListener)((event)=>{\n        // This is the heartbeat event\n        if (event.data === \"\\uD83D\\uDC93\") {\n            return;\n        }\n        try {\n            handleMessage(event);\n        } catch (e) {}\n    });\n    function handleMessage(event) {\n        const obj = typeof event === \"string\" ? {\n            action: event\n        } : JSON.parse(event.data);\n        // eslint-disable-next-line default-case\n        switch(obj.action){\n            case \"building\":\n                timeoutId && clearTimeout(timeoutId);\n                isVisible = true;\n                isBuilding = true;\n                updateContainer();\n                break;\n            case \"built\":\n            case \"sync\":\n                isBuilding = false;\n                // Wait for the fade out transition to complete\n                timeoutId = setTimeout(()=>{\n                    isVisible = false;\n                    updateContainer();\n                }, 100);\n                updateContainer();\n                break;\n        }\n    }\n    toggleCallback(handleMessage);\n    function updateContainer() {\n        if (isBuilding) {\n            container.classList.add(\"\" + prefix + \"building\");\n        } else {\n            container.classList.remove(\"\" + prefix + \"building\");\n        }\n        if (isVisible) {\n            container.classList.add(\"\" + prefix + \"visible\");\n        } else {\n            container.classList.remove(\"\" + prefix + \"visible\");\n        }\n    }\n}\nfunction createContainer(prefix) {\n    const container = document.createElement(\"div\");\n    container.id = \"\" + prefix + \"container\";\n    container.innerHTML = '\\n    <div id=\"' + prefix + 'icon-wrapper\">\\n      <svg viewBox=\"0 0 226 200\">\\n        <defs>\\n          <linearGradient\\n            x1=\"114.720775%\"\\n            y1=\"181.283245%\"\\n            x2=\"39.5399306%\"\\n            y2=\"100%\"\\n            id=\"' + prefix + 'linear-gradient\"\\n          >\\n            <stop stop-color=\"#000000\" offset=\"0%\" />\\n            <stop stop-color=\"#FFFFFF\" offset=\"100%\" />\\n          </linearGradient>\\n        </defs>\\n        <g id=\"' + prefix + 'icon-group\" fill=\"none\" stroke=\"url(#' + prefix + 'linear-gradient)\" stroke-width=\"18\">\\n          <path d=\"M113,5.08219117 L4.28393801,197.5 L221.716062,197.5 L113,5.08219117 Z\" />\\n        </g>\\n      </svg>\\n    </div>\\n  ';\n    return container;\n}\nfunction createCss(prefix, param) {\n    let { horizontalProperty, verticalProperty } = param;\n    const css = document.createElement(\"style\");\n    css.textContent = \"\\n    #\" + prefix + \"container {\\n      position: absolute;\\n      \" + verticalProperty + \": 10px;\\n      \" + horizontalProperty + \": 30px;\\n\\n      border-radius: 3px;\\n      background: #000;\\n      color: #fff;\\n      font: initial;\\n      cursor: initial;\\n      letter-spacing: initial;\\n      text-shadow: initial;\\n      text-transform: initial;\\n      visibility: initial;\\n\\n      padding: 7px 10px 8px 10px;\\n      align-items: center;\\n      box-shadow: 0 11px 40px 0 rgba(0, 0, 0, 0.25), 0 2px 10px 0 rgba(0, 0, 0, 0.12);\\n\\n      display: none;\\n      opacity: 0;\\n      transition: opacity 0.1s ease, \" + verticalProperty + \" 0.1s ease;\\n      animation: \" + prefix + \"fade-in 0.1s ease-in-out;\\n    }\\n\\n    #\" + prefix + \"container.\" + prefix + \"visible {\\n      display: flex;\\n    }\\n\\n    #\" + prefix + \"container.\" + prefix + \"building {\\n      \" + verticalProperty + \": 20px;\\n      opacity: 1;\\n    }\\n\\n    #\" + prefix + \"icon-wrapper {\\n      width: 16px;\\n      height: 16px;\\n    }\\n\\n    #\" + prefix + \"icon-wrapper > svg {\\n      width: 100%;\\n      height: 100%;\\n    }\\n\\n    #\" + prefix + \"icon-group {\\n      animation: \" + prefix + \"strokedash 1s ease-in-out both infinite;\\n    }\\n\\n    @keyframes \" + prefix + \"fade-in {\\n      from {\\n        \" + verticalProperty + \": 10px;\\n        opacity: 0;\\n      }\\n      to {\\n        \" + verticalProperty + \": 20px;\\n        opacity: 1;\\n      }\\n    }\\n\\n    @keyframes \" + prefix + \"strokedash {\\n      0% {\\n        stroke-dasharray: 0 226;\\n      }\\n      80%,\\n      100% {\\n        stroke-dasharray: 659 226;\\n      }\\n    }\\n  \";\n    return css;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=dev-build-watcher.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvZGV2LWJ1aWxkLXdhdGNoZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsMERBQTBELEdBQWdCO0FBQzFFQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsMkNBQTBDO0lBQ3RDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsYUFBYUMsbUJBQU9BLENBQUMsaUdBQTJCO0FBQ3RELFNBQVNGLHVCQUF1QkcsY0FBYyxFQUFFQyxRQUFRO0lBQ3BELElBQUlBLGFBQWEsS0FBSyxHQUFHQSxXQUFXO0lBQ3BDLE1BQU1DLGFBQWFDLFNBQVNDLGFBQWEsQ0FBQztJQUMxQyxNQUFNLENBQUNDLGtCQUFrQkMsbUJBQW1CLEdBQUdMLFNBQVNNLEtBQUssQ0FBQztJQUM5REwsV0FBV00sRUFBRSxHQUFHO0lBQ2hCLGdFQUFnRTtJQUNoRU4sV0FBV08sS0FBSyxDQUFDUixRQUFRLEdBQUc7SUFDNUIsNERBQTREO0lBQzVEQyxXQUFXTyxLQUFLLENBQUNKLGlCQUFpQixHQUFHO0lBQ3JDLDREQUE0RDtJQUM1REgsV0FBV08sS0FBSyxDQUFDSCxtQkFBbUIsR0FBRztJQUN2Q0osV0FBV08sS0FBSyxDQUFDQyxLQUFLLEdBQUc7SUFDekJSLFdBQVdPLEtBQUssQ0FBQ0UsTUFBTSxHQUFHO0lBQzFCVCxXQUFXTyxLQUFLLENBQUNHLE1BQU0sR0FBRztJQUMxQlQsU0FBU1UsSUFBSSxDQUFDQyxXQUFXLENBQUNaO0lBQzFCLElBQUlhO0lBQ0osSUFBSUMsU0FBUztJQUNiLElBQUlkLFdBQVdlLFlBQVksRUFBRTtRQUN6QkYsYUFBYWIsV0FBV2UsWUFBWSxDQUFDO1lBQ2pDQyxNQUFNO1FBQ1Y7SUFDSixPQUFPO1FBQ0gsaUVBQWlFO1FBQ2pFLDJEQUEyRDtRQUMzRCx1QkFBdUI7UUFDdkJILGFBQWFiO1FBQ2JjLFNBQVM7SUFDYjtJQUNBLFlB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LE9BQU8sRUFBRW5EO0lBQy9Cc0QsT0FBT3RELE9BQU8sR0FBR0EsUUFBUW1ELE9BQU87QUFDbEMsRUFFQSw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZGV2L2Rldi1idWlsZC13YXRjaGVyLmpzPzdiMzQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lICovIFwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVmYXVsdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaW5pdGlhbGl6ZUJ1aWxkV2F0Y2hlcjtcbiAgICB9XG59KTtcbmNvbnN0IF93ZWJzb2NrZXQgPSByZXF1aXJlKFwiLi9lcnJvci1vdmVybGF5L3dlYnNvY2tldFwiKTtcbmZ1bmN0aW9uIGluaXRpYWxpemVCdWlsZFdhdGNoZXIodG9nZ2xlQ2FsbGJhY2ssIHBvc2l0aW9uKSB7XG4gICAgaWYgKHBvc2l0aW9uID09PSB2b2lkIDApIHBvc2l0aW9uID0gXCJib3R0b20tcmlnaHRcIjtcbiAgICBjb25zdCBzaGFkb3dIb3N0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBjb25zdCBbdmVydGljYWxQcm9wZXJ0eSwgaG9yaXpvbnRhbFByb3BlcnR5XSA9IHBvc2l0aW9uLnNwbGl0KFwiLVwiKTtcbiAgICBzaGFkb3dIb3N0LmlkID0gXCJfX25leHQtYnVpbGQtd2F0Y2hlclwiO1xuICAgIC8vIE1ha2Ugc3VyZSBjb250YWluZXIgaXMgZml4ZWQgYW5kIG9uIGEgaGlnaCB6SW5kZXggc28gaXQgc2hvd3NcbiAgICBzaGFkb3dIb3N0LnN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuICAgIC8vIEVuc3VyZSBjb250YWluZXIncyBwb3NpdGlvbiB0byBiZSB0b3Agb3IgYm90dG9tIChkZWZhdWx0KVxuICAgIHNoYWRvd0hvc3Quc3R5bGVbdmVydGljYWxQcm9wZXJ0eV0gPSBcIjEwcHhcIjtcbiAgICAvLyBFbnN1cmUgY29udGFpbmVyJ3MgcG9zaXRpb24gdG8gYmUgbGVmdCBvciByaWdodCAoZGVmYXVsdClcbiAgICBzaGFkb3dIb3N0LnN0eWxlW2hvcml6b250YWxQcm9wZXJ0eV0gPSBcIjIwcHhcIjtcbiAgICBzaGFkb3dIb3N0LnN0eWxlLndpZHRoID0gXCIwXCI7XG4gICAgc2hhZG93SG9zdC5zdHlsZS5oZWlnaHQgPSBcIjBcIjtcbiAgICBzaGFkb3dIb3N0LnN0eWxlLnpJbmRleCA9IFwiOTk5OTlcIjtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNoYWRvd0hvc3QpO1xuICAgIGxldCBzaGFkb3dSb290O1xuICAgIGxldCBwcmVmaXggPSBcIlwiO1xuICAgIGlmIChzaGFkb3dIb3N0LmF0dGFjaFNoYWRvdykge1xuICAgICAgICBzaGFkb3dSb290ID0gc2hhZG93SG9zdC5hdHRhY2hTaGFkb3coe1xuICAgICAgICAgICAgbW9kZTogXCJvcGVuXCJcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgYXR0YWNoU2hhZG93IGlzIHVuZGVmaW5lZCB0aGVuIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnRcbiAgICAgICAgLy8gdGhlIFNoYWRvdyBET00sIHdlIG5lZWQgdG8gcHJlZml4IGFsbCB0aGUgbmFtZXMgc28gdGhlcmVcbiAgICAgICAgLy8gd2lsbCBiZSBubyBjb25mbGljdHNcbiAgICAgICAgc2hhZG93Um9vdCA9IHNoYWRvd0hvc3Q7XG4gICAgICAgIHByZWZpeCA9IFwiX19uZXh0LWJ1aWxkLXdhdGNoZXItXCI7XG4gICAgfVxuICAgIC8vIENvbnRhaW5lclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGNyZWF0ZUNvbnRhaW5lcihwcmVmaXgpO1xuICAgIHNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAvLyBDU1NcbiAgICBjb25zdCBjc3MgPSBjcmVhdGVDc3MocHJlZml4LCB7XG4gICAgICAgIGhvcml6b250YWxQcm9wZXJ0eSxcbiAgICAgICAgdmVydGljYWxQcm9wZXJ0eVxuICAgIH0pO1xuICAgIHNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoY3NzKTtcbiAgICAvLyBTdGF0ZVxuICAgIGxldCBpc1Zpc2libGUgPSBmYWxzZTtcbiAgICBsZXQgaXNCdWlsZGluZyA9IGZhbHNlO1xuICAgIGxldCB0aW1lb3V0SWQgPSBudWxsO1xuICAgIC8vIEhhbmRsZSBldmVudHNcbiAgICAoMCwgX3dlYnNvY2tldC5hZGRNZXNzYWdlTGlzdGVuZXIpKChldmVudCk9PntcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgaGVhcnRiZWF0IGV2ZW50XG4gICAgICAgIGlmIChldmVudC5kYXRhID09PSBcIlxcdUQ4M0RcXHVEQzkzXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaGFuZGxlTWVzc2FnZShldmVudCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShldmVudCkge1xuICAgICAgICBjb25zdCBvYmogPSB0eXBlb2YgZXZlbnQgPT09IFwic3RyaW5nXCIgPyB7XG4gICAgICAgICAgICBhY3Rpb246IGV2ZW50XG4gICAgICAgIH0gOiBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVmYXVsdC1jYXNlXG4gICAgICAgIHN3aXRjaChvYmouYWN0aW9uKXtcbiAgICAgICAgICAgIGNhc2UgXCJidWlsZGluZ1wiOlxuICAgICAgICAgICAgICAgIHRpbWVvdXRJZCAmJiBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgICAgICBpc1Zpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlzQnVpbGRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUNvbnRhaW5lcigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImJ1aWx0XCI6XG4gICAgICAgICAgICBjYXNlIFwic3luY1wiOlxuICAgICAgICAgICAgICAgIGlzQnVpbGRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgZmFkZSBvdXQgdHJhbnNpdGlvbiB0byBjb21wbGV0ZVxuICAgICAgICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgaXNWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNvbnRhaW5lcigpO1xuICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlQ29udGFpbmVyKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9nZ2xlQ2FsbGJhY2soaGFuZGxlTWVzc2FnZSk7XG4gICAgZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyKCkge1xuICAgICAgICBpZiAoaXNCdWlsZGluZykge1xuICAgICAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJcIiArIHByZWZpeCArIFwiYnVpbGRpbmdcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShcIlwiICsgcHJlZml4ICsgXCJidWlsZGluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZChcIlwiICsgcHJlZml4ICsgXCJ2aXNpYmxlXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoXCJcIiArIHByZWZpeCArIFwidmlzaWJsZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRhaW5lcihwcmVmaXgpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGNvbnRhaW5lci5pZCA9IFwiXCIgKyBwcmVmaXggKyBcImNvbnRhaW5lclwiO1xuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSAnXFxuICAgIDxkaXYgaWQ9XCInICsgcHJlZml4ICsgJ2ljb24td3JhcHBlclwiPlxcbiAgICAgIDxzdmcgdmlld0JveD1cIjAgMCAyMjYgMjAwXCI+XFxuICAgICAgICA8ZGVmcz5cXG4gICAgICAgICAgPGxpbmVhckdyYWRpZW50XFxuICAgICAgICAgICAgeDE9XCIxMTQuNzIwNzc1JVwiXFxuICAgICAgICAgICAgeTE9XCIxODEuMjgzMjQ1JVwiXFxuICAgICAgICAgICAgeDI9XCIzOS41Mzk5MzA2JVwiXFxuICAgICAgICAgICAgeTI9XCIxMDAlXCJcXG4gICAgICAgICAgICBpZD1cIicgKyBwcmVmaXggKyAnbGluZWFyLWdyYWRpZW50XCJcXG4gICAgICAgICAgPlxcbiAgICAgICAgICAgIDxzdG9wIHN0b3AtY29sb3I9XCIjMDAwMDAwXCIgb2Zmc2V0PVwiMCVcIiAvPlxcbiAgICAgICAgICAgIDxzdG9wIHN0b3AtY29sb3I9XCIjRkZGRkZGXCIgb2Zmc2V0PVwiMTAwJVwiIC8+XFxuICAgICAgICAgIDwvbGluZWFyR3JhZGllbnQ+XFxuICAgICAgICA8L2RlZnM+XFxuICAgICAgICA8ZyBpZD1cIicgKyBwcmVmaXggKyAnaWNvbi1ncm91cFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwidXJsKCMnICsgcHJlZml4ICsgJ2xpbmVhci1ncmFkaWVudClcIiBzdHJva2Utd2lkdGg9XCIxOFwiPlxcbiAgICAgICAgICA8cGF0aCBkPVwiTTExMyw1LjA4MjE5MTE3IEw0LjI4MzkzODAxLDE5Ny41IEwyMjEuNzE2MDYyLDE5Ny41IEwxMTMsNS4wODIxOTExNyBaXCIgLz5cXG4gICAgICAgIDwvZz5cXG4gICAgICA8L3N2Zz5cXG4gICAgPC9kaXY+XFxuICAnO1xuICAgIHJldHVybiBjb250YWluZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVDc3MocHJlZml4LCBwYXJhbSkge1xuICAgIGxldCB7IGhvcml6b250YWxQcm9wZXJ0eSAsIHZlcnRpY2FsUHJvcGVydHkgIH0gPSBwYXJhbTtcbiAgICBjb25zdCBjc3MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgY3NzLnRleHRDb250ZW50ID0gXCJcXG4gICAgI1wiICsgcHJlZml4ICsgXCJjb250YWluZXIge1xcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICBcIiArIHZlcnRpY2FsUHJvcGVydHkgKyBcIjogMTBweDtcXG4gICAgICBcIiArIGhvcml6b250YWxQcm9wZXJ0eSArIFwiOiAzMHB4O1xcblxcbiAgICAgIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gICAgICBiYWNrZ3JvdW5kOiAjMDAwO1xcbiAgICAgIGNvbG9yOiAjZmZmO1xcbiAgICAgIGZvbnQ6IGluaXRpYWw7XFxuICAgICAgY3Vyc29yOiBpbml0aWFsO1xcbiAgICAgIGxldHRlci1zcGFjaW5nOiBpbml0aWFsO1xcbiAgICAgIHRleHQtc2hhZG93OiBpbml0aWFsO1xcbiAgICAgIHRleHQtdHJhbnNmb3JtOiBpbml0aWFsO1xcbiAgICAgIHZpc2liaWxpdHk6IGluaXRpYWw7XFxuXFxuICAgICAgcGFkZGluZzogN3B4IDEwcHggOHB4IDEwcHg7XFxuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgICBib3gtc2hhZG93OiAwIDExcHggNDBweCAwIHJnYmEoMCwgMCwgMCwgMC4yNSksIDAgMnB4IDEwcHggMCByZ2JhKDAsIDAsIDAsIDAuMTIpO1xcblxcbiAgICAgIGRpc3BsYXk6IG5vbmU7XFxuICAgICAgb3BhY2l0eTogMDtcXG4gICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMXMgZWFzZSwgXCIgKyB2ZXJ0aWNhbFByb3BlcnR5ICsgXCIgMC4xcyBlYXNlO1xcbiAgICAgIGFuaW1hdGlvbjogXCIgKyBwcmVmaXggKyBcImZhZGUtaW4gMC4xcyBlYXNlLWluLW91dDtcXG4gICAgfVxcblxcbiAgICAjXCIgKyBwcmVmaXggKyBcImNvbnRhaW5lci5cIiArIHByZWZpeCArIFwidmlzaWJsZSB7XFxuICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgfVxcblxcbiAgICAjXCIgKyBwcmVmaXggKyBcImNvbnRhaW5lci5cIiArIHByZWZpeCArIFwiYnVpbGRpbmcge1xcbiAgICAgIFwiICsgdmVydGljYWxQcm9wZXJ0eSArIFwiOiAyMHB4O1xcbiAgICAgIG9wYWNpdHk6IDE7XFxuICAgIH1cXG5cXG4gICAgI1wiICsgcHJlZml4ICsgXCJpY29uLXdyYXBwZXIge1xcbiAgICAgIHdpZHRoOiAxNnB4O1xcbiAgICAgIGhlaWdodDogMTZweDtcXG4gICAgfVxcblxcbiAgICAjXCIgKyBwcmVmaXggKyBcImljb24td3JhcHBlciA+IHN2ZyB7XFxuICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB9XFxuXFxuICAgICNcIiArIHByZWZpeCArIFwiaWNvbi1ncm91cCB7XFxuICAgICAgYW5pbWF0aW9uOiBcIiArIHByZWZpeCArIFwic3Ryb2tlZGFzaCAxcyBlYXNlLWluLW91dCBib3RoIGluZmluaXRlO1xcbiAgICB9XFxuXFxuICAgIEBrZXlmcmFtZXMgXCIgKyBwcmVmaXggKyBcImZhZGUtaW4ge1xcbiAgICAgIGZyb20ge1xcbiAgICAgICAgXCIgKyB2ZXJ0aWNhbFByb3BlcnR5ICsgXCI6IDEwcHg7XFxuICAgICAgICBvcGFjaXR5OiAwO1xcbiAgICAgIH1cXG4gICAgICB0byB7XFxuICAgICAgICBcIiArIHZlcnRpY2FsUHJvcGVydHkgKyBcIjogMjBweDtcXG4gICAgICAgIG9wYWNpdHk6IDE7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIEBrZXlmcmFtZXMgXCIgKyBwcmVmaXggKyBcInN0cm9rZWRhc2gge1xcbiAgICAgIDAlIHtcXG4gICAgICAgIHN0cm9rZS1kYXNoYXJyYXk6IDAgMjI2O1xcbiAgICAgIH1cXG4gICAgICA4MCUsXFxuICAgICAgMTAwJSB7XFxuICAgICAgICBzdHJva2UtZGFzaGFycmF5OiA2NTkgMjI2O1xcbiAgICAgIH1cXG4gICAgfVxcbiAgXCI7XG4gICAgcmV0dXJuIGNzcztcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV2LWJ1aWxkLXdhdGNoZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImluaXRpYWxpemVCdWlsZFdhdGNoZXIiLCJfd2Vic29ja2V0IiwicmVxdWlyZSIsInRvZ2dsZUNhbGxiYWNrIiwicG9zaXRpb24iLCJzaGFkb3dIb3N0IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwidmVydGljYWxQcm9wZXJ0eSIsImhvcml6b250YWxQcm9wZXJ0eSIsInNwbGl0IiwiaWQiLCJzdHlsZSIsIndpZHRoIiwiaGVpZ2h0IiwiekluZGV4IiwiYm9keSIsImFwcGVuZENoaWxkIiwic2hhZG93Um9vdCIsInByZWZpeCIsImF0dGFjaFNoYWRvdyIsIm1vZGUiLCJjb250YWluZXIiLCJjcmVhdGVDb250YWluZXIiLCJjc3MiLCJjcmVhdGVDc3MiLCJpc1Zpc2libGUiLCJpc0J1aWxkaW5nIiwidGltZW91dElkIiwiYWRkTWVzc2FnZUxpc3RlbmVyIiwiZXZlbnQiLCJkYXRhIiwiaGFuZGxlTWVzc2FnZSIsImUiLCJvYmoiLCJhY3Rpb24iLCJKU09OIiwicGFyc2UiLCJjbGVhclRpbWVvdXQiLCJ1cGRhdGVDb250YWluZXIiLCJzZXRUaW1lb3V0IiwiY2xhc3NMaXN0IiwiYWRkIiwicmVtb3ZlIiwiaW5uZXJIVE1MIiwicGFyYW0iLCJ0ZXh0Q29udGVudCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/dev/dev-build-watcher.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/dev/error-overlay/hot-dev-client.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/error-overlay/hot-dev-client.js ***!
  \***************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// TODO: Remove use of `any` type. Fix no-use-before-define violations.\n/* eslint-disable @typescript-eslint/no-use-before-define */ /**\n * MIT License\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */ // This file is a modified version of the Create React App HMR dev client that\n// can be found here:\n// https://github.com/facebook/create-react-app/blob/v3.4.1/packages/react-dev-utils/webpackHotDevClient.js\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return connect;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _client = __webpack_require__(/*! next/dist/compiled/@next/react-dev-overlay/dist/client */ \"./node_modules/next/dist/compiled/@next/react-dev-overlay/dist/client.js\");\nconst _stripansi = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/compiled/strip-ansi */ \"./node_modules/next/dist/compiled/strip-ansi/index.js\"));\nconst _websocket = __webpack_require__(/*! ./websocket */ \"./node_modules/next/dist/client/dev/error-overlay/websocket.js\");\nconst _formatwebpackmessages = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./format-webpack-messages */ \"./node_modules/next/dist/client/dev/error-overlay/format-webpack-messages.js\"));\nwindow.__nextDevClientId = Math.round(Math.random() * 100 + Date.now());\nlet hadRuntimeError = false;\nlet customHmrEventHandler;\nfunction connect() {\n    (0, _client.register)();\n    (0, _websocket.addMessageListener)((event)=>{\n        try {\n            const payload = JSON.parse(event.data);\n            if (!(\"action\" in payload)) return;\n            processMessage(payload);\n        } catch (err) {\n            var _err_stack;\n            console.warn(\"[HMR] Invalid message: \" + event.data + \"\\n\" + ((_err_stack = err == null ? void 0 : err.stack) != null ? _err_stack : \"\"));\n        }\n    });\n    return {\n        subscribeToHmrEvent (handler) {\n            customHmrEventHandler = handler;\n        },\n        onUnrecoverableError () {\n            hadRuntimeError = true;\n        }\n    };\n}\n// Remember some state related to hot module replacement.\nvar isFirstCompilation = true;\nvar mostRecentCompilationHash = null;\nvar hasCompileErrors = false;\nfunction clearOutdatedErrors() {\n    // Clean up outdated compile errors, if any.\n    if (typeof console !== \"undefined\" && typeof console.clear === \"function\") {\n        if (hasCompileErrors) {\n            console.clear();\n        }\n    }\n}\n// Successful compilation.\nfunction handleSuccess() {\n    clearOutdatedErrors();\n    const isHotUpdate = !isFirstCompilation || window.__NEXT_DATA__.page !== \"/_error\" && isUpdateAvailable();\n    isFirstCompilation = false;\n    hasCompileErrors = false;\n    // Attempt to apply hot updates or reload.\n    if (isHotUpdate) {\n        tryApplyUpdates(onBeforeFastRefresh, onFastRefresh);\n    }\n}\n// Compilation with warnings (e.g. ESLint).\nfunction handleWarnings(warnings) {\n    clearOutdatedErrors();\n    const isHotUpdate = !isFirstCompilation;\n    isFirstCompilation = false;\n    hasCompileErrors = false;\n    function printWarnings() {\n        // Print warnings to the console.\n        const formatted = (0, _formatwebpackmessages.default)({\n            warnings: warnings,\n            errors: []\n        });\n        if (typeof console !== \"undefined\" && typeof console.warn === \"function\") {\n            var _formatted_warnings;\n            for(let i = 0; i < ((_formatted_warnings = formatted.warnings) == null ? void 0 : _formatted_warnings.length); i++){\n                if (i === 5) {\n                    console.warn(\"There were more warnings in other files.\\n\" + \"You can find a complete log in the terminal.\");\n                    break;\n                }\n                console.warn((0, _stripansi.default)(formatted.warnings[i]));\n            }\n        }\n    }\n    printWarnings();\n    // Attempt to apply hot updates or reload.\n    if (isHotUpdate) {\n        tryApplyUpdates(onBeforeFastRefresh, onFastRefresh);\n    }\n}\n// Compilation with errors (e.g. syntax error or missing modules).\nfunction handleErrors(errors) {\n    clearOutdatedErrors();\n    isFirstCompilation = false;\n    hasCompileErrors = true;\n    // \"Massage\" webpack messages.\n    var formatted = (0, _formatwebpackmessages.default)({\n        errors: errors,\n        warnings: []\n    });\n    // Only show the first error.\n    (0, _client.onBuildError)(formatted.errors[0]);\n    // Also log them to the console.\n    if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        for(var i = 0; i < formatted.errors.length; i++){\n            console.error((0, _stripansi.default)(formatted.errors[i]));\n        }\n    }\n    // Do not attempt to reload now.\n    // We will reload on next success instead.\n    if (false) {}\n}\nlet startLatency = undefined;\nfunction onBeforeFastRefresh(updatedModules) {\n    if (updatedModules.length > 0) {\n        // Only trigger a pending state if we have updates to apply\n        // (cf. onFastRefresh)\n        (0, _client.onBeforeRefresh)();\n    }\n}\nfunction onFastRefresh(updatedModules) {\n    (0, _client.onBuildOk)();\n    if (updatedModules.length > 0) {\n        // Only complete a pending state if we applied updates\n        // (cf. onBeforeFastRefresh)\n        (0, _client.onRefresh)();\n    }\n    if (startLatency) {\n        const endLatency = Date.now();\n        const latency = endLatency - startLatency;\n        console.log(\"[Fast Refresh] done in \" + latency + \"ms\");\n        (0, _websocket.sendMessage)(JSON.stringify({\n            event: \"client-hmr-latency\",\n            id: window.__nextDevClientId,\n            startTime: startLatency,\n            endTime: endLatency,\n            page: window.location.pathname,\n            updatedModules\n        }));\n        if (self.__NEXT_HMR_LATENCY_CB) {\n            self.__NEXT_HMR_LATENCY_CB(latency);\n        }\n    }\n}\n// There is a newer version of the code available.\nfunction handleAvailableHash(hash) {\n    // Update last known compilation hash.\n    mostRecentCompilationHash = hash;\n}\n// Handle messages from the server.\nfunction processMessage(obj) {\n    switch(obj.action){\n        case \"building\":\n            {\n                startLatency = Date.now();\n                console.log(\"[Fast Refresh] rebuilding\");\n                break;\n            }\n        case \"built\":\n        case \"sync\":\n            {\n                if (obj.hash) {\n                    handleAvailableHash(obj.hash);\n                }\n                const { errors, warnings } = obj;\n                const hasErrors = Boolean(errors && errors.length);\n                if (hasErrors) {\n                    (0, _websocket.sendMessage)(JSON.stringify({\n                        event: \"client-error\",\n                        errorCount: errors.length,\n                        clientId: window.__nextDevClientId\n                    }));\n                    return handleErrors(errors);\n                }\n                const hasWarnings = Boolean(warnings && warnings.length);\n                if (hasWarnings) {\n                    (0, _websocket.sendMessage)(JSON.stringify({\n                        event: \"client-warning\",\n                        warningCount: warnings.length,\n                        clientId: window.__nextDevClientId\n                    }));\n                    return handleWarnings(warnings);\n                }\n                (0, _websocket.sendMessage)(JSON.stringify({\n                    event: \"client-success\",\n                    clientId: window.__nextDevClientId\n                }));\n                return handleSuccess();\n            }\n        case \"serverComponentChanges\":\n            {\n                window.location.reload();\n                return;\n            }\n        case \"serverError\":\n            {\n                const { errorJSON } = obj;\n                if (errorJSON) {\n                    const { message, stack } = JSON.parse(errorJSON);\n                    const error = new Error(message);\n                    error.stack = stack;\n                    handleErrors([\n                        error\n                    ]);\n                }\n                return;\n            }\n        default:\n            {\n                if (customHmrEventHandler) {\n                    customHmrEventHandler(obj);\n                    break;\n                }\n                break;\n            }\n    }\n}\n// Is there a newer version of this code available?\nfunction isUpdateAvailable() {\n    /* globals __webpack_hash__ */ // __webpack_hash__ is the hash of the current compilation.\n    // It's a global variable injected by Webpack.\n    return mostRecentCompilationHash !== __webpack_require__.h();\n}\n// Webpack disallows updates in other states.\nfunction canApplyUpdates() {\n    // @ts-expect-error TODO: module.hot exists but type needs to be added. Can't use `as any` here as webpack parses for `module.hot` calls.\n    return module.hot.status() === \"idle\";\n}\nfunction afterApplyUpdates(fn) {\n    if (canApplyUpdates()) {\n        fn();\n    } else {\n        function handler(status) {\n            if (status === \"idle\") {\n                // @ts-expect-error TODO: module.hot exists but type needs to be added. Can't use `as any` here as webpack parses for `module.hot` calls.\n                module.hot.removeStatusHandler(handler);\n                fn();\n            }\n        }\n        // @ts-expect-error TODO: module.hot exists but type needs to be added. Can't use `as any` here as webpack parses for `module.hot` calls.\n        module.hot.addStatusHandler(handler);\n    }\n}\n// Attempt to update code on the fly, fall back to a hard reload.\nfunction tryApplyUpdates(onBeforeHotUpdate, onHotUpdateSuccess) {\n    // @ts-expect-error TODO: module.hot exists but type needs to be added. Can't use `as any` here as webpack parses for `module.hot` calls.\n    if (false) {}\n    if (!isUpdateAvailable() || !canApplyUpdates()) {\n        (0, _client.onBuildOk)();\n        return;\n    }\n    function handleApplyUpdates(err, updatedModules) {\n        if (err || hadRuntimeError || !updatedModules) {\n            if (err) {\n                console.warn(\"[Fast Refresh] performing full reload\\n\\n\" + \"Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.\\n\" + \"You might have a file which exports a React component but also exports a value that is imported by a non-React component file.\\n\" + \"Consider migrating the non-React component export to a separate file and importing it into both files.\\n\\n\" + \"It is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.\\n\" + \"Fast Refresh requires at least one parent function component in your React tree.\");\n            } else if (hadRuntimeError) {\n                console.warn(\"[Fast Refresh] performing full reload because your application had an unrecoverable error\");\n            }\n            performFullReload(err);\n            return;\n        }\n        if (typeof onHotUpdateSuccess === \"function\") {\n            // Maybe we want to do something.\n            onHotUpdateSuccess(updatedModules);\n        }\n        if (isUpdateAvailable()) {\n            // While we were updating, there was a new update! Do it again.\n            // However, this time, don't trigger a pending refresh state.\n            tryApplyUpdates(updatedModules.length > 0 ? undefined : onBeforeHotUpdate, updatedModules.length > 0 ? _client.onBuildOk : onHotUpdateSuccess);\n        } else {\n            (0, _client.onBuildOk)();\n            if (false) {}\n        }\n    }\n    // https://webpack.js.org/api/hot-module-replacement/#check\n    // @ts-expect-error TODO: module.hot exists but type needs to be added. Can't use `as any` here as webpack parses for `module.hot` calls.\n    module.hot.check(/* autoApply */ false).then((updatedModules)=>{\n        if (!updatedModules) {\n            return null;\n        }\n        if (typeof onBeforeHotUpdate === \"function\") {\n            onBeforeHotUpdate(updatedModules);\n        }\n        // @ts-expect-error TODO: module.hot exists but type needs to be added. Can't use `as any` here as webpack parses for `module.hot` calls.\n        return module.hot.apply();\n    }).then((updatedModules)=>{\n        handleApplyUpdates(null, updatedModules);\n    }, (err)=>{\n        handleApplyUpdates(err, null);\n    });\n}\nfunction performFullReload(err) {\n    const stackTrace = err && (err.stack && err.stack.split(\"\\n\").slice(0, 5).join(\"\\n\") || err.message || err + \"\");\n    (0, _websocket.sendMessage)(JSON.stringify({\n        event: \"client-full-reload\",\n        stackTrace,\n        hadRuntimeError: !!hadRuntimeError\n    }));\n    window.location.reload();\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=hot-dev-client.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvZXJyb3Itb3ZlcmxheS9ob3QtZGV2LWNsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx1RUFBdUU7QUFDdkUsMERBQTBELEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzQjVELEdBQUcsOEVBQThFO0FBQ2xGLHFCQUFxQjtBQUNyQiwyR0FBMkc7QUFDOUY7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILDJDQUEwQztJQUN0Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLDJCQUEyQkMsbUJBQU9BLENBQUMsNEdBQXlDO0FBQ2xGLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLHdJQUF3RDtBQUNoRixNQUFNRSxhQUFhLFdBQVcsR0FBR0gseUJBQXlCSSxDQUFDLENBQUNILG1CQUFPQSxDQUFDLDRGQUErQjtBQUNuRyxNQUFNSSxhQUFhSixtQkFBT0EsQ0FBQyxtRkFBYTtBQUN4QyxNQUFNSyx5QkFBeUIsV0FBVyxHQUFHTix5QkFBeUJJLENBQUMsQ0FBQ0gsbUJBQU9BLENBQUMsK0dBQTJCO0FBQzNHTSxPQUFPQyxpQkFBaUIsR0FBR0MsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQUssTUFBTUMsS0FBS0MsR0FBRztBQUNwRSxJQUFJQyxrQkFBa0I7QUFDdEIsSUFBSUM7QUFDSixTQUFTaEI7SUFDSixJQUFHRyxRQUFRYyxRQUFRO0lBQ25CLElBQUdYLFdBQVdZLGtCQUFrQixFQUFFLENBQUNDO1FBQ2hDLElBQUk7WUFDQSxNQUFNQyxVQUFVQyxLQUFLQyxLQUFLLENBQUNILE1BQU1JLElBQUk7WUFDckMsSUFBSSxDQUFFLGFBQVlILE9BQU0sR0FBSTtZQUM1QkksZUFBZUo7UUFDbkIsRUFBRSxPQUFPSyxLQUFLO1lBQ1YsSUFBSUM7WUFDSkMsUUFBUUMsSUFBSSxDQUFDLDRCQUE0QlQsTUFB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QUFhO0lBQ3JLeEgsT0FBT0MsY0FBYyxDQUFDQyxRQUFRc0QsT0FBTyxFQUFFLGNBQWM7UUFBRXJELE9BQU87SUFBSztJQUNuRUgsT0FBT3lILE1BQU0sQ0FBQ3ZILFFBQVFzRCxPQUFPLEVBQUV0RDtJQUMvQm9HLE9BQU9wRyxPQUFPLEdBQUdBLFFBQVFzRCxPQUFPO0FBQ2xDLEVBRUEsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2Rldi9lcnJvci1vdmVybGF5L2hvdC1kZXYtY2xpZW50LmpzPzE2MDAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVE9ETzogUmVtb3ZlIHVzZSBvZiBgYW55YCB0eXBlLiBGaXggbm8tdXNlLWJlZm9yZS1kZWZpbmUgdmlvbGF0aW9ucy5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZSAqLyAvKipcbiAqIE1JVCBMaWNlbnNlXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqLyAvLyBUaGlzIGZpbGUgaXMgYSBtb2RpZmllZCB2ZXJzaW9uIG9mIHRoZSBDcmVhdGUgUmVhY3QgQXBwIEhNUiBkZXYgY2xpZW50IHRoYXRcbi8vIGNhbiBiZSBmb3VuZCBoZXJlOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2NyZWF0ZS1yZWFjdC1hcHAvYmxvYi92My40LjEvcGFja2FnZXMvcmVhY3QtZGV2LXV0aWxzL3dlYnBhY2tIb3REZXZDbGllbnQuanNcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVmYXVsdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY29ubmVjdDtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHRcIik7XG5jb25zdCBfY2xpZW50ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9kaXN0L2NsaWVudFwiKTtcbmNvbnN0IF9zdHJpcGFuc2kgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvc3RyaXAtYW5zaVwiKSk7XG5jb25zdCBfd2Vic29ja2V0ID0gcmVxdWlyZShcIi4vd2Vic29ja2V0XCIpO1xuY29uc3QgX2Zvcm1hdHdlYnBhY2ttZXNzYWdlcyA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4vZm9ybWF0LXdlYnBhY2stbWVzc2FnZXNcIikpO1xud2luZG93Ll9fbmV4dERldkNsaWVudElkID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMTAwICsgRGF0ZS5ub3coKSk7XG5sZXQgaGFkUnVudGltZUVycm9yID0gZmFsc2U7XG5sZXQgY3VzdG9tSG1yRXZlbnRIYW5kbGVyO1xuZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICAoMCwgX2NsaWVudC5yZWdpc3RlcikoKTtcbiAgICAoMCwgX3dlYnNvY2tldC5hZGRNZXNzYWdlTGlzdGVuZXIpKChldmVudCk9PntcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgaWYgKCEoXCJhY3Rpb25cIiBpbiBwYXlsb2FkKSkgcmV0dXJuO1xuICAgICAgICAgICAgcHJvY2Vzc01lc3NhZ2UocGF5bG9hZCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdmFyIF9lcnJfc3RhY2s7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbSE1SXSBJbnZhbGlkIG1lc3NhZ2U6IFwiICsgZXZlbnQuZGF0YSArIFwiXFxuXCIgKyAoKF9lcnJfc3RhY2sgPSBlcnIgPT0gbnVsbCA/IHZvaWQgMCA6IGVyci5zdGFjaykgIT0gbnVsbCA/IF9lcnJfc3RhY2sgOiBcIlwiKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzY3JpYmVUb0htckV2ZW50IChoYW5kbGVyKSB7XG4gICAgICAgICAgICBjdXN0b21IbXJFdmVudEhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICB9LFxuICAgICAgICBvblVucmVjb3ZlcmFibGVFcnJvciAoKSB7XG4gICAgICAgICAgICBoYWRSdW50aW1lRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8vIFJlbWVtYmVyIHNvbWUgc3RhdGUgcmVsYXRlZCB0byBob3QgbW9kdWxlIHJlcGxhY2VtZW50LlxudmFyIGlzRmlyc3RDb21waWxhdGlvbiA9IHRydWU7XG52YXIgbW9zdFJlY2VudENvbXBpbGF0aW9uSGFzaCA9IG51bGw7XG52YXIgaGFzQ29tcGlsZUVycm9ycyA9IGZhbHNlO1xuZnVuY3Rpb24gY2xlYXJPdXRkYXRlZEVycm9ycygpIHtcbiAgICAvLyBDbGVhbiB1cCBvdXRkYXRlZCBjb21waWxlIGVycm9ycywgaWYgYW55LlxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29uc29sZS5jbGVhciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmIChoYXNDb21waWxlRXJyb3JzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBTdWNjZXNzZnVsIGNvbXBpbGF0aW9uLlxuZnVuY3Rpb24gaGFuZGxlU3VjY2VzcygpIHtcbiAgICBjbGVhck91dGRhdGVkRXJyb3JzKCk7XG4gICAgY29uc3QgaXNIb3RVcGRhdGUgPSAhaXNGaXJzdENvbXBpbGF0aW9uIHx8IHdpbmRvdy5fX05FWFRfREFUQV9fLnBhZ2UgIT09IFwiL19lcnJvclwiICYmIGlzVXBkYXRlQXZhaWxhYmxlKCk7XG4gICAgaXNGaXJzdENvbXBpbGF0aW9uID0gZmFsc2U7XG4gICAgaGFzQ29tcGlsZUVycm9ycyA9IGZhbHNlO1xuICAgIC8vIEF0dGVtcHQgdG8gYXBwbHkgaG90IHVwZGF0ZXMgb3IgcmVsb2FkLlxuICAgIGlmIChpc0hvdFVwZGF0ZSkge1xuICAgICAgICB0cnlBcHBseVVwZGF0ZXMob25CZWZvcmVGYXN0UmVmcmVzaCwgb25GYXN0UmVmcmVzaCk7XG4gICAgfVxufVxuLy8gQ29tcGlsYXRpb24gd2l0aCB3YXJuaW5ncyAoZS5nLiBFU0xpbnQpLlxuZnVuY3Rpb24gaGFuZGxlV2FybmluZ3Mod2FybmluZ3MpIHtcbiAgICBjbGVhck91dGRhdGVkRXJyb3JzKCk7XG4gICAgY29uc3QgaXNIb3RVcGRhdGUgPSAhaXNGaXJzdENvbXBpbGF0aW9uO1xuICAgIGlzRmlyc3RDb21waWxhdGlvbiA9IGZhbHNlO1xuICAgIGhhc0NvbXBpbGVFcnJvcnMgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBwcmludFdhcm5pbmdzKCkge1xuICAgICAgICAvLyBQcmludCB3YXJuaW5ncyB0byB0aGUgY29uc29sZS5cbiAgICAgICAgY29uc3QgZm9ybWF0dGVkID0gKDAsIF9mb3JtYXR3ZWJwYWNrbWVzc2FnZXMuZGVmYXVsdCkoe1xuICAgICAgICAgICAgd2FybmluZ3M6IHdhcm5pbmdzLFxuICAgICAgICAgICAgZXJyb3JzOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBjb25zb2xlLndhcm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFyIF9mb3JtYXR0ZWRfd2FybmluZ3M7XG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgKChfZm9ybWF0dGVkX3dhcm5pbmdzID0gZm9ybWF0dGVkLndhcm5pbmdzKSA9PSBudWxsID8gdm9pZCAwIDogX2Zvcm1hdHRlZF93YXJuaW5ncy5sZW5ndGgpOyBpKyspe1xuICAgICAgICAgICAgICAgIGlmIChpID09PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRoZXJlIHdlcmUgbW9yZSB3YXJuaW5ncyBpbiBvdGhlciBmaWxlcy5cXG5cIiArIFwiWW91IGNhbiBmaW5kIGEgY29tcGxldGUgbG9nIGluIHRoZSB0ZXJtaW5hbC5cIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oKDAsIF9zdHJpcGFuc2kuZGVmYXVsdCkoZm9ybWF0dGVkLndhcm5pbmdzW2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJpbnRXYXJuaW5ncygpO1xuICAgIC8vIEF0dGVtcHQgdG8gYXBwbHkgaG90IHVwZGF0ZXMgb3IgcmVsb2FkLlxuICAgIGlmIChpc0hvdFVwZGF0ZSkge1xuICAgICAgICB0cnlBcHBseVVwZGF0ZXMob25CZWZvcmVGYXN0UmVmcmVzaCwgb25GYXN0UmVmcmVzaCk7XG4gICAgfVxufVxuLy8gQ29tcGlsYXRpb24gd2l0aCBlcnJvcnMgKGUuZy4gc3ludGF4IGVycm9yIG9yIG1pc3NpbmcgbW9kdWxlcykuXG5mdW5jdGlvbiBoYW5kbGVFcnJvcnMoZXJyb3JzKSB7XG4gICAgY2xlYXJPdXRkYXRlZEVycm9ycygpO1xuICAgIGlzRmlyc3RDb21waWxhdGlvbiA9IGZhbHNlO1xuICAgIGhhc0NvbXBpbGVFcnJvcnMgPSB0cnVlO1xuICAgIC8vIFwiTWFzc2FnZVwiIHdlYnBhY2sgbWVzc2FnZXMuXG4gICAgdmFyIGZvcm1hdHRlZCA9ICgwLCBfZm9ybWF0d2VicGFja21lc3NhZ2VzLmRlZmF1bHQpKHtcbiAgICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICAgIHdhcm5pbmdzOiBbXVxuICAgIH0pO1xuICAgIC8vIE9ubHkgc2hvdyB0aGUgZmlyc3QgZXJyb3IuXG4gICAgKDAsIF9jbGllbnQub25CdWlsZEVycm9yKShmb3JtYXR0ZWQuZXJyb3JzWzBdKTtcbiAgICAvLyBBbHNvIGxvZyB0aGVtIHRvIHRoZSBjb25zb2xlLlxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBmb3JtYXR0ZWQuZXJyb3JzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoKDAsIF9zdHJpcGFuc2kuZGVmYXVsdCkoZm9ybWF0dGVkLmVycm9yc1tpXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIERvIG5vdCBhdHRlbXB0IHRvIHJlbG9hZCBub3cuXG4gICAgLy8gV2Ugd2lsbCByZWxvYWQgb24gbmV4dCBzdWNjZXNzIGluc3RlYWQuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9URVNUX01PREUpIHtcbiAgICAgICAgaWYgKHNlbGYuX19ORVhUX0hNUl9DQikge1xuICAgICAgICAgICAgc2VsZi5fX05FWFRfSE1SX0NCKGZvcm1hdHRlZC5lcnJvcnNbMF0pO1xuICAgICAgICAgICAgc2VsZi5fX05FWFRfSE1SX0NCID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmxldCBzdGFydExhdGVuY3kgPSB1bmRlZmluZWQ7XG5mdW5jdGlvbiBvbkJlZm9yZUZhc3RSZWZyZXNoKHVwZGF0ZWRNb2R1bGVzKSB7XG4gICAgaWYgKHVwZGF0ZWRNb2R1bGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gT25seSB0cmlnZ2VyIGEgcGVuZGluZyBzdGF0ZSBpZiB3ZSBoYXZlIHVwZGF0ZXMgdG8gYXBwbHlcbiAgICAgICAgLy8gKGNmLiBvbkZhc3RSZWZyZXNoKVxuICAgICAgICAoMCwgX2NsaWVudC5vbkJlZm9yZVJlZnJlc2gpKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gb25GYXN0UmVmcmVzaCh1cGRhdGVkTW9kdWxlcykge1xuICAgICgwLCBfY2xpZW50Lm9uQnVpbGRPaykoKTtcbiAgICBpZiAodXBkYXRlZE1vZHVsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBPbmx5IGNvbXBsZXRlIGEgcGVuZGluZyBzdGF0ZSBpZiB3ZSBhcHBsaWVkIHVwZGF0ZXNcbiAgICAgICAgLy8gKGNmLiBvbkJlZm9yZUZhc3RSZWZyZXNoKVxuICAgICAgICAoMCwgX2NsaWVudC5vblJlZnJlc2gpKCk7XG4gICAgfVxuICAgIGlmIChzdGFydExhdGVuY3kpIHtcbiAgICAgICAgY29uc3QgZW5kTGF0ZW5jeSA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IGxhdGVuY3kgPSBlbmRMYXRlbmN5IC0gc3RhcnRMYXRlbmN5O1xuICAgICAgICBjb25zb2xlLmxvZyhcIltGYXN0IFJlZnJlc2hdIGRvbmUgaW4gXCIgKyBsYXRlbmN5ICsgXCJtc1wiKTtcbiAgICAgICAgKDAsIF93ZWJzb2NrZXQuc2VuZE1lc3NhZ2UpKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGV2ZW50OiBcImNsaWVudC1obXItbGF0ZW5jeVwiLFxuICAgICAgICAgICAgaWQ6IHdpbmRvdy5fX25leHREZXZDbGllbnRJZCxcbiAgICAgICAgICAgIHN0YXJ0VGltZTogc3RhcnRMYXRlbmN5LFxuICAgICAgICAgICAgZW5kVGltZTogZW5kTGF0ZW5jeSxcbiAgICAgICAgICAgIHBhZ2U6IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgICAgIHVwZGF0ZWRNb2R1bGVzXG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKHNlbGYuX19ORVhUX0hNUl9MQVRFTkNZX0NCKSB7XG4gICAgICAgICAgICBzZWxmLl9fTkVYVF9ITVJfTEFURU5DWV9DQihsYXRlbmN5KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIFRoZXJlIGlzIGEgbmV3ZXIgdmVyc2lvbiBvZiB0aGUgY29kZSBhdmFpbGFibGUuXG5mdW5jdGlvbiBoYW5kbGVBdmFpbGFibGVIYXNoKGhhc2gpIHtcbiAgICAvLyBVcGRhdGUgbGFzdCBrbm93biBjb21waWxhdGlvbiBoYXNoLlxuICAgIG1vc3RSZWNlbnRDb21waWxhdGlvbkhhc2ggPSBoYXNoO1xufVxuLy8gSGFuZGxlIG1lc3NhZ2VzIGZyb20gdGhlIHNlcnZlci5cbmZ1bmN0aW9uIHByb2Nlc3NNZXNzYWdlKG9iaikge1xuICAgIHN3aXRjaChvYmouYWN0aW9uKXtcbiAgICAgICAgY2FzZSBcImJ1aWxkaW5nXCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhcnRMYXRlbmN5ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIltGYXN0IFJlZnJlc2hdIHJlYnVpbGRpbmdcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJidWlsdFwiOlxuICAgICAgICBjYXNlIFwic3luY1wiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVBdmFpbGFibGVIYXNoKG9iai5oYXNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvcnMgLCB3YXJuaW5ncyAgfSA9IG9iajtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNFcnJvcnMgPSBCb29sZWFuKGVycm9ycyAmJiBlcnJvcnMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfd2Vic29ja2V0LnNlbmRNZXNzYWdlKShKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogXCJjbGllbnQtZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ291bnQ6IGVycm9ycy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRJZDogd2luZG93Ll9fbmV4dERldkNsaWVudElkXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9ycyhlcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBoYXNXYXJuaW5ncyA9IEJvb2xlYW4od2FybmluZ3MgJiYgd2FybmluZ3MubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzV2FybmluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF93ZWJzb2NrZXQuc2VuZE1lc3NhZ2UpKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcImNsaWVudC13YXJuaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5nQ291bnQ6IHdhcm5pbmdzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudElkOiB3aW5kb3cuX19uZXh0RGV2Q2xpZW50SWRcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlV2FybmluZ3Mod2FybmluZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoMCwgX3dlYnNvY2tldC5zZW5kTWVzc2FnZSkoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICBldmVudDogXCJjbGllbnQtc3VjY2Vzc1wiLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRJZDogd2luZG93Ll9fbmV4dERldkNsaWVudElkXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdWNjZXNzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJzZXJ2ZXJDb21wb25lbnRDaGFuZ2VzXCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcInNlcnZlckVycm9yXCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvckpTT04gIH0gPSBvYmo7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9ySlNPTikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG1lc3NhZ2UgLCBzdGFjayAgfSA9IEpTT04ucGFyc2UoZXJyb3JKU09OKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLnN0YWNrID0gc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9ycyhbXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChjdXN0b21IbXJFdmVudEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tSG1yRXZlbnRIYW5kbGVyKG9iaik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICB9XG59XG4vLyBJcyB0aGVyZSBhIG5ld2VyIHZlcnNpb24gb2YgdGhpcyBjb2RlIGF2YWlsYWJsZT9cbmZ1bmN0aW9uIGlzVXBkYXRlQXZhaWxhYmxlKCkge1xuICAgIC8qIGdsb2JhbHMgX193ZWJwYWNrX2hhc2hfXyAqLyAvLyBfX3dlYnBhY2tfaGFzaF9fIGlzIHRoZSBoYXNoIG9mIHRoZSBjdXJyZW50IGNvbXBpbGF0aW9uLlxuICAgIC8vIEl0J3MgYSBnbG9iYWwgdmFyaWFibGUgaW5qZWN0ZWQgYnkgV2VicGFjay5cbiAgICByZXR1cm4gbW9zdFJlY2VudENvbXBpbGF0aW9uSGFzaCAhPT0gX193ZWJwYWNrX2hhc2hfXztcbn1cbi8vIFdlYnBhY2sgZGlzYWxsb3dzIHVwZGF0ZXMgaW4gb3RoZXIgc3RhdGVzLlxuZnVuY3Rpb24gY2FuQXBwbHlVcGRhdGVzKCkge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogbW9kdWxlLmhvdCBleGlzdHMgYnV0IHR5cGUgbmVlZHMgdG8gYmUgYWRkZWQuIENhbid0IHVzZSBgYXMgYW55YCBoZXJlIGFzIHdlYnBhY2sgcGFyc2VzIGZvciBgbW9kdWxlLmhvdGAgY2FsbHMuXG4gICAgcmV0dXJuIG1vZHVsZS5ob3Quc3RhdHVzKCkgPT09IFwiaWRsZVwiO1xufVxuZnVuY3Rpb24gYWZ0ZXJBcHBseVVwZGF0ZXMoZm4pIHtcbiAgICBpZiAoY2FuQXBwbHlVcGRhdGVzKCkpIHtcbiAgICAgICAgZm4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVyKHN0YXR1cykge1xuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gXCJpZGxlXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE86IG1vZHVsZS5ob3QgZXhpc3RzIGJ1dCB0eXBlIG5lZWRzIHRvIGJlIGFkZGVkLiBDYW4ndCB1c2UgYGFzIGFueWAgaGVyZSBhcyB3ZWJwYWNrIHBhcnNlcyBmb3IgYG1vZHVsZS5ob3RgIGNhbGxzLlxuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QucmVtb3ZlU3RhdHVzSGFuZGxlcihoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogbW9kdWxlLmhvdCBleGlzdHMgYnV0IHR5cGUgbmVlZHMgdG8gYmUgYWRkZWQuIENhbid0IHVzZSBgYXMgYW55YCBoZXJlIGFzIHdlYnBhY2sgcGFyc2VzIGZvciBgbW9kdWxlLmhvdGAgY2FsbHMuXG4gICAgICAgIG1vZHVsZS5ob3QuYWRkU3RhdHVzSGFuZGxlcihoYW5kbGVyKTtcbiAgICB9XG59XG4vLyBBdHRlbXB0IHRvIHVwZGF0ZSBjb2RlIG9uIHRoZSBmbHksIGZhbGwgYmFjayB0byBhIGhhcmQgcmVsb2FkLlxuZnVuY3Rpb24gdHJ5QXBwbHlVcGRhdGVzKG9uQmVmb3JlSG90VXBkYXRlLCBvbkhvdFVwZGF0ZVN1Y2Nlc3MpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE86IG1vZHVsZS5ob3QgZXhpc3RzIGJ1dCB0eXBlIG5lZWRzIHRvIGJlIGFkZGVkLiBDYW4ndCB1c2UgYGFzIGFueWAgaGVyZSBhcyB3ZWJwYWNrIHBhcnNlcyBmb3IgYG1vZHVsZS5ob3RgIGNhbGxzLlxuICAgIGlmICghbW9kdWxlLmhvdCkge1xuICAgICAgICAvLyBIb3RNb2R1bGVSZXBsYWNlbWVudFBsdWdpbiBpcyBub3QgaW4gV2VicGFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICBjb25zb2xlLmVycm9yKFwiSG90TW9kdWxlUmVwbGFjZW1lbnRQbHVnaW4gaXMgbm90IGluIFdlYnBhY2sgY29uZmlndXJhdGlvbi5cIik7XG4gICAgICAgIC8vIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWlzVXBkYXRlQXZhaWxhYmxlKCkgfHwgIWNhbkFwcGx5VXBkYXRlcygpKSB7XG4gICAgICAgICgwLCBfY2xpZW50Lm9uQnVpbGRPaykoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVBcHBseVVwZGF0ZXMoZXJyLCB1cGRhdGVkTW9kdWxlcykge1xuICAgICAgICBpZiAoZXJyIHx8IGhhZFJ1bnRpbWVFcnJvciB8fCAhdXBkYXRlZE1vZHVsZXMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbRmFzdCBSZWZyZXNoXSBwZXJmb3JtaW5nIGZ1bGwgcmVsb2FkXFxuXFxuXCIgKyBcIkZhc3QgUmVmcmVzaCB3aWxsIHBlcmZvcm0gYSBmdWxsIHJlbG9hZCB3aGVuIHlvdSBlZGl0IGEgZmlsZSB0aGF0J3MgaW1wb3J0ZWQgYnkgbW9kdWxlcyBvdXRzaWRlIG9mIHRoZSBSZWFjdCByZW5kZXJpbmcgdHJlZS5cXG5cIiArIFwiWW91IG1pZ2h0IGhhdmUgYSBmaWxlIHdoaWNoIGV4cG9ydHMgYSBSZWFjdCBjb21wb25lbnQgYnV0IGFsc28gZXhwb3J0cyBhIHZhbHVlIHRoYXQgaXMgaW1wb3J0ZWQgYnkgYSBub24tUmVhY3QgY29tcG9uZW50IGZpbGUuXFxuXCIgKyBcIkNvbnNpZGVyIG1pZ3JhdGluZyB0aGUgbm9uLVJlYWN0IGNvbXBvbmVudCBleHBvcnQgdG8gYSBzZXBhcmF0ZSBmaWxlIGFuZCBpbXBvcnRpbmcgaXQgaW50byBib3RoIGZpbGVzLlxcblxcblwiICsgXCJJdCBpcyBhbHNvIHBvc3NpYmxlIHRoZSBwYXJlbnQgY29tcG9uZW50IG9mIHRoZSBjb21wb25lbnQgeW91IGVkaXRlZCBpcyBhIGNsYXNzIGNvbXBvbmVudCwgd2hpY2ggZGlzYWJsZXMgRmFzdCBSZWZyZXNoLlxcblwiICsgXCJGYXN0IFJlZnJlc2ggcmVxdWlyZXMgYXQgbGVhc3Qgb25lIHBhcmVudCBmdW5jdGlvbiBjb21wb25lbnQgaW4geW91ciBSZWFjdCB0cmVlLlwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFkUnVudGltZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW0Zhc3QgUmVmcmVzaF0gcGVyZm9ybWluZyBmdWxsIHJlbG9hZCBiZWNhdXNlIHlvdXIgYXBwbGljYXRpb24gaGFkIGFuIHVucmVjb3ZlcmFibGUgZXJyb3JcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwZXJmb3JtRnVsbFJlbG9hZChlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb25Ib3RVcGRhdGVTdWNjZXNzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIC8vIE1heWJlIHdlIHdhbnQgdG8gZG8gc29tZXRoaW5nLlxuICAgICAgICAgICAgb25Ib3RVcGRhdGVTdWNjZXNzKHVwZGF0ZWRNb2R1bGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVcGRhdGVBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgLy8gV2hpbGUgd2Ugd2VyZSB1cGRhdGluZywgdGhlcmUgd2FzIGEgbmV3IHVwZGF0ZSEgRG8gaXQgYWdhaW4uXG4gICAgICAgICAgICAvLyBIb3dldmVyLCB0aGlzIHRpbWUsIGRvbid0IHRyaWdnZXIgYSBwZW5kaW5nIHJlZnJlc2ggc3RhdGUuXG4gICAgICAgICAgICB0cnlBcHBseVVwZGF0ZXModXBkYXRlZE1vZHVsZXMubGVuZ3RoID4gMCA/IHVuZGVmaW5lZCA6IG9uQmVmb3JlSG90VXBkYXRlLCB1cGRhdGVkTW9kdWxlcy5sZW5ndGggPiAwID8gX2NsaWVudC5vbkJ1aWxkT2sgOiBvbkhvdFVwZGF0ZVN1Y2Nlc3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKDAsIF9jbGllbnQub25CdWlsZE9rKSgpO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9URVNUX01PREUpIHtcbiAgICAgICAgICAgICAgICBhZnRlckFwcGx5VXBkYXRlcygoKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fX05FWFRfSE1SX0NCKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9fTkVYVF9ITVJfQ0IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX19ORVhUX0hNUl9DQiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBodHRwczovL3dlYnBhY2suanMub3JnL2FwaS9ob3QtbW9kdWxlLXJlcGxhY2VtZW50LyNjaGVja1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogbW9kdWxlLmhvdCBleGlzdHMgYnV0IHR5cGUgbmVlZHMgdG8gYmUgYWRkZWQuIENhbid0IHVzZSBgYXMgYW55YCBoZXJlIGFzIHdlYnBhY2sgcGFyc2VzIGZvciBgbW9kdWxlLmhvdGAgY2FsbHMuXG4gICAgbW9kdWxlLmhvdC5jaGVjaygvKiBhdXRvQXBwbHkgKi8gZmFsc2UpLnRoZW4oKHVwZGF0ZWRNb2R1bGVzKT0+e1xuICAgICAgICBpZiAoIXVwZGF0ZWRNb2R1bGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9uQmVmb3JlSG90VXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIG9uQmVmb3JlSG90VXBkYXRlKHVwZGF0ZWRNb2R1bGVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE86IG1vZHVsZS5ob3QgZXhpc3RzIGJ1dCB0eXBlIG5lZWRzIHRvIGJlIGFkZGVkLiBDYW4ndCB1c2UgYGFzIGFueWAgaGVyZSBhcyB3ZWJwYWNrIHBhcnNlcyBmb3IgYG1vZHVsZS5ob3RgIGNhbGxzLlxuICAgICAgICByZXR1cm4gbW9kdWxlLmhvdC5hcHBseSgpO1xuICAgIH0pLnRoZW4oKHVwZGF0ZWRNb2R1bGVzKT0+e1xuICAgICAgICBoYW5kbGVBcHBseVVwZGF0ZXMobnVsbCwgdXBkYXRlZE1vZHVsZXMpO1xuICAgIH0sIChlcnIpPT57XG4gICAgICAgIGhhbmRsZUFwcGx5VXBkYXRlcyhlcnIsIG51bGwpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcGVyZm9ybUZ1bGxSZWxvYWQoZXJyKSB7XG4gICAgY29uc3Qgc3RhY2tUcmFjZSA9IGVyciAmJiAoZXJyLnN0YWNrICYmIGVyci5zdGFjay5zcGxpdChcIlxcblwiKS5zbGljZSgwLCA1KS5qb2luKFwiXFxuXCIpIHx8IGVyci5tZXNzYWdlIHx8IGVyciArIFwiXCIpO1xuICAgICgwLCBfd2Vic29ja2V0LnNlbmRNZXNzYWdlKShKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGV2ZW50OiBcImNsaWVudC1mdWxsLXJlbG9hZFwiLFxuICAgICAgICBzdGFja1RyYWNlLFxuICAgICAgICBoYWRSdW50aW1lRXJyb3I6ICEhaGFkUnVudGltZUVycm9yXG4gICAgfSkpO1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG90LWRldi1jbGllbnQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImNvbm5lY3QiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiX2NsaWVudCIsIl9zdHJpcGFuc2kiLCJfIiwiX3dlYnNvY2tldCIsIl9mb3JtYXR3ZWJwYWNrbWVzc2FnZXMiLCJ3aW5kb3ciLCJfX25leHREZXZDbGllbnRJZCIsIk1hdGgiLCJyb3VuZCIsInJhbmRvbSIsIkRhdGUiLCJub3ciLCJoYWRSdW50aW1lRXJyb3IiLCJjdXN0b21IbXJFdmVudEhhbmRsZXIiLCJyZWdpc3RlciIsImFkZE1lc3NhZ2VMaXN0ZW5lciIsImV2ZW50IiwicGF5bG9hZCIsIkpTT04iLCJwYXJzZSIsImRhdGEiLCJwcm9jZXNzTWVzc2FnZSIsImVyciIsIl9lcnJfc3RhY2siLCJjb25zb2xlIiwid2FybiIsInN0YWNrIiwic3Vic2NyaWJlVG9IbXJFdmVudCIsImhhbmRsZXIiLCJvblVucmVjb3ZlcmFibGVFcnJvciIsImlzRmlyc3RDb21waWxhdGlvbiIsIm1vc3RSZWNlbnRDb21waWxhdGlvbkhhc2giLCJoYXNDb21waWxlRXJyb3JzIiwiY2xlYXJPdXRkYXRlZEVycm9ycyIsImNsZWFyIiwiaGFuZGxlU3VjY2VzcyIsImlzSG90VXBkYXRlIiwiX19ORVhUX0RBVEFfXyIsInBhZ2UiLCJpc1VwZGF0ZUF2YWlsYWJsZSIsInRyeUFwcGx5VXBkYXRlcyIsIm9uQmVmb3JlRmFzdFJlZnJlc2giLCJvbkZhc3RSZWZyZXNoIiwiaGFuZGxlV2FybmluZ3MiLCJ3YXJuaW5ncyIsInByaW50V2FybmluZ3MiLCJmb3JtYXR0ZWQiLCJkZWZhdWx0IiwiZXJyb3JzIiwiX2Zvcm1hdHRlZF93YXJuaW5ncyIsImkiLCJsZW5ndGgiLCJoYW5kbGVFcnJvcnMiLCJvbkJ1aWxkRXJyb3IiLCJlcnJvciIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfVEVTVF9NT0RFIiwic2VsZiIsIl9fTkVYVF9ITVJfQ0IiLCJzdGFydExhdGVuY3kiLCJ1bmRlZmluZWQiLCJ1cGRhdGVkTW9kdWxlcyIsIm9uQmVmb3JlUmVmcmVzaCIsIm9uQnVpbGRPayIsIm9uUmVmcmVzaCIsImVuZExhdGVuY3kiLCJsYXRlbmN5IiwibG9nIiwic2VuZE1lc3NhZ2UiLCJzdHJpbmdpZnkiLCJpZCIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJsb2NhdGlvbiIsInBhdGhuYW1lIiwiX19ORVhUX0hNUl9MQVRFTkNZX0NCIiwiaGFuZGxlQXZhaWxhYmxlSGFzaCIsImhhc2giLCJvYmoiLCJhY3Rpb24iLCJoYXNFcnJvcnMiLCJCb29sZWFuIiwiZXJyb3JDb3VudCIsImNsaWVudElkIiwiaGFzV2FybmluZ3MiLCJ3YXJuaW5nQ291bnQiLCJyZWxvYWQiLCJlcnJvckpTT04iLCJtZXNzYWdlIiwiRXJyb3IiLCJfX3dlYnBhY2tfaGFzaF9fIiwiY2FuQXBwbHlVcGRhdGVzIiwibW9kdWxlIiwiaG90Iiwic3RhdHVzIiwiYWZ0ZXJBcHBseVVwZGF0ZXMiLCJmbiIsInJlbW92ZVN0YXR1c0hhbmRsZXIiLCJhZGRTdGF0dXNIYW5kbGVyIiwib25CZWZvcmVIb3RVcGRhdGUiLCJvbkhvdFVwZGF0ZVN1Y2Nlc3MiLCJoYW5kbGVBcHBseVVwZGF0ZXMiLCJwZXJmb3JtRnVsbFJlbG9hZCIsImNoZWNrIiwidGhlbiIsImFwcGx5Iiwic3RhY2tUcmFjZSIsInNwbGl0Iiwic2xpY2UiLCJqb2luIiwiX19lc01vZHVsZSIsImFzc2lnbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/dev/error-overlay/hot-dev-client.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/index.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/index.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* global location */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    version: function() {\n        return version;\n    },\n    router: function() {\n        return router;\n    },\n    emitter: function() {\n        return emitter;\n    },\n    initialize: function() {\n        return initialize;\n    },\n    hydrate: function() {\n        return hydrate;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\n__webpack_require__(/*! ../build/polyfills/polyfill-module */ \"./node_modules/next/dist/build/polyfills/polyfill-module.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nconst _client = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom/client */ \"./node_modules/react-dom/client.js\"));\nconst _headmanagercontext = __webpack_require__(/*! ../shared/lib/head-manager-context */ \"./node_modules/next/dist/shared/lib/head-manager-context.js\");\nconst _mitt = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../shared/lib/mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\nconst _routercontext = __webpack_require__(/*! ../shared/lib/router-context */ \"./node_modules/next/dist/shared/lib/router-context.js\");\nconst _handlesmoothscroll = __webpack_require__(/*! ../shared/lib/router/utils/handle-smooth-scroll */ \"./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\");\nconst _isdynamic = __webpack_require__(/*! ../shared/lib/router/utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nconst _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nconst _runtimeconfig = __webpack_require__(/*! ../shared/lib/runtime-config */ \"./node_modules/next/dist/shared/lib/runtime-config.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nconst _portal = __webpack_require__(/*! ./portal */ \"./node_modules/next/dist/client/portal/index.js\");\nconst _headmanager = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./head-manager */ \"./node_modules/next/dist/client/head-manager.js\"));\nconst _pageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./page-loader */ \"./node_modules/next/dist/client/page-loader.js\"));\nconst _performancerelayer = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./performance-relayer */ \"./node_modules/next/dist/client/performance-relayer.js\"));\nconst _routeannouncer = __webpack_require__(/*! ./route-announcer */ \"./node_modules/next/dist/client/route-announcer.js\");\nconst _router = __webpack_require__(/*! ./router */ \"./node_modules/next/dist/client/router.js\");\nconst _iserror = __webpack_require__(/*! ../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\");\nconst _imageconfigcontext = __webpack_require__(/*! ../shared/lib/image-config-context */ \"./node_modules/next/dist/shared/lib/image-config-context.js\");\nconst _removebasepath = __webpack_require__(/*! ./remove-base-path */ \"./node_modules/next/dist/client/remove-base-path.js\");\nconst _hasbasepath = __webpack_require__(/*! ./has-base-path */ \"./node_modules/next/dist/client/has-base-path.js\");\nconst _approutercontext = __webpack_require__(/*! ../shared/lib/app-router-context */ \"./node_modules/next/dist/shared/lib/app-router-context.js\");\nconst _adapters = __webpack_require__(/*! ../shared/lib/router/adapters */ \"./node_modules/next/dist/shared/lib/router/adapters.js\");\nconst _hooksclientcontext = __webpack_require__(/*! ../shared/lib/hooks-client-context */ \"./node_modules/next/dist/shared/lib/hooks-client-context.js\");\nconst _onrecoverableerror = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./on-recoverable-error */ \"./node_modules/next/dist/client/on-recoverable-error.js\"));\nconst _tracer = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./tracing/tracer */ \"./node_modules/next/dist/client/tracing/tracer.js\"));\nconst _reporttosocket = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./tracing/report-to-socket */ \"./node_modules/next/dist/client/tracing/report-to-socket.js\"));\nconst version = \"13.4.19\";\nlet router;\nconst emitter = (0, _mitt.default)();\nconst looseToArray = (input)=>[].slice.call(input);\nlet initialData;\nlet defaultLocale = undefined;\nlet asPath;\nlet pageLoader;\nlet appElement;\nlet headManager;\nlet initialMatchesMiddleware = false;\nlet lastAppProps;\nlet lastRenderReject;\nlet webpackHMR;\nlet CachedApp, onPerfEntry;\nlet CachedComponent;\nclass Container extends _react.default.Component {\n    componentDidCatch(componentErr, info) {\n        this.props.fn(componentErr, info);\n    }\n    componentDidMount() {\n        this.scrollToHash();\n        // We need to replace the router state if:\n        // - the page was (auto) exported and has a query string or search (hash)\n        // - it was auto exported and is a dynamic route (to provide params)\n        // - if it is a client-side skeleton (fallback render)\n        // - if middleware matches the current page (may have rewrite params)\n        // - if rewrites in next.config.js match (may have rewrite params)\n        if (router.isSsr && (initialData.isFallback || initialData.nextExport && ((0, _isdynamic.isDynamicRoute)(router.pathname) || location.search || false || initialMatchesMiddleware) || initialData.props && initialData.props.__N_SSG && (location.search || false || initialMatchesMiddleware))) {\n            // update query on mount for exported pages\n            router.replace(router.pathname + \"?\" + String((0, _querystring.assign)((0, _querystring.urlQueryToSearchParams)(router.query), new URLSearchParams(location.search))), asPath, {\n                // @ts-ignore\n                // WARNING: `_h` is an internal option for handing Next.js\n                // client-side hydration. Your app should _never_ use this property.\n                // It may change at any time without notice.\n                _h: 1,\n                // Fallback pages must trigger the data fetch, so the transition is\n                // not shallow.\n                // Other pages (strictly updating query) happens shallowly, as data\n                // requirements would already be present.\n                shallow: !initialData.isFallback && !initialMatchesMiddleware\n            }).catch((err)=>{\n                if (!err.cancelled) throw err;\n            });\n        }\n    }\n    componentDidUpdate() {\n        this.scrollToHash();\n    }\n    scrollToHash() {\n        let { hash } = location;\n        hash = hash && hash.substring(1);\n        if (!hash) return;\n        const el = document.getElementById(hash);\n        if (!el) return;\n        // If we call scrollIntoView() in here without a setTimeout\n        // it won't scroll properly.\n        setTimeout(()=>el.scrollIntoView(), 0);\n    }\n    render() {\n        if (false) {} else {\n            const { ReactDevOverlay } = __webpack_require__(/*! next/dist/compiled/@next/react-dev-overlay/dist/client */ \"./node_modules/next/dist/compiled/@next/react-dev-overlay/dist/client.js\");\n            return /*#__PURE__*/ _react.default.createElement(ReactDevOverlay, null, this.props.children);\n        }\n    }\n}\nasync function initialize(opts) {\n    if (opts === void 0) opts = {};\n    _tracer.default.onSpanEnd(_reporttosocket.default);\n    // This makes sure this specific lines are removed in production\n    if (true) {\n        webpackHMR = opts.webpackHMR;\n    }\n    initialData = JSON.parse(document.getElementById(\"__NEXT_DATA__\").textContent);\n    window.__NEXT_DATA__ = initialData;\n    defaultLocale = initialData.defaultLocale;\n    const prefix = initialData.assetPrefix || \"\";\n    self.__next_set_public_path__(\"\" + prefix + \"/_next/\") //eslint-disable-line\n    ;\n    // Initialize next/config with the environment configuration\n    (0, _runtimeconfig.setConfig)({\n        serverRuntimeConfig: {},\n        publicRuntimeConfig: initialData.runtimeConfig || {}\n    });\n    asPath = (0, _utils.getURL)();\n    // make sure not to attempt stripping basePath for 404s\n    if ((0, _hasbasepath.hasBasePath)(asPath)) {\n        asPath = (0, _removebasepath.removeBasePath)(asPath);\n    }\n    if (false) {}\n    if (initialData.scriptLoader) {\n        const { initScriptLoader } = __webpack_require__(/*! ./script */ \"./node_modules/next/dist/client/script.js\");\n        initScriptLoader(initialData.scriptLoader);\n    }\n    pageLoader = new _pageloader.default(initialData.buildId, prefix);\n    const register = (param)=>{\n        let [r, f] = param;\n        return pageLoader.routeLoader.onEntrypoint(r, f);\n    };\n    if (window.__NEXT_P) {\n        // Defer page registration for another tick. This will increase the overall\n        // latency in hydrating the page, but reduce the total blocking time.\n        window.__NEXT_P.map((p)=>setTimeout(()=>register(p), 0));\n    }\n    window.__NEXT_P = [];\n    window.__NEXT_P.push = register;\n    headManager = (0, _headmanager.default)();\n    headManager.getIsSsr = ()=>{\n        return router.isSsr;\n    };\n    appElement = document.getElementById(\"__next\");\n    return {\n        assetPrefix: prefix\n    };\n}\nfunction renderApp(App, appProps) {\n    return /*#__PURE__*/ _react.default.createElement(App, appProps);\n}\nfunction AppContainer(param) {\n    _s();\n    let { children } = param;\n    // Create a memoized value for next/navigation router context.\n    const adaptedForAppRouter = _react.default.useMemo(()=>{\n        return (0, _adapters.adaptForAppRouterInstance)(router);\n    }, []);\n    var _self___NEXT_DATA___autoExport;\n    return /*#__PURE__*/ _react.default.createElement(Container, {\n        fn: (error)=>// eslint-disable-next-line @typescript-eslint/no-use-before-define\n            renderError({\n                App: CachedApp,\n                err: error\n            }).catch((err)=>console.error(\"Error rendering page: \", err))\n    }, /*#__PURE__*/ _react.default.createElement(_approutercontext.AppRouterContext.Provider, {\n        value: adaptedForAppRouter\n    }, /*#__PURE__*/ _react.default.createElement(_hooksclientcontext.SearchParamsContext.Provider, {\n        value: (0, _adapters.adaptForSearchParams)(router)\n    }, /*#__PURE__*/ _react.default.createElement(_adapters.PathnameContextProviderAdapter, {\n        router: router,\n        isAutoExport: (_self___NEXT_DATA___autoExport = self.__NEXT_DATA__.autoExport) != null ? _self___NEXT_DATA___autoExport : false\n    }, /*#__PURE__*/ _react.default.createElement(_routercontext.RouterContext.Provider, {\n        value: (0, _router.makePublicRouterInstance)(router)\n    }, /*#__PURE__*/ _react.default.createElement(_headmanagercontext.HeadManagerContext.Provider, {\n        value: headManager\n    }, /*#__PURE__*/ _react.default.createElement(_imageconfigcontext.ImageConfigContext.Provider, {\n        value: {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[]}\n    }, children)))))));\n}\n_s(AppContainer, \"F6BSfrFQNeqenuPnUMVY/6gI8uE=\");\n_c = AppContainer;\nconst wrapApp = (App)=>(wrappedAppProps)=>{\n        const appProps = {\n            ...wrappedAppProps,\n            Component: CachedComponent,\n            err: initialData.err,\n            router\n        };\n        return /*#__PURE__*/ _react.default.createElement(AppContainer, null, renderApp(App, appProps));\n    };\n// This method handles all runtime and debug errors.\n// 404 and 500 errors are special kind of errors\n// and they are still handle via the main render method.\nfunction renderError(renderErrorProps) {\n    let { App, err } = renderErrorProps;\n    // In development runtime errors are caught by our overlay\n    // In production we catch runtime errors using componentDidCatch which will trigger renderError\n    if (true) {\n        // A Next.js rendering runtime error is always unrecoverable\n        // FIXME: let's make this recoverable (error in GIP client-transition)\n        webpackHMR.onUnrecoverableError();\n        // We need to render an empty <App> so that the `<ReactDevOverlay>` can\n        // render itself.\n        // TODO: Fix disabled eslint rule\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return doRender({\n            App: ()=>null,\n            props: {},\n            Component: ()=>null,\n            styleSheets: []\n        });\n    }\n    // Make sure we log the error to the console, otherwise users can't track down issues.\n    console.error(err);\n    console.error(\"A client-side exception has occurred, see here for more info: https://nextjs.org/docs/messages/client-side-exception-occurred\");\n    return pageLoader.loadPage(\"/_error\").then((param)=>{\n        let { page: ErrorComponent, styleSheets } = param;\n        return (lastAppProps == null ? void 0 : lastAppProps.Component) === ErrorComponent ? Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ../pages/_error */ \"./node_modules/next/dist/pages/_error.js\"))).then((errorModule)=>{\n            return Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ../pages/_app */ \"./node_modules/next/dist/pages/_app.js\"))).then((appModule)=>{\n                App = appModule.default;\n                renderErrorProps.App = App;\n                return errorModule;\n            });\n        }).then((m)=>({\n                ErrorComponent: m.default,\n                styleSheets: []\n            })) : {\n            ErrorComponent,\n            styleSheets\n        };\n    }).then((param)=>{\n        let { ErrorComponent, styleSheets } = param;\n        var _renderErrorProps_props;\n        // In production we do a normal render with the `ErrorComponent` as component.\n        // If we've gotten here upon initial render, we can use the props from the server.\n        // Otherwise, we need to call `getInitialProps` on `App` before mounting.\n        const AppTree = wrapApp(App);\n        const appCtx = {\n            Component: ErrorComponent,\n            AppTree,\n            router,\n            ctx: {\n                err,\n                pathname: initialData.page,\n                query: initialData.query,\n                asPath,\n                AppTree\n            }\n        };\n        return Promise.resolve(((_renderErrorProps_props = renderErrorProps.props) == null ? void 0 : _renderErrorProps_props.err) ? renderErrorProps.props : (0, _utils.loadGetInitialProps)(App, appCtx)).then((initProps)=>// eslint-disable-next-line @typescript-eslint/no-use-before-define\n            doRender({\n                ...renderErrorProps,\n                err,\n                Component: ErrorComponent,\n                styleSheets,\n                props: initProps\n            }));\n    });\n}\n// Dummy component that we render as a child of Root so that we can\n// toggle the correct styles before the page is rendered.\nfunction Head(param) {\n    _s1();\n    let { callback } = param;\n    // We use `useLayoutEffect` to guarantee the callback is executed\n    // as soon as React flushes the update.\n    _react.default.useLayoutEffect(()=>callback(), [\n        callback\n    ]);\n    return null;\n}\n_s1(Head, \"n7/vCynhJvM+pLkyL2DMQUF0odM=\");\n_c1 = Head;\nlet reactRoot = null;\n// On initial render a hydrate should always happen\nlet shouldHydrate = true;\nfunction clearMarks() {\n    [\n        \"beforeRender\",\n        \"afterHydrate\",\n        \"afterRender\",\n        \"routeChange\"\n    ].forEach((mark)=>performance.clearMarks(mark));\n}\nfunction markHydrateComplete() {\n    if (!_utils.ST) return;\n    performance.mark(\"afterHydrate\") // mark end of hydration\n    ;\n    const beforeHydrationMeasure = performance.measure(\"Next.js-before-hydration\", \"navigationStart\", \"beforeRender\");\n    const hydrationMeasure = performance.measure(\"Next.js-hydration\", \"beforeRender\", \"afterHydrate\");\n    _tracer.default.startSpan(\"navigation-to-hydration\", {\n        startTime: performance.timeOrigin + beforeHydrationMeasure.startTime,\n        attributes: {\n            pathname: location.pathname,\n            query: location.search\n        }\n    }).end(performance.timeOrigin + hydrationMeasure.startTime + hydrationMeasure.duration);\n    if (onPerfEntry) {\n        performance.getEntriesByName(\"Next.js-hydration\").forEach(onPerfEntry);\n    }\n    clearMarks();\n}\nfunction markRenderComplete() {\n    if (!_utils.ST) return;\n    performance.mark(\"afterRender\") // mark end of render\n    ;\n    const navStartEntries = performance.getEntriesByName(\"routeChange\", \"mark\");\n    if (!navStartEntries.length) return;\n    performance.measure(\"Next.js-route-change-to-render\", navStartEntries[0].name, \"beforeRender\");\n    performance.measure(\"Next.js-render\", \"beforeRender\", \"afterRender\");\n    if (onPerfEntry) {\n        performance.getEntriesByName(\"Next.js-render\").forEach(onPerfEntry);\n        performance.getEntriesByName(\"Next.js-route-change-to-render\").forEach(onPerfEntry);\n    }\n    clearMarks();\n    [\n        \"Next.js-route-change-to-render\",\n        \"Next.js-render\"\n    ].forEach((measure)=>performance.clearMeasures(measure));\n}\nfunction renderReactElement(domEl, fn) {\n    // mark start of hydrate/render\n    if (_utils.ST) {\n        performance.mark(\"beforeRender\");\n    }\n    const reactEl = fn(shouldHydrate ? markHydrateComplete : markRenderComplete);\n    if (!reactRoot) {\n        // Unlike with createRoot, you don't need a separate root.render() call here\n        reactRoot = _client.default.hydrateRoot(domEl, reactEl, {\n            onRecoverableError: _onrecoverableerror.default\n        });\n        // TODO: Remove shouldHydrate variable when React 18 is stable as it can depend on `reactRoot` existing\n        shouldHydrate = false;\n    } else {\n        const startTransition = _react.default.startTransition;\n        startTransition(()=>{\n            reactRoot.render(reactEl);\n        });\n    }\n}\nfunction Root(param) {\n    _s2();\n    let { callbacks, children } = param;\n    // We use `useLayoutEffect` to guarantee the callbacks are executed\n    // as soon as React flushes the update\n    _react.default.useLayoutEffect(()=>callbacks.forEach((callback)=>callback()), [\n        callbacks\n    ]);\n    // We should ask to measure the Web Vitals after rendering completes so we\n    // don't cause any hydration delay:\n    _react.default.useEffect(()=>{\n        (0, _performancerelayer.default)(onPerfEntry);\n    }, []);\n    if (false) {}\n    return children;\n}\n_s2(Root, \"Gjgl5rfcc2T4sFnfEMfRvL6K4Q4=\");\n_c2 = Root;\nfunction doRender(input) {\n    let { App, Component, props, err } = input;\n    let styleSheets = \"initial\" in input ? undefined : input.styleSheets;\n    Component = Component || lastAppProps.Component;\n    props = props || lastAppProps.props;\n    const appProps = {\n        ...props,\n        Component,\n        err,\n        router\n    };\n    // lastAppProps has to be set before ReactDom.render to account for ReactDom throwing an error.\n    lastAppProps = appProps;\n    let canceled = false;\n    let resolvePromise;\n    const renderPromise = new Promise((resolve, reject)=>{\n        if (lastRenderReject) {\n            lastRenderReject();\n        }\n        resolvePromise = ()=>{\n            lastRenderReject = null;\n            resolve();\n        };\n        lastRenderReject = ()=>{\n            canceled = true;\n            lastRenderReject = null;\n            const error = new Error(\"Cancel rendering route\");\n            error.cancelled = true;\n            reject(error);\n        };\n    });\n    // This function has a return type to ensure it doesn't start returning a\n    // Promise. It should remain synchronous.\n    function onStart() {\n        if (!styleSheets || // We use `style-loader` in development, so we don't need to do anything\n        // unless we're in production:\n        \"development\" !== \"production\") {\n            return false;\n        }\n        const currentStyleTags = looseToArray(document.querySelectorAll(\"style[data-n-href]\"));\n        const currentHrefs = new Set(currentStyleTags.map((tag)=>tag.getAttribute(\"data-n-href\")));\n        const noscript = document.querySelector(\"noscript[data-n-css]\");\n        const nonce = noscript == null ? void 0 : noscript.getAttribute(\"data-n-css\");\n        styleSheets.forEach((param)=>{\n            let { href, text } = param;\n            if (!currentHrefs.has(href)) {\n                const styleTag = document.createElement(\"style\");\n                styleTag.setAttribute(\"data-n-href\", href);\n                styleTag.setAttribute(\"media\", \"x\");\n                if (nonce) {\n                    styleTag.setAttribute(\"nonce\", nonce);\n                }\n                document.head.appendChild(styleTag);\n                styleTag.appendChild(document.createTextNode(text));\n            }\n        });\n        return true;\n    }\n    function onHeadCommit() {\n        if (// unless we're in production:\n        false) {}\n        if (input.scroll) {\n            const { x, y } = input.scroll;\n            (0, _handlesmoothscroll.handleSmoothScroll)(()=>{\n                window.scrollTo(x, y);\n            });\n        }\n    }\n    function onRootCommit() {\n        resolvePromise();\n    }\n    onStart();\n    const elem = /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(Head, {\n        callback: onHeadCommit\n    }), /*#__PURE__*/ _react.default.createElement(AppContainer, null, renderApp(App, appProps), /*#__PURE__*/ _react.default.createElement(_portal.Portal, {\n        type: \"next-route-announcer\"\n    }, /*#__PURE__*/ _react.default.createElement(_routeannouncer.RouteAnnouncer, null))));\n    // We catch runtime errors using componentDidCatch which will trigger renderError\n    renderReactElement(appElement, (callback)=>/*#__PURE__*/ _react.default.createElement(Root, {\n            callbacks: [\n                callback,\n                onRootCommit\n            ]\n        },  false ? /*#__PURE__*/ 0 : elem));\n    return renderPromise;\n}\nasync function render(renderingProps) {\n    if (renderingProps.err) {\n        await renderError(renderingProps);\n        return;\n    }\n    try {\n        await doRender(renderingProps);\n    } catch (err) {\n        const renderErr = (0, _iserror.getProperError)(err);\n        // bubble up cancelation errors\n        if (renderErr.cancelled) {\n            throw renderErr;\n        }\n        if (true) {\n            // Ensure this error is displayed in the overlay in development\n            setTimeout(()=>{\n                throw renderErr;\n            });\n        }\n        await renderError({\n            ...renderingProps,\n            err: renderErr\n        });\n    }\n}\nasync function hydrate(opts) {\n    let initialErr = initialData.err;\n    try {\n        const appEntrypoint = await pageLoader.routeLoader.whenEntrypoint(\"/_app\");\n        if (\"error\" in appEntrypoint) {\n            throw appEntrypoint.error;\n        }\n        const { component: app, exports: mod } = appEntrypoint;\n        CachedApp = app;\n        if (mod && mod.reportWebVitals) {\n            onPerfEntry = (param)=>{\n                let { id, name, startTime, value, duration, entryType, entries, attribution } = param;\n                // Combines timestamp with random number for unique ID\n                const uniqueID = Date.now() + \"-\" + (Math.floor(Math.random() * (9e12 - 1)) + 1e12);\n                let perfStartEntry;\n                if (entries && entries.length) {\n                    perfStartEntry = entries[0].startTime;\n                }\n                const webVitals = {\n                    id: id || uniqueID,\n                    name,\n                    startTime: startTime || perfStartEntry,\n                    value: value == null ? duration : value,\n                    label: entryType === \"mark\" || entryType === \"measure\" ? \"custom\" : \"web-vital\"\n                };\n                if (attribution) {\n                    webVitals.attribution = attribution;\n                }\n                mod.reportWebVitals(webVitals);\n            };\n        }\n        const pageEntrypoint = // error, so we need to skip waiting for the entrypoint.\n         true && initialData.err ? {\n            error: initialData.err\n        } : await pageLoader.routeLoader.whenEntrypoint(initialData.page);\n        if (\"error\" in pageEntrypoint) {\n            throw pageEntrypoint.error;\n        }\n        CachedComponent = pageEntrypoint.component;\n        if (true) {\n            const { isValidElementType } = __webpack_require__(/*! next/dist/compiled/react-is */ \"./node_modules/next/dist/compiled/react-is/index.js\");\n            if (!isValidElementType(CachedComponent)) {\n                throw new Error('The default export is not a React Component in page: \"' + initialData.page + '\"');\n            }\n        }\n    } catch (error) {\n        // This catches errors like throwing in the top level of a module\n        initialErr = (0, _iserror.getProperError)(error);\n    }\n    if (true) {\n        const { getServerError } = __webpack_require__(/*! next/dist/compiled/@next/react-dev-overlay/dist/client */ \"./node_modules/next/dist/compiled/@next/react-dev-overlay/dist/client.js\");\n        // Server-side runtime errors need to be re-thrown on the client-side so\n        // that the overlay is rendered.\n        if (initialErr) {\n            if (initialErr === initialData.err) {\n                setTimeout(()=>{\n                    let error;\n                    try {\n                        // Generate a new error object. We `throw` it because some browsers\n                        // will set the `stack` when thrown, and we want to ensure ours is\n                        // not overridden when we re-throw it below.\n                        throw new Error(initialErr.message);\n                    } catch (e) {\n                        error = e;\n                    }\n                    error.name = initialErr.name;\n                    error.stack = initialErr.stack;\n                    throw getServerError(error, initialErr.source);\n                });\n            } else {\n                setTimeout(()=>{\n                    throw initialErr;\n                });\n            }\n        }\n    }\n    if (window.__NEXT_PRELOADREADY) {\n        await window.__NEXT_PRELOADREADY(initialData.dynamicIds);\n    }\n    router = (0, _router.createRouter)(initialData.page, initialData.query, asPath, {\n        initialProps: initialData.props,\n        pageLoader,\n        App: CachedApp,\n        Component: CachedComponent,\n        wrapApp,\n        err: initialErr,\n        isFallback: Boolean(initialData.isFallback),\n        subscription: (info, App, scroll)=>render(Object.assign({}, info, {\n                App,\n                scroll\n            })),\n        locale: initialData.locale,\n        locales: initialData.locales,\n        defaultLocale,\n        domainLocales: initialData.domainLocales,\n        isPreview: initialData.isPreview\n    });\n    initialMatchesMiddleware = await router._initialMatchesMiddlewarePromise;\n    const renderCtx = {\n        App: CachedApp,\n        initial: true,\n        Component: CachedComponent,\n        props: initialData.props,\n        err: initialErr\n    };\n    if (opts == null ? void 0 : opts.beforeRender) {\n        await opts.beforeRender();\n    }\n    render(renderCtx);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=index.js.map\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"AppContainer\");\n$RefreshReg$(_c1, \"Head\");\n$RefreshReg$(_c2, \"Root\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBbUIsR0FBZ0I7Ozs7OztBQUNuQ0EsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FNTjtBQUNBLFNBQVNNLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlaLE9BQU9DLGNBQWMsQ0FBQ1UsUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRUixTQUFTO0lBQ2JHLFNBQVM7UUFDTCxPQUFPQTtJQUNYO0lBQ0FDLFFBQVE7UUFDSixPQUFPQTtJQUNYO0lBQ0FDLFNBQVM7UUFDTCxPQUFPQTtJQUNYO0lBQ0FDLFlBQVk7UUFDUixPQUFPQTtJQUNYO0lBQ0FDLFNBQVM7UUFDTCxPQUFPQTtJQUNYO0FBQ0o7QUFDQSxNQUFNTywyQkFBMkJDLG1CQUFPQSxDQUFDLDRHQUF5QztBQUNsRkEsbUJBQU9BLENBQUMsdUdBQW9DO0FBQzVDLE1BQU1DLFNBQVMsV0FBVyxHQUFHRix5QkFBeUJHLENBQUMsQ0FBQ0YsbUJBQU9BLENBQUMsNENBQU87QUFDdkUsTUFBTUcsVUFBVSxXQUFXLEdBQUdKLHlCQUF5QkcsQ0FBQyxDQUFDRixtQkFBT0EsQ0FBQyw0REFBa0I7QUFDbkYsTUFBTUksc0JBQXNCSixtQkFBT0EsQ0FBQyx1R0FBb0M7QUFDeEUsTUFBTUssUUFBUSxXQUFXLEdBQUdOLHlCQUF5QkcsQ0FBQyxDQUFDRixtQkFBT0EsQ0FBQyx1RUFBb0I7QUFDbkYsTUFBTU0saUJBQWlCTixtQkFBT0EsQ0FBQywyRkFBOEI7QUFDN0QsTUFBTU8sc0JBQXNCUCxtQkFBT0EsQ0FBQyxpSUFBaUQ7QUFDckYsTUFBTVEsYUFBYVIsbUJBQU9BLENBQUMsNkdBQXVDO0FBQ2xFLE1BQU1TLGVBQWVULG1CQUFPQSxD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QUFNO2dCQUMxRHFGO2dCQUNBa0g7WUFDSjtRQUNKckksUUFBUXBGLFlBQVlvRixNQUFNO1FBQzFCSixTQUFTaEYsWUFBWWdGLE9BQU87UUFDNUIvRTtRQUNBeVEsZUFBZTFRLFlBQVkwUSxhQUFhO1FBQ3hDQyxXQUFXM1EsWUFBWTJRLFNBQVM7SUFDcEM7SUFDQXBRLDJCQUEyQixNQUFNbkQsT0FBT3dULGdDQUFnQztJQUN4RSxNQUFNQyxZQUFZO1FBQ2R0SyxLQUFLNUY7UUFDTG1RLFNBQVM7UUFDVC9QLFdBQVdGO1FBQ1hNLE9BQU9uQixZQUFZbUIsS0FBSztRQUN4QndCLEtBQUs4TDtJQUNUO0lBQ0EsSUFBSWhMLFFBQVEsT0FBTyxLQUFLLElBQUlBLEtBQUtzTixZQUFZLEVBQUU7UUFDM0MsTUFBTXROLEtBQUtzTixZQUFZO0lBQzNCO0lBQ0ExTixPQUFPd047QUFDWDtBQUVBLElBQUksQ0FBQyxPQUFPN1QsUUFBUTJDLE9BQU8sS0FBSyxjQUFlLE9BQU8zQyxRQUFRMkMsT0FBTyxLQUFLLFlBQVkzQyxRQUFRMkMsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPM0MsUUFBUTJDLE9BQU8sQ0FBQ3FSLFVBQVUsS0FBSyxhQUFhO0lBQ3JLbFUsT0FBT0MsY0FBYyxDQUFDQyxRQUFRMkMsT0FBTyxFQUFFLGNBQWM7UUFBRTFDLE9BQU87SUFBSztJQUNuRUgsT0FBT3NGLE1BQU0sQ0FBQ3BGLFFBQVEyQyxPQUFPLEVBQUUzQztJQUMvQkUsT0FBT0YsT0FBTyxHQUFHQSxRQUFRMkMsT0FBTztBQUNsQyxFQUVBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbmRleC5qcz80NmNiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbCBsb2NhdGlvbiAqLyBcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIHZlcnNpb246IG51bGwsXG4gICAgcm91dGVyOiBudWxsLFxuICAgIGVtaXR0ZXI6IG51bGwsXG4gICAgaW5pdGlhbGl6ZTogbnVsbCxcbiAgICBoeWRyYXRlOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIHZlcnNpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICB9LFxuICAgIHJvdXRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByb3V0ZXI7XG4gICAgfSxcbiAgICBlbWl0dGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGVtaXR0ZXI7XG4gICAgfSxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGluaXRpYWxpemU7XG4gICAgfSxcbiAgICBoeWRyYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGh5ZHJhdGU7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xucmVxdWlyZShcIi4uL2J1aWxkL3BvbHlmaWxscy9wb2x5ZmlsbC1tb2R1bGVcIik7XG5jb25zdCBfcmVhY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBfY2xpZW50ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwicmVhY3QtZG9tL2NsaWVudFwiKSk7XG5jb25zdCBfaGVhZG1hbmFnZXJjb250ZXh0ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvaGVhZC1tYW5hZ2VyLWNvbnRleHRcIik7XG5jb25zdCBfbWl0dCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4uL3NoYXJlZC9saWIvbWl0dFwiKSk7XG5jb25zdCBfcm91dGVyY29udGV4dCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci1jb250ZXh0XCIpO1xuY29uc3QgX2hhbmRsZXNtb290aHNjcm9sbCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9oYW5kbGUtc21vb3RoLXNjcm9sbFwiKTtcbmNvbnN0IF9pc2R5bmFtaWMgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pY1wiKTtcbmNvbnN0IF9xdWVyeXN0cmluZyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9xdWVyeXN0cmluZ1wiKTtcbmNvbnN0IF9ydW50aW1lY29uZmlnID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcnVudGltZS1jb25maWdcIik7XG5jb25zdCBfdXRpbHMgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi91dGlsc1wiKTtcbmNvbnN0IF9wb3J0YWwgPSByZXF1aXJlKFwiLi9wb3J0YWxcIik7XG5jb25zdCBfaGVhZG1hbmFnZXIgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCIuL2hlYWQtbWFuYWdlclwiKSk7XG5jb25zdCBfcGFnZWxvYWRlciA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4vcGFnZS1sb2FkZXJcIikpO1xuY29uc3QgX3BlcmZvcm1hbmNlcmVsYXllciA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4vcGVyZm9ybWFuY2UtcmVsYXllclwiKSk7XG5jb25zdCBfcm91dGVhbm5vdW5jZXIgPSByZXF1aXJlKFwiLi9yb3V0ZS1hbm5vdW5jZXJcIik7XG5jb25zdCBfcm91dGVyID0gcmVxdWlyZShcIi4vcm91dGVyXCIpO1xuY29uc3QgX2lzZXJyb3IgPSByZXF1aXJlKFwiLi4vbGliL2lzLWVycm9yXCIpO1xuY29uc3QgX2ltYWdlY29uZmlnY29udGV4dCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZy1jb250ZXh0XCIpO1xuY29uc3QgX3JlbW92ZWJhc2VwYXRoID0gcmVxdWlyZShcIi4vcmVtb3ZlLWJhc2UtcGF0aFwiKTtcbmNvbnN0IF9oYXNiYXNlcGF0aCA9IHJlcXVpcmUoXCIuL2hhcy1iYXNlLXBhdGhcIik7XG5jb25zdCBfYXBwcm91dGVyY29udGV4dCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dFwiKTtcbmNvbnN0IF9hZGFwdGVycyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci9hZGFwdGVyc1wiKTtcbmNvbnN0IF9ob29rc2NsaWVudGNvbnRleHQgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9ob29rcy1jbGllbnQtY29udGV4dFwiKTtcbmNvbnN0IF9vbnJlY292ZXJhYmxlZXJyb3IgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCIuL29uLXJlY292ZXJhYmxlLWVycm9yXCIpKTtcbmNvbnN0IF90cmFjZXIgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCIuL3RyYWNpbmcvdHJhY2VyXCIpKTtcbmNvbnN0IF9yZXBvcnR0b3NvY2tldCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4vdHJhY2luZy9yZXBvcnQtdG8tc29ja2V0XCIpKTtcbmNvbnN0IHZlcnNpb24gPSBcIjEzLjQuMTlcIjtcbmxldCByb3V0ZXI7XG5jb25zdCBlbWl0dGVyID0gKDAsIF9taXR0LmRlZmF1bHQpKCk7XG5jb25zdCBsb29zZVRvQXJyYXkgPSAoaW5wdXQpPT5bXS5zbGljZS5jYWxsKGlucHV0KTtcbmxldCBpbml0aWFsRGF0YTtcbmxldCBkZWZhdWx0TG9jYWxlID0gdW5kZWZpbmVkO1xubGV0IGFzUGF0aDtcbmxldCBwYWdlTG9hZGVyO1xubGV0IGFwcEVsZW1lbnQ7XG5sZXQgaGVhZE1hbmFnZXI7XG5sZXQgaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlID0gZmFsc2U7XG5sZXQgbGFzdEFwcFByb3BzO1xubGV0IGxhc3RSZW5kZXJSZWplY3Q7XG5sZXQgd2VicGFja0hNUjtcbmxldCBDYWNoZWRBcHAsIG9uUGVyZkVudHJ5O1xubGV0IENhY2hlZENvbXBvbmVudDtcbmNsYXNzIENvbnRhaW5lciBleHRlbmRzIF9yZWFjdC5kZWZhdWx0LkNvbXBvbmVudCB7XG4gICAgY29tcG9uZW50RGlkQ2F0Y2goY29tcG9uZW50RXJyLCBpbmZvKSB7XG4gICAgICAgIHRoaXMucHJvcHMuZm4oY29tcG9uZW50RXJyLCBpbmZvKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKCk7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gcmVwbGFjZSB0aGUgcm91dGVyIHN0YXRlIGlmOlxuICAgICAgICAvLyAtIHRoZSBwYWdlIHdhcyAoYXV0bykgZXhwb3J0ZWQgYW5kIGhhcyBhIHF1ZXJ5IHN0cmluZyBvciBzZWFyY2ggKGhhc2gpXG4gICAgICAgIC8vIC0gaXQgd2FzIGF1dG8gZXhwb3J0ZWQgYW5kIGlzIGEgZHluYW1pYyByb3V0ZSAodG8gcHJvdmlkZSBwYXJhbXMpXG4gICAgICAgIC8vIC0gaWYgaXQgaXMgYSBjbGllbnQtc2lkZSBza2VsZXRvbiAoZmFsbGJhY2sgcmVuZGVyKVxuICAgICAgICAvLyAtIGlmIG1pZGRsZXdhcmUgbWF0Y2hlcyB0aGUgY3VycmVudCBwYWdlIChtYXkgaGF2ZSByZXdyaXRlIHBhcmFtcylcbiAgICAgICAgLy8gLSBpZiByZXdyaXRlcyBpbiBuZXh0LmNvbmZpZy5qcyBtYXRjaCAobWF5IGhhdmUgcmV3cml0ZSBwYXJhbXMpXG4gICAgICAgIGlmIChyb3V0ZXIuaXNTc3IgJiYgKGluaXRpYWxEYXRhLmlzRmFsbGJhY2sgfHwgaW5pdGlhbERhdGEubmV4dEV4cG9ydCAmJiAoKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKHJvdXRlci5wYXRobmFtZSkgfHwgbG9jYXRpb24uc2VhcmNoIHx8IHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgfHwgaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlKSB8fCBpbml0aWFsRGF0YS5wcm9wcyAmJiBpbml0aWFsRGF0YS5wcm9wcy5fX05fU1NHICYmIChsb2NhdGlvbi5zZWFyY2ggfHwgcHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyB8fCBpbml0aWFsTWF0Y2hlc01pZGRsZXdhcmUpKSkge1xuICAgICAgICAgICAgLy8gdXBkYXRlIHF1ZXJ5IG9uIG1vdW50IGZvciBleHBvcnRlZCBwYWdlc1xuICAgICAgICAgICAgcm91dGVyLnJlcGxhY2Uocm91dGVyLnBhdGhuYW1lICsgXCI/XCIgKyBTdHJpbmcoKDAsIF9xdWVyeXN0cmluZy5hc3NpZ24pKCgwLCBfcXVlcnlzdHJpbmcudXJsUXVlcnlUb1NlYXJjaFBhcmFtcykocm91dGVyLnF1ZXJ5KSwgbmV3IFVSTFNlYXJjaFBhcmFtcyhsb2NhdGlvbi5zZWFyY2gpKSksIGFzUGF0aCwge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAvLyBXQVJOSU5HOiBgX2hgIGlzIGFuIGludGVybmFsIG9wdGlvbiBmb3IgaGFuZGluZyBOZXh0LmpzXG4gICAgICAgICAgICAgICAgLy8gY2xpZW50LXNpZGUgaHlkcmF0aW9uLiBZb3VyIGFwcCBzaG91bGQgX25ldmVyXyB1c2UgdGhpcyBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyBJdCBtYXkgY2hhbmdlIGF0IGFueSB0aW1lIHdpdGhvdXQgbm90aWNlLlxuICAgICAgICAgICAgICAgIF9oOiAxLFxuICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIHBhZ2VzIG11c3QgdHJpZ2dlciB0aGUgZGF0YSBmZXRjaCwgc28gdGhlIHRyYW5zaXRpb24gaXNcbiAgICAgICAgICAgICAgICAvLyBub3Qgc2hhbGxvdy5cbiAgICAgICAgICAgICAgICAvLyBPdGhlciBwYWdlcyAoc3RyaWN0bHkgdXBkYXRpbmcgcXVlcnkpIGhhcHBlbnMgc2hhbGxvd2x5LCBhcyBkYXRhXG4gICAgICAgICAgICAgICAgLy8gcmVxdWlyZW1lbnRzIHdvdWxkIGFscmVhZHkgYmUgcHJlc2VudC5cbiAgICAgICAgICAgICAgICBzaGFsbG93OiAhaW5pdGlhbERhdGEuaXNGYWxsYmFjayAmJiAhaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlXG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgICAgIGlmICghZXJyLmNhbmNlbGxlZCkgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICB0aGlzLnNjcm9sbFRvSGFzaCgpO1xuICAgIH1cbiAgICBzY3JvbGxUb0hhc2goKSB7XG4gICAgICAgIGxldCB7IGhhc2ggIH0gPSBsb2NhdGlvbjtcbiAgICAgICAgaGFzaCA9IGhhc2ggJiYgaGFzaC5zdWJzdHJpbmcoMSk7XG4gICAgICAgIGlmICghaGFzaCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2gpO1xuICAgICAgICBpZiAoIWVsKSByZXR1cm47XG4gICAgICAgIC8vIElmIHdlIGNhbGwgc2Nyb2xsSW50b1ZpZXcoKSBpbiBoZXJlIHdpdGhvdXQgYSBzZXRUaW1lb3V0XG4gICAgICAgIC8vIGl0IHdvbid0IHNjcm9sbCBwcm9wZXJseS5cbiAgICAgICAgc2V0VGltZW91dCgoKT0+ZWwuc2Nyb2xsSW50b1ZpZXcoKSwgMCk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB7IFJlYWN0RGV2T3ZlcmxheSAgfSA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvZGlzdC9jbGllbnRcIik7XG4gICAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJlYWN0RGV2T3ZlcmxheSwgbnVsbCwgdGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBpbml0aWFsaXplKG9wdHMpIHtcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSBvcHRzID0ge307XG4gICAgX3RyYWNlci5kZWZhdWx0Lm9uU3BhbkVuZChfcmVwb3J0dG9zb2NrZXQuZGVmYXVsdCk7XG4gICAgLy8gVGhpcyBtYWtlcyBzdXJlIHRoaXMgc3BlY2lmaWMgbGluZXMgYXJlIHJlbW92ZWQgaW4gcHJvZHVjdGlvblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgIHdlYnBhY2tITVIgPSBvcHRzLndlYnBhY2tITVI7XG4gICAgfVxuICAgIGluaXRpYWxEYXRhID0gSlNPTi5wYXJzZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIl9fTkVYVF9EQVRBX19cIikudGV4dENvbnRlbnQpO1xuICAgIHdpbmRvdy5fX05FWFRfREFUQV9fID0gaW5pdGlhbERhdGE7XG4gICAgZGVmYXVsdExvY2FsZSA9IGluaXRpYWxEYXRhLmRlZmF1bHRMb2NhbGU7XG4gICAgY29uc3QgcHJlZml4ID0gaW5pdGlhbERhdGEuYXNzZXRQcmVmaXggfHwgXCJcIjtcbiAgICBzZWxmLl9fbmV4dF9zZXRfcHVibGljX3BhdGhfXyhcIlwiICsgcHJlZml4ICsgXCIvX25leHQvXCIpIC8vZXNsaW50LWRpc2FibGUtbGluZVxuICAgIDtcbiAgICAvLyBJbml0aWFsaXplIG5leHQvY29uZmlnIHdpdGggdGhlIGVudmlyb25tZW50IGNvbmZpZ3VyYXRpb25cbiAgICAoMCwgX3J1bnRpbWVjb25maWcuc2V0Q29uZmlnKSh7XG4gICAgICAgIHNlcnZlclJ1bnRpbWVDb25maWc6IHt9LFxuICAgICAgICBwdWJsaWNSdW50aW1lQ29uZmlnOiBpbml0aWFsRGF0YS5ydW50aW1lQ29uZmlnIHx8IHt9XG4gICAgfSk7XG4gICAgYXNQYXRoID0gKDAsIF91dGlscy5nZXRVUkwpKCk7XG4gICAgLy8gbWFrZSBzdXJlIG5vdCB0byBhdHRlbXB0IHN0cmlwcGluZyBiYXNlUGF0aCBmb3IgNDA0c1xuICAgIGlmICgoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShhc1BhdGgpKSB7XG4gICAgICAgIGFzUGF0aCA9ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzUGF0aCk7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIGNvbnN0IHsgbm9ybWFsaXplTG9jYWxlUGF0aCAgfSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2kxOG4vbm9ybWFsaXplLWxvY2FsZS1wYXRoXCIpO1xuICAgICAgICBjb25zdCB7IGRldGVjdERvbWFpbkxvY2FsZSAgfSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2kxOG4vZGV0ZWN0LWRvbWFpbi1sb2NhbGVcIik7XG4gICAgICAgIGNvbnN0IHsgcGFyc2VSZWxhdGl2ZVVybCAgfSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9wYXJzZS1yZWxhdGl2ZS11cmxcIik7XG4gICAgICAgIGNvbnN0IHsgZm9ybWF0VXJsICB9ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmxcIik7XG4gICAgICAgIGlmIChpbml0aWFsRGF0YS5sb2NhbGVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRBcyA9IHBhcnNlUmVsYXRpdmVVcmwoYXNQYXRoKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSBub3JtYWxpemVMb2NhbGVQYXRoKHBhcnNlZEFzLnBhdGhuYW1lLCBpbml0aWFsRGF0YS5sb2NhbGVzKTtcbiAgICAgICAgICAgIGlmIChsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSBsb2NhbGVQYXRoUmVzdWx0LnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIGFzUGF0aCA9IGZvcm1hdFVybChwYXJzZWRBcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlcml2ZSB0aGUgZGVmYXVsdCBsb2NhbGUgaWYgaXQgd2Fzbid0IGRldGVjdGVkIGluIHRoZSBhc1BhdGhcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSBkb24ndCBwcmVyZW5kZXIgc3RhdGljIHBhZ2VzIHdpdGggYWxsIHBvc3NpYmxlIGRlZmF1bHRcbiAgICAgICAgICAgICAgICAvLyBsb2NhbGVzXG4gICAgICAgICAgICAgICAgZGVmYXVsdExvY2FsZSA9IGluaXRpYWxEYXRhLmxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGF0dGVtcHQgZGV0ZWN0aW5nIGRlZmF1bHQgbG9jYWxlIGJhc2VkIG9uIGhvc3RuYW1lXG4gICAgICAgICAgICBjb25zdCBkZXRlY3RlZERvbWFpbiA9IGRldGVjdERvbWFpbkxvY2FsZShwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9ET01BSU5TLCB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUpO1xuICAgICAgICAgICAgLy8gVE9ETzogaW52ZXN0aWdhdGUgaWYgZGVmYXVsdExvY2FsZSBuZWVkcyB0byBiZSBwb3B1bGF0ZWQgYWZ0ZXJcbiAgICAgICAgICAgIC8vIGh5ZHJhdGlvbiB0byBwcmV2ZW50IG1pc21hdGNoZWQgcmVuZGVyc1xuICAgICAgICAgICAgaWYgKGRldGVjdGVkRG9tYWluKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdExvY2FsZSA9IGRldGVjdGVkRG9tYWluLmRlZmF1bHRMb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluaXRpYWxEYXRhLnNjcmlwdExvYWRlcikge1xuICAgICAgICBjb25zdCB7IGluaXRTY3JpcHRMb2FkZXIgIH0gPSByZXF1aXJlKFwiLi9zY3JpcHRcIik7XG4gICAgICAgIGluaXRTY3JpcHRMb2FkZXIoaW5pdGlhbERhdGEuc2NyaXB0TG9hZGVyKTtcbiAgICB9XG4gICAgcGFnZUxvYWRlciA9IG5ldyBfcGFnZWxvYWRlci5kZWZhdWx0KGluaXRpYWxEYXRhLmJ1aWxkSWQsIHByZWZpeCk7XG4gICAgY29uc3QgcmVnaXN0ZXIgPSAocGFyYW0pPT57XG4gICAgICAgIGxldCBbciwgZl0gPSBwYXJhbTtcbiAgICAgICAgcmV0dXJuIHBhZ2VMb2FkZXIucm91dGVMb2FkZXIub25FbnRyeXBvaW50KHIsIGYpO1xuICAgIH07XG4gICAgaWYgKHdpbmRvdy5fX05FWFRfUCkge1xuICAgICAgICAvLyBEZWZlciBwYWdlIHJlZ2lzdHJhdGlvbiBmb3IgYW5vdGhlciB0aWNrLiBUaGlzIHdpbGwgaW5jcmVhc2UgdGhlIG92ZXJhbGxcbiAgICAgICAgLy8gbGF0ZW5jeSBpbiBoeWRyYXRpbmcgdGhlIHBhZ2UsIGJ1dCByZWR1Y2UgdGhlIHRvdGFsIGJsb2NraW5nIHRpbWUuXG4gICAgICAgIHdpbmRvdy5fX05FWFRfUC5tYXAoKHApPT5zZXRUaW1lb3V0KCgpPT5yZWdpc3RlcihwKSwgMCkpO1xuICAgIH1cbiAgICB3aW5kb3cuX19ORVhUX1AgPSBbXTtcbiAgICB3aW5kb3cuX19ORVhUX1AucHVzaCA9IHJlZ2lzdGVyO1xuICAgIGhlYWRNYW5hZ2VyID0gKDAsIF9oZWFkbWFuYWdlci5kZWZhdWx0KSgpO1xuICAgIGhlYWRNYW5hZ2VyLmdldElzU3NyID0gKCk9PntcbiAgICAgICAgcmV0dXJuIHJvdXRlci5pc1NzcjtcbiAgICB9O1xuICAgIGFwcEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIl9fbmV4dFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhc3NldFByZWZpeDogcHJlZml4XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlbmRlckFwcChBcHAsIGFwcFByb3BzKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChBcHAsIGFwcFByb3BzKTtcbn1cbmZ1bmN0aW9uIEFwcENvbnRhaW5lcihwYXJhbSkge1xuICAgIGxldCB7IGNoaWxkcmVuICB9ID0gcGFyYW07XG4gICAgLy8gQ3JlYXRlIGEgbWVtb2l6ZWQgdmFsdWUgZm9yIG5leHQvbmF2aWdhdGlvbiByb3V0ZXIgY29udGV4dC5cbiAgICBjb25zdCBhZGFwdGVkRm9yQXBwUm91dGVyID0gX3JlYWN0LmRlZmF1bHQudXNlTWVtbygoKT0+e1xuICAgICAgICByZXR1cm4gKDAsIF9hZGFwdGVycy5hZGFwdEZvckFwcFJvdXRlckluc3RhbmNlKShyb3V0ZXIpO1xuICAgIH0sIFtdKTtcbiAgICB2YXIgX3NlbGZfX19ORVhUX0RBVEFfX19hdXRvRXhwb3J0O1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ29udGFpbmVyLCB7XG4gICAgICAgIGZuOiAoZXJyb3IpPT4vLyBUT0RPOiBGaXggZGlzYWJsZWQgZXNsaW50IHJ1bGVcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgICAgIHJlbmRlckVycm9yKHtcbiAgICAgICAgICAgICAgICBBcHA6IENhY2hlZEFwcCxcbiAgICAgICAgICAgICAgICBlcnI6IGVycm9yXG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyKT0+Y29uc29sZS5lcnJvcihcIkVycm9yIHJlbmRlcmluZyBwYWdlOiBcIiwgZXJyKSlcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2FwcHJvdXRlcmNvbnRleHQuQXBwUm91dGVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogYWRhcHRlZEZvckFwcFJvdXRlclxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfaG9va3NjbGllbnRjb250ZXh0LlNlYXJjaFBhcmFtc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6ICgwLCBfYWRhcHRlcnMuYWRhcHRGb3JTZWFyY2hQYXJhbXMpKHJvdXRlcilcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2FkYXB0ZXJzLlBhdGhuYW1lQ29udGV4dFByb3ZpZGVyQWRhcHRlciwge1xuICAgICAgICByb3V0ZXI6IHJvdXRlcixcbiAgICAgICAgaXNBdXRvRXhwb3J0OiAoX3NlbGZfX19ORVhUX0RBVEFfX19hdXRvRXhwb3J0ID0gc2VsZi5fX05FWFRfREFUQV9fLmF1dG9FeHBvcnQpICE9IG51bGwgPyBfc2VsZl9fX05FWFRfREFUQV9fX2F1dG9FeHBvcnQgOiBmYWxzZVxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcm91dGVyY29udGV4dC5Sb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiAoMCwgX3JvdXRlci5tYWtlUHVibGljUm91dGVySW5zdGFuY2UpKHJvdXRlcilcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2hlYWRtYW5hZ2VyY29udGV4dC5IZWFkTWFuYWdlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IGhlYWRNYW5hZ2VyXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9pbWFnZWNvbmZpZ2NvbnRleHQuSW1hZ2VDb25maWdDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBwcm9jZXNzLmVudi5fX05FWFRfSU1BR0VfT1BUU1xuICAgIH0sIGNoaWxkcmVuKSkpKSkpKTtcbn1cbmNvbnN0IHdyYXBBcHAgPSAoQXBwKT0+KHdyYXBwZWRBcHBQcm9wcyk9PntcbiAgICAgICAgY29uc3QgYXBwUHJvcHMgPSB7XG4gICAgICAgICAgICAuLi53cmFwcGVkQXBwUHJvcHMsXG4gICAgICAgICAgICBDb21wb25lbnQ6IENhY2hlZENvbXBvbmVudCxcbiAgICAgICAgICAgIGVycjogaW5pdGlhbERhdGEuZXJyLFxuICAgICAgICAgICAgcm91dGVyXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQXBwQ29udGFpbmVyLCBudWxsLCByZW5kZXJBcHAoQXBwLCBhcHBQcm9wcykpO1xuICAgIH07XG4vLyBUaGlzIG1ldGhvZCBoYW5kbGVzIGFsbCBydW50aW1lIGFuZCBkZWJ1ZyBlcnJvcnMuXG4vLyA0MDQgYW5kIDUwMCBlcnJvcnMgYXJlIHNwZWNpYWwga2luZCBvZiBlcnJvcnNcbi8vIGFuZCB0aGV5IGFyZSBzdGlsbCBoYW5kbGUgdmlhIHRoZSBtYWluIHJlbmRlciBtZXRob2QuXG5mdW5jdGlvbiByZW5kZXJFcnJvcihyZW5kZXJFcnJvclByb3BzKSB7XG4gICAgbGV0IHsgQXBwICwgZXJyICB9ID0gcmVuZGVyRXJyb3JQcm9wcztcbiAgICAvLyBJbiBkZXZlbG9wbWVudCBydW50aW1lIGVycm9ycyBhcmUgY2F1Z2h0IGJ5IG91ciBvdmVybGF5XG4gICAgLy8gSW4gcHJvZHVjdGlvbiB3ZSBjYXRjaCBydW50aW1lIGVycm9ycyB1c2luZyBjb21wb25lbnREaWRDYXRjaCB3aGljaCB3aWxsIHRyaWdnZXIgcmVuZGVyRXJyb3JcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIC8vIEEgTmV4dC5qcyByZW5kZXJpbmcgcnVudGltZSBlcnJvciBpcyBhbHdheXMgdW5yZWNvdmVyYWJsZVxuICAgICAgICAvLyBGSVhNRTogbGV0J3MgbWFrZSB0aGlzIHJlY292ZXJhYmxlIChlcnJvciBpbiBHSVAgY2xpZW50LXRyYW5zaXRpb24pXG4gICAgICAgIHdlYnBhY2tITVIub25VbnJlY292ZXJhYmxlRXJyb3IoKTtcbiAgICAgICAgLy8gV2UgbmVlZCB0byByZW5kZXIgYW4gZW1wdHkgPEFwcD4gc28gdGhhdCB0aGUgYDxSZWFjdERldk92ZXJsYXk+YCBjYW5cbiAgICAgICAgLy8gcmVuZGVyIGl0c2VsZi5cbiAgICAgICAgLy8gVE9ETzogRml4IGRpc2FibGVkIGVzbGludCBydWxlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIGRvUmVuZGVyKHtcbiAgICAgICAgICAgIEFwcDogKCk9Pm51bGwsXG4gICAgICAgICAgICBwcm9wczoge30sXG4gICAgICAgICAgICBDb21wb25lbnQ6ICgpPT5udWxsLFxuICAgICAgICAgICAgc3R5bGVTaGVldHM6IFtdXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgd2UgbG9nIHRoZSBlcnJvciB0byB0aGUgY29uc29sZSwgb3RoZXJ3aXNlIHVzZXJzIGNhbid0IHRyYWNrIGRvd24gaXNzdWVzLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICBjb25zb2xlLmVycm9yKFwiQSBjbGllbnQtc2lkZSBleGNlcHRpb24gaGFzIG9jY3VycmVkLCBzZWUgaGVyZSBmb3IgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9jbGllbnQtc2lkZS1leGNlcHRpb24tb2NjdXJyZWRcIik7XG4gICAgcmV0dXJuIHBhZ2VMb2FkZXIubG9hZFBhZ2UoXCIvX2Vycm9yXCIpLnRoZW4oKHBhcmFtKT0+e1xuICAgICAgICBsZXQgeyBwYWdlOiBFcnJvckNvbXBvbmVudCAsIHN0eWxlU2hlZXRzICB9ID0gcGFyYW07XG4gICAgICAgIHJldHVybiAobGFzdEFwcFByb3BzID09IG51bGwgPyB2b2lkIDAgOiBsYXN0QXBwUHJvcHMuQ29tcG9uZW50KSA9PT0gRXJyb3JDb21wb25lbnQgPyBpbXBvcnQoXCIuLi9wYWdlcy9fZXJyb3JcIikudGhlbigoZXJyb3JNb2R1bGUpPT57XG4gICAgICAgICAgICByZXR1cm4gaW1wb3J0KFwiLi4vcGFnZXMvX2FwcFwiKS50aGVuKChhcHBNb2R1bGUpPT57XG4gICAgICAgICAgICAgICAgQXBwID0gYXBwTW9kdWxlLmRlZmF1bHQ7XG4gICAgICAgICAgICAgICAgcmVuZGVyRXJyb3JQcm9wcy5BcHAgPSBBcHA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yTW9kdWxlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLnRoZW4oKG0pPT4oe1xuICAgICAgICAgICAgICAgIEVycm9yQ29tcG9uZW50OiBtLmRlZmF1bHQsXG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldHM6IFtdXG4gICAgICAgICAgICB9KSkgOiB7XG4gICAgICAgICAgICBFcnJvckNvbXBvbmVudCxcbiAgICAgICAgICAgIHN0eWxlU2hlZXRzXG4gICAgICAgIH07XG4gICAgfSkudGhlbigocGFyYW0pPT57XG4gICAgICAgIGxldCB7IEVycm9yQ29tcG9uZW50ICwgc3R5bGVTaGVldHMgIH0gPSBwYXJhbTtcbiAgICAgICAgdmFyIF9yZW5kZXJFcnJvclByb3BzX3Byb3BzO1xuICAgICAgICAvLyBJbiBwcm9kdWN0aW9uIHdlIGRvIGEgbm9ybWFsIHJlbmRlciB3aXRoIHRoZSBgRXJyb3JDb21wb25lbnRgIGFzIGNvbXBvbmVudC5cbiAgICAgICAgLy8gSWYgd2UndmUgZ290dGVuIGhlcmUgdXBvbiBpbml0aWFsIHJlbmRlciwgd2UgY2FuIHVzZSB0aGUgcHJvcHMgZnJvbSB0aGUgc2VydmVyLlxuICAgICAgICAvLyBPdGhlcndpc2UsIHdlIG5lZWQgdG8gY2FsbCBgZ2V0SW5pdGlhbFByb3BzYCBvbiBgQXBwYCBiZWZvcmUgbW91bnRpbmcuXG4gICAgICAgIGNvbnN0IEFwcFRyZWUgPSB3cmFwQXBwKEFwcCk7XG4gICAgICAgIGNvbnN0IGFwcEN0eCA9IHtcbiAgICAgICAgICAgIENvbXBvbmVudDogRXJyb3JDb21wb25lbnQsXG4gICAgICAgICAgICBBcHBUcmVlLFxuICAgICAgICAgICAgcm91dGVyLFxuICAgICAgICAgICAgY3R4OiB7XG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBpbml0aWFsRGF0YS5wYWdlLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBpbml0aWFsRGF0YS5xdWVyeSxcbiAgICAgICAgICAgICAgICBhc1BhdGgsXG4gICAgICAgICAgICAgICAgQXBwVHJlZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCgoX3JlbmRlckVycm9yUHJvcHNfcHJvcHMgPSByZW5kZXJFcnJvclByb3BzLnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX3JlbmRlckVycm9yUHJvcHNfcHJvcHMuZXJyKSA/IHJlbmRlckVycm9yUHJvcHMucHJvcHMgOiAoMCwgX3V0aWxzLmxvYWRHZXRJbml0aWFsUHJvcHMpKEFwcCwgYXBwQ3R4KSkudGhlbigoaW5pdFByb3BzKT0+Ly8gVE9ETzogRml4IGRpc2FibGVkIGVzbGludCBydWxlXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgICAgICBkb1JlbmRlcih7XG4gICAgICAgICAgICAgICAgLi4ucmVuZGVyRXJyb3JQcm9wcyxcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50OiBFcnJvckNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0cyxcbiAgICAgICAgICAgICAgICBwcm9wczogaW5pdFByb3BzXG4gICAgICAgICAgICB9KSk7XG4gICAgfSk7XG59XG4vLyBEdW1teSBjb21wb25lbnQgdGhhdCB3ZSByZW5kZXIgYXMgYSBjaGlsZCBvZiBSb290IHNvIHRoYXQgd2UgY2FuXG4vLyB0b2dnbGUgdGhlIGNvcnJlY3Qgc3R5bGVzIGJlZm9yZSB0aGUgcGFnZSBpcyByZW5kZXJlZC5cbmZ1bmN0aW9uIEhlYWQocGFyYW0pIHtcbiAgICBsZXQgeyBjYWxsYmFjayAgfSA9IHBhcmFtO1xuICAgIC8vIFdlIHVzZSBgdXNlTGF5b3V0RWZmZWN0YCB0byBndWFyYW50ZWUgdGhlIGNhbGxiYWNrIGlzIGV4ZWN1dGVkXG4gICAgLy8gYXMgc29vbiBhcyBSZWFjdCBmbHVzaGVzIHRoZSB1cGRhdGUuXG4gICAgX3JlYWN0LmRlZmF1bHQudXNlTGF5b3V0RWZmZWN0KCgpPT5jYWxsYmFjaygpLCBbXG4gICAgICAgIGNhbGxiYWNrXG4gICAgXSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5sZXQgcmVhY3RSb290ID0gbnVsbDtcbi8vIE9uIGluaXRpYWwgcmVuZGVyIGEgaHlkcmF0ZSBzaG91bGQgYWx3YXlzIGhhcHBlblxubGV0IHNob3VsZEh5ZHJhdGUgPSB0cnVlO1xuZnVuY3Rpb24gY2xlYXJNYXJrcygpIHtcbiAgICBbXG4gICAgICAgIFwiYmVmb3JlUmVuZGVyXCIsXG4gICAgICAgIFwiYWZ0ZXJIeWRyYXRlXCIsXG4gICAgICAgIFwiYWZ0ZXJSZW5kZXJcIixcbiAgICAgICAgXCJyb3V0ZUNoYW5nZVwiXG4gICAgXS5mb3JFYWNoKChtYXJrKT0+cGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhtYXJrKSk7XG59XG5mdW5jdGlvbiBtYXJrSHlkcmF0ZUNvbXBsZXRlKCkge1xuICAgIGlmICghX3V0aWxzLlNUKSByZXR1cm47XG4gICAgcGVyZm9ybWFuY2UubWFyayhcImFmdGVySHlkcmF0ZVwiKSAvLyBtYXJrIGVuZCBvZiBoeWRyYXRpb25cbiAgICA7XG4gICAgY29uc3QgYmVmb3JlSHlkcmF0aW9uTWVhc3VyZSA9IHBlcmZvcm1hbmNlLm1lYXN1cmUoXCJOZXh0LmpzLWJlZm9yZS1oeWRyYXRpb25cIiwgXCJuYXZpZ2F0aW9uU3RhcnRcIiwgXCJiZWZvcmVSZW5kZXJcIik7XG4gICAgY29uc3QgaHlkcmF0aW9uTWVhc3VyZSA9IHBlcmZvcm1hbmNlLm1lYXN1cmUoXCJOZXh0LmpzLWh5ZHJhdGlvblwiLCBcImJlZm9yZVJlbmRlclwiLCBcImFmdGVySHlkcmF0ZVwiKTtcbiAgICBfdHJhY2VyLmRlZmF1bHQuc3RhcnRTcGFuKFwibmF2aWdhdGlvbi10by1oeWRyYXRpb25cIiwge1xuICAgICAgICBzdGFydFRpbWU6IHBlcmZvcm1hbmNlLnRpbWVPcmlnaW4gKyBiZWZvcmVIeWRyYXRpb25NZWFzdXJlLnN0YXJ0VGltZSxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICAgICAgcXVlcnk6IGxvY2F0aW9uLnNlYXJjaFxuICAgICAgICB9XG4gICAgfSkuZW5kKHBlcmZvcm1hbmNlLnRpbWVPcmlnaW4gKyBoeWRyYXRpb25NZWFzdXJlLnN0YXJ0VGltZSArIGh5ZHJhdGlvbk1lYXN1cmUuZHVyYXRpb24pO1xuICAgIGlmIChvblBlcmZFbnRyeSkge1xuICAgICAgICBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKFwiTmV4dC5qcy1oeWRyYXRpb25cIikuZm9yRWFjaChvblBlcmZFbnRyeSk7XG4gICAgfVxuICAgIGNsZWFyTWFya3MoKTtcbn1cbmZ1bmN0aW9uIG1hcmtSZW5kZXJDb21wbGV0ZSgpIHtcbiAgICBpZiAoIV91dGlscy5TVCkgcmV0dXJuO1xuICAgIHBlcmZvcm1hbmNlLm1hcmsoXCJhZnRlclJlbmRlclwiKSAvLyBtYXJrIGVuZCBvZiByZW5kZXJcbiAgICA7XG4gICAgY29uc3QgbmF2U3RhcnRFbnRyaWVzID0gcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZShcInJvdXRlQ2hhbmdlXCIsIFwibWFya1wiKTtcbiAgICBpZiAoIW5hdlN0YXJ0RW50cmllcy5sZW5ndGgpIHJldHVybjtcbiAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKFwiTmV4dC5qcy1yb3V0ZS1jaGFuZ2UtdG8tcmVuZGVyXCIsIG5hdlN0YXJ0RW50cmllc1swXS5uYW1lLCBcImJlZm9yZVJlbmRlclwiKTtcbiAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKFwiTmV4dC5qcy1yZW5kZXJcIiwgXCJiZWZvcmVSZW5kZXJcIiwgXCJhZnRlclJlbmRlclwiKTtcbiAgICBpZiAob25QZXJmRW50cnkpIHtcbiAgICAgICAgcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZShcIk5leHQuanMtcmVuZGVyXCIpLmZvckVhY2gob25QZXJmRW50cnkpO1xuICAgICAgICBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKFwiTmV4dC5qcy1yb3V0ZS1jaGFuZ2UtdG8tcmVuZGVyXCIpLmZvckVhY2gob25QZXJmRW50cnkpO1xuICAgIH1cbiAgICBjbGVhck1hcmtzKCk7XG4gICAgW1xuICAgICAgICBcIk5leHQuanMtcm91dGUtY2hhbmdlLXRvLXJlbmRlclwiLFxuICAgICAgICBcIk5leHQuanMtcmVuZGVyXCJcbiAgICBdLmZvckVhY2goKG1lYXN1cmUpPT5wZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKG1lYXN1cmUpKTtcbn1cbmZ1bmN0aW9uIHJlbmRlclJlYWN0RWxlbWVudChkb21FbCwgZm4pIHtcbiAgICAvLyBtYXJrIHN0YXJ0IG9mIGh5ZHJhdGUvcmVuZGVyXG4gICAgaWYgKF91dGlscy5TVCkge1xuICAgICAgICBwZXJmb3JtYW5jZS5tYXJrKFwiYmVmb3JlUmVuZGVyXCIpO1xuICAgIH1cbiAgICBjb25zdCByZWFjdEVsID0gZm4oc2hvdWxkSHlkcmF0ZSA/IG1hcmtIeWRyYXRlQ29tcGxldGUgOiBtYXJrUmVuZGVyQ29tcGxldGUpO1xuICAgIGlmICghcmVhY3RSb290KSB7XG4gICAgICAgIC8vIFVubGlrZSB3aXRoIGNyZWF0ZVJvb3QsIHlvdSBkb24ndCBuZWVkIGEgc2VwYXJhdGUgcm9vdC5yZW5kZXIoKSBjYWxsIGhlcmVcbiAgICAgICAgcmVhY3RSb290ID0gX2NsaWVudC5kZWZhdWx0Lmh5ZHJhdGVSb290KGRvbUVsLCByZWFjdEVsLCB7XG4gICAgICAgICAgICBvblJlY292ZXJhYmxlRXJyb3I6IF9vbnJlY292ZXJhYmxlZXJyb3IuZGVmYXVsdFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIHNob3VsZEh5ZHJhdGUgdmFyaWFibGUgd2hlbiBSZWFjdCAxOCBpcyBzdGFibGUgYXMgaXQgY2FuIGRlcGVuZCBvbiBgcmVhY3RSb290YCBleGlzdGluZ1xuICAgICAgICBzaG91bGRIeWRyYXRlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUcmFuc2l0aW9uID0gX3JlYWN0LmRlZmF1bHQuc3RhcnRUcmFuc2l0aW9uO1xuICAgICAgICBzdGFydFRyYW5zaXRpb24oKCk9PntcbiAgICAgICAgICAgIHJlYWN0Um9vdC5yZW5kZXIocmVhY3RFbCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIFJvb3QocGFyYW0pIHtcbiAgICBsZXQgeyBjYWxsYmFja3MgLCBjaGlsZHJlbiAgfSA9IHBhcmFtO1xuICAgIC8vIFdlIHVzZSBgdXNlTGF5b3V0RWZmZWN0YCB0byBndWFyYW50ZWUgdGhlIGNhbGxiYWNrcyBhcmUgZXhlY3V0ZWRcbiAgICAvLyBhcyBzb29uIGFzIFJlYWN0IGZsdXNoZXMgdGhlIHVwZGF0ZVxuICAgIF9yZWFjdC5kZWZhdWx0LnVzZUxheW91dEVmZmVjdCgoKT0+Y2FsbGJhY2tzLmZvckVhY2goKGNhbGxiYWNrKT0+Y2FsbGJhY2soKSksIFtcbiAgICAgICAgY2FsbGJhY2tzXG4gICAgXSk7XG4gICAgLy8gV2Ugc2hvdWxkIGFzayB0byBtZWFzdXJlIHRoZSBXZWIgVml0YWxzIGFmdGVyIHJlbmRlcmluZyBjb21wbGV0ZXMgc28gd2VcbiAgICAvLyBkb24ndCBjYXVzZSBhbnkgaHlkcmF0aW9uIGRlbGF5OlxuICAgIF9yZWFjdC5kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAoMCwgX3BlcmZvcm1hbmNlcmVsYXllci5kZWZhdWx0KShvblBlcmZFbnRyeSk7XG4gICAgfSwgW10pO1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgICAgICBfcmVhY3QuZGVmYXVsdC51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgICAgIHdpbmRvdy5fX05FWFRfSFlEUkFURUQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5fX05FWFRfSFlEUkFURURfQ0IpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuX19ORVhUX0hZRFJBVEVEX0NCKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xufVxuZnVuY3Rpb24gZG9SZW5kZXIoaW5wdXQpIHtcbiAgICBsZXQgeyBBcHAgLCBDb21wb25lbnQgLCBwcm9wcyAsIGVyciAgfSA9IGlucHV0O1xuICAgIGxldCBzdHlsZVNoZWV0cyA9IFwiaW5pdGlhbFwiIGluIGlucHV0ID8gdW5kZWZpbmVkIDogaW5wdXQuc3R5bGVTaGVldHM7XG4gICAgQ29tcG9uZW50ID0gQ29tcG9uZW50IHx8IGxhc3RBcHBQcm9wcy5Db21wb25lbnQ7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCBsYXN0QXBwUHJvcHMucHJvcHM7XG4gICAgY29uc3QgYXBwUHJvcHMgPSB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIGVycixcbiAgICAgICAgcm91dGVyXG4gICAgfTtcbiAgICAvLyBsYXN0QXBwUHJvcHMgaGFzIHRvIGJlIHNldCBiZWZvcmUgUmVhY3REb20ucmVuZGVyIHRvIGFjY291bnQgZm9yIFJlYWN0RG9tIHRocm93aW5nIGFuIGVycm9yLlxuICAgIGxhc3RBcHBQcm9wcyA9IGFwcFByb3BzO1xuICAgIGxldCBjYW5jZWxlZCA9IGZhbHNlO1xuICAgIGxldCByZXNvbHZlUHJvbWlzZTtcbiAgICBjb25zdCByZW5kZXJQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgaWYgKGxhc3RSZW5kZXJSZWplY3QpIHtcbiAgICAgICAgICAgIGxhc3RSZW5kZXJSZWplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlUHJvbWlzZSA9ICgpPT57XG4gICAgICAgICAgICBsYXN0UmVuZGVyUmVqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGFzdFJlbmRlclJlamVjdCA9ICgpPT57XG4gICAgICAgICAgICBjYW5jZWxlZCA9IHRydWU7XG4gICAgICAgICAgICBsYXN0UmVuZGVyUmVqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwiQ2FuY2VsIHJlbmRlcmluZyByb3V0ZVwiKTtcbiAgICAgICAgICAgIGVycm9yLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaGFzIGEgcmV0dXJuIHR5cGUgdG8gZW5zdXJlIGl0IGRvZXNuJ3Qgc3RhcnQgcmV0dXJuaW5nIGFcbiAgICAvLyBQcm9taXNlLiBJdCBzaG91bGQgcmVtYWluIHN5bmNocm9ub3VzLlxuICAgIGZ1bmN0aW9uIG9uU3RhcnQoKSB7XG4gICAgICAgIGlmICghc3R5bGVTaGVldHMgfHwgLy8gV2UgdXNlIGBzdHlsZS1sb2FkZXJgIGluIGRldmVsb3BtZW50LCBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nXG4gICAgICAgIC8vIHVubGVzcyB3ZSdyZSBpbiBwcm9kdWN0aW9uOlxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50U3R5bGVUYWdzID0gbG9vc2VUb0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJzdHlsZVtkYXRhLW4taHJlZl1cIikpO1xuICAgICAgICBjb25zdCBjdXJyZW50SHJlZnMgPSBuZXcgU2V0KGN1cnJlbnRTdHlsZVRhZ3MubWFwKCh0YWcpPT50YWcuZ2V0QXR0cmlidXRlKFwiZGF0YS1uLWhyZWZcIikpKTtcbiAgICAgICAgY29uc3Qgbm9zY3JpcHQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibm9zY3JpcHRbZGF0YS1uLWNzc11cIik7XG4gICAgICAgIGNvbnN0IG5vbmNlID0gbm9zY3JpcHQgPT0gbnVsbCA/IHZvaWQgMCA6IG5vc2NyaXB0LmdldEF0dHJpYnV0ZShcImRhdGEtbi1jc3NcIik7XG4gICAgICAgIHN0eWxlU2hlZXRzLmZvckVhY2goKHBhcmFtKT0+e1xuICAgICAgICAgICAgbGV0IHsgaHJlZiAsIHRleHQgIH0gPSBwYXJhbTtcbiAgICAgICAgICAgIGlmICghY3VycmVudEhyZWZzLmhhcyhocmVmKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlVGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgICAgICAgICAgIHN0eWxlVGFnLnNldEF0dHJpYnV0ZShcImRhdGEtbi1ocmVmXCIsIGhyZWYpO1xuICAgICAgICAgICAgICAgIHN0eWxlVGFnLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIFwieFwiKTtcbiAgICAgICAgICAgICAgICBpZiAobm9uY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVUYWcuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgbm9uY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlVGFnKTtcbiAgICAgICAgICAgICAgICBzdHlsZVRhZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25IZWFkQ29tbWl0KCkge1xuICAgICAgICBpZiAoLy8gV2UgdXNlIGBzdHlsZS1sb2FkZXJgIGluIGRldmVsb3BtZW50LCBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nXG4gICAgICAgIC8vIHVubGVzcyB3ZSdyZSBpbiBwcm9kdWN0aW9uOlxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgJiYgLy8gV2UgY2FuIHNraXAgdGhpcyBkdXJpbmcgaHlkcmF0aW9uLiBSdW5uaW5nIGl0IHdvbnQgY2F1c2UgYW55IGhhcm0sIGJ1dFxuICAgICAgICAvLyB3ZSBtYXkgYXMgd2VsbCBzYXZlIHRoZSBDUFUgY3ljbGVzOlxuICAgICAgICBzdHlsZVNoZWV0cyAmJiAvLyBFbnN1cmUgdGhpcyByZW5kZXIgd2FzIG5vdCBjYW5jZWxlZFxuICAgICAgICAhY2FuY2VsZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2lyZWRIcmVmcyA9IG5ldyBTZXQoc3R5bGVTaGVldHMubWFwKChzKT0+cy5ocmVmKSk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U3R5bGVUYWdzID0gbG9vc2VUb0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJzdHlsZVtkYXRhLW4taHJlZl1cIikpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEhyZWZzID0gY3VycmVudFN0eWxlVGFncy5tYXAoKHRhZyk9PnRhZy5nZXRBdHRyaWJ1dGUoXCJkYXRhLW4taHJlZlwiKSk7XG4gICAgICAgICAgICAvLyBUb2dnbGUgYDxzdHlsZT5gIHRhZ3Mgb24gb3Igb2ZmIGRlcGVuZGluZyBvbiBpZiB0aGV5J3JlIG5lZWRlZDpcbiAgICAgICAgICAgIGZvcihsZXQgaWR4ID0gMDsgaWR4IDwgY3VycmVudEhyZWZzLmxlbmd0aDsgKytpZHgpe1xuICAgICAgICAgICAgICAgIGlmIChkZXNpcmVkSHJlZnMuaGFzKGN1cnJlbnRIcmVmc1tpZHhdKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3R5bGVUYWdzW2lkeF0ucmVtb3ZlQXR0cmlidXRlKFwibWVkaWFcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0eWxlVGFnc1tpZHhdLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIFwieFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW9yZGVyIHN0eWxlcyBpbnRvIGludGVuZGVkIG9yZGVyOlxuICAgICAgICAgICAgbGV0IHJlZmVyZW5jZU5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibm9zY3JpcHRbZGF0YS1uLWNzc11cIik7XG4gICAgICAgICAgICBpZiAoLy8gVGhpcyBzaG91bGQgYmUgYW4gaW52YXJpYW50OlxuICAgICAgICAgICAgcmVmZXJlbmNlTm9kZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzLmZvckVhY2goKHBhcmFtKT0+e1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyBocmVmICB9ID0gcGFyYW07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFRhZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlW2RhdGEtbi1ocmVmPVwiJyArIGhyZWYgKyAnXCJdJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgvLyBUaGlzIHNob3VsZCBiZSBhbiBpbnZhcmlhbnQ6XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0YXJnZXRUYWcsIHJlZmVyZW5jZU5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZSA9IHRhcmdldFRhZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmluYWxseSwgY2xlYW4gdXAgc2VydmVyIHJlbmRlcmVkIHN0eWxlc2hlZXRzOlxuICAgICAgICAgICAgbG9vc2VUb0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rW2RhdGEtbi1wXVwiKSkuZm9yRWFjaCgoZWwpPT57XG4gICAgICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQuc2Nyb2xsKSB7XG4gICAgICAgICAgICBjb25zdCB7IHggLCB5ICB9ID0gaW5wdXQuc2Nyb2xsO1xuICAgICAgICAgICAgKDAsIF9oYW5kbGVzbW9vdGhzY3JvbGwuaGFuZGxlU21vb3RoU2Nyb2xsKSgoKT0+e1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbyh4LCB5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUm9vdENvbW1pdCgpIHtcbiAgICAgICAgcmVzb2x2ZVByb21pc2UoKTtcbiAgICB9XG4gICAgb25TdGFydCgpO1xuICAgIGNvbnN0IGVsZW0gPSAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChIZWFkLCB7XG4gICAgICAgIGNhbGxiYWNrOiBvbkhlYWRDb21taXRcbiAgICB9KSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEFwcENvbnRhaW5lciwgbnVsbCwgcmVuZGVyQXBwKEFwcCwgYXBwUHJvcHMpLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3BvcnRhbC5Qb3J0YWwsIHtcbiAgICAgICAgdHlwZTogXCJuZXh0LXJvdXRlLWFubm91bmNlclwiXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yb3V0ZWFubm91bmNlci5Sb3V0ZUFubm91bmNlciwgbnVsbCkpKSk7XG4gICAgLy8gV2UgY2F0Y2ggcnVudGltZSBlcnJvcnMgdXNpbmcgY29tcG9uZW50RGlkQ2F0Y2ggd2hpY2ggd2lsbCB0cmlnZ2VyIHJlbmRlckVycm9yXG4gICAgcmVuZGVyUmVhY3RFbGVtZW50KGFwcEVsZW1lbnQsIChjYWxsYmFjayk9Pi8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChSb290LCB7XG4gICAgICAgICAgICBjYWxsYmFja3M6IFtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBvblJvb3RDb21taXRcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSwgcHJvY2Vzcy5lbnYuX19ORVhUX1NUUklDVF9NT0RFID8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LlN0cmljdE1vZGUsIG51bGwsIGVsZW0pIDogZWxlbSkpO1xuICAgIHJldHVybiByZW5kZXJQcm9taXNlO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVuZGVyKHJlbmRlcmluZ1Byb3BzKSB7XG4gICAgaWYgKHJlbmRlcmluZ1Byb3BzLmVycikge1xuICAgICAgICBhd2FpdCByZW5kZXJFcnJvcihyZW5kZXJpbmdQcm9wcyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZG9SZW5kZXIocmVuZGVyaW5nUHJvcHMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCByZW5kZXJFcnIgPSAoMCwgX2lzZXJyb3IuZ2V0UHJvcGVyRXJyb3IpKGVycik7XG4gICAgICAgIC8vIGJ1YmJsZSB1cCBjYW5jZWxhdGlvbiBlcnJvcnNcbiAgICAgICAgaWYgKHJlbmRlckVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHRocm93IHJlbmRlckVycjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICAgICAgLy8gRW5zdXJlIHRoaXMgZXJyb3IgaXMgZGlzcGxheWVkIGluIHRoZSBvdmVybGF5IGluIGRldmVsb3BtZW50XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgdGhyb3cgcmVuZGVyRXJyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcmVuZGVyRXJyb3Ioe1xuICAgICAgICAgICAgLi4ucmVuZGVyaW5nUHJvcHMsXG4gICAgICAgICAgICBlcnI6IHJlbmRlckVyclxuICAgICAgICB9KTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBoeWRyYXRlKG9wdHMpIHtcbiAgICBsZXQgaW5pdGlhbEVyciA9IGluaXRpYWxEYXRhLmVycjtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBhcHBFbnRyeXBvaW50ID0gYXdhaXQgcGFnZUxvYWRlci5yb3V0ZUxvYWRlci53aGVuRW50cnlwb2ludChcIi9fYXBwXCIpO1xuICAgICAgICBpZiAoXCJlcnJvclwiIGluIGFwcEVudHJ5cG9pbnQpIHtcbiAgICAgICAgICAgIHRocm93IGFwcEVudHJ5cG9pbnQuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjb21wb25lbnQ6IGFwcCAsIGV4cG9ydHM6IG1vZCAgfSA9IGFwcEVudHJ5cG9pbnQ7XG4gICAgICAgIENhY2hlZEFwcCA9IGFwcDtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QucmVwb3J0V2ViVml0YWxzKSB7XG4gICAgICAgICAgICBvblBlcmZFbnRyeSA9IChwYXJhbSk9PntcbiAgICAgICAgICAgICAgICBsZXQgeyBpZCAsIG5hbWUgLCBzdGFydFRpbWUgLCB2YWx1ZSAsIGR1cmF0aW9uICwgZW50cnlUeXBlICwgZW50cmllcyAsIGF0dHJpYnV0aW9uICB9ID0gcGFyYW07XG4gICAgICAgICAgICAgICAgLy8gQ29tYmluZXMgdGltZXN0YW1wIHdpdGggcmFuZG9tIG51bWJlciBmb3IgdW5pcXVlIElEXG4gICAgICAgICAgICAgICAgY29uc3QgdW5pcXVlSUQgPSBEYXRlLm5vdygpICsgXCItXCIgKyAoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKDllMTIgLSAxKSkgKyAxZTEyKTtcbiAgICAgICAgICAgICAgICBsZXQgcGVyZlN0YXJ0RW50cnk7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJpZXMgJiYgZW50cmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVyZlN0YXJ0RW50cnkgPSBlbnRyaWVzWzBdLnN0YXJ0VGltZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgd2ViVml0YWxzID0ge1xuICAgICAgICAgICAgICAgICAgICBpZDogaWQgfHwgdW5pcXVlSUQsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lIHx8IHBlcmZTdGFydEVudHJ5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUgPT0gbnVsbCA/IGR1cmF0aW9uIDogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBlbnRyeVR5cGUgPT09IFwibWFya1wiIHx8IGVudHJ5VHlwZSA9PT0gXCJtZWFzdXJlXCIgPyBcImN1c3RvbVwiIDogXCJ3ZWItdml0YWxcIlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHdlYlZpdGFscy5hdHRyaWJ1dGlvbiA9IGF0dHJpYnV0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb2QucmVwb3J0V2ViVml0YWxzKHdlYlZpdGFscyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhZ2VFbnRyeXBvaW50ID0gLy8gVGhlIGRldiBzZXJ2ZXIgZmFpbHMgdG8gc2VydmUgc2NyaXB0IGFzc2V0cyB3aGVuIHRoZXJlJ3MgYSBoeWRyYXRpb25cbiAgICAgICAgLy8gZXJyb3IsIHNvIHdlIG5lZWQgdG8gc2tpcCB3YWl0aW5nIGZvciB0aGUgZW50cnlwb2ludC5cbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIiAmJiBpbml0aWFsRGF0YS5lcnIgPyB7XG4gICAgICAgICAgICBlcnJvcjogaW5pdGlhbERhdGEuZXJyXG4gICAgICAgIH0gOiBhd2FpdCBwYWdlTG9hZGVyLnJvdXRlTG9hZGVyLndoZW5FbnRyeXBvaW50KGluaXRpYWxEYXRhLnBhZ2UpO1xuICAgICAgICBpZiAoXCJlcnJvclwiIGluIHBhZ2VFbnRyeXBvaW50KSB7XG4gICAgICAgICAgICB0aHJvdyBwYWdlRW50cnlwb2ludC5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBDYWNoZWRDb21wb25lbnQgPSBwYWdlRW50cnlwb2ludC5jb21wb25lbnQ7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlICB9ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdC1pc1wiKTtcbiAgICAgICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKENhY2hlZENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBkZWZhdWx0IGV4cG9ydCBpcyBub3QgYSBSZWFjdCBDb21wb25lbnQgaW4gcGFnZTogXCInICsgaW5pdGlhbERhdGEucGFnZSArICdcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gVGhpcyBjYXRjaGVzIGVycm9ycyBsaWtlIHRocm93aW5nIGluIHRoZSB0b3AgbGV2ZWwgb2YgYSBtb2R1bGVcbiAgICAgICAgaW5pdGlhbEVyciA9ICgwLCBfaXNlcnJvci5nZXRQcm9wZXJFcnJvcikoZXJyb3IpO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICBjb25zdCB7IGdldFNlcnZlckVycm9yICB9ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9kaXN0L2NsaWVudFwiKTtcbiAgICAgICAgLy8gU2VydmVyLXNpZGUgcnVudGltZSBlcnJvcnMgbmVlZCB0byBiZSByZS10aHJvd24gb24gdGhlIGNsaWVudC1zaWRlIHNvXG4gICAgICAgIC8vIHRoYXQgdGhlIG92ZXJsYXkgaXMgcmVuZGVyZWQuXG4gICAgICAgIGlmIChpbml0aWFsRXJyKSB7XG4gICAgICAgICAgICBpZiAoaW5pdGlhbEVyciA9PT0gaW5pdGlhbERhdGEuZXJyKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIG5ldyBlcnJvciBvYmplY3QuIFdlIGB0aHJvd2AgaXQgYmVjYXVzZSBzb21lIGJyb3dzZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIHNldCB0aGUgYHN0YWNrYCB3aGVuIHRocm93biwgYW5kIHdlIHdhbnQgdG8gZW5zdXJlIG91cnMgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBvdmVycmlkZGVuIHdoZW4gd2UgcmUtdGhyb3cgaXQgYmVsb3cuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaW5pdGlhbEVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBpbml0aWFsRXJyLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLnN0YWNrID0gaW5pdGlhbEVyci5zdGFjaztcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZ2V0U2VydmVyRXJyb3IoZXJyb3IsIGluaXRpYWxFcnIuc291cmNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbml0aWFsRXJyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh3aW5kb3cuX19ORVhUX1BSRUxPQURSRUFEWSkge1xuICAgICAgICBhd2FpdCB3aW5kb3cuX19ORVhUX1BSRUxPQURSRUFEWShpbml0aWFsRGF0YS5keW5hbWljSWRzKTtcbiAgICB9XG4gICAgcm91dGVyID0gKDAsIF9yb3V0ZXIuY3JlYXRlUm91dGVyKShpbml0aWFsRGF0YS5wYWdlLCBpbml0aWFsRGF0YS5xdWVyeSwgYXNQYXRoLCB7XG4gICAgICAgIGluaXRpYWxQcm9wczogaW5pdGlhbERhdGEucHJvcHMsXG4gICAgICAgIHBhZ2VMb2FkZXIsXG4gICAgICAgIEFwcDogQ2FjaGVkQXBwLFxuICAgICAgICBDb21wb25lbnQ6IENhY2hlZENvbXBvbmVudCxcbiAgICAgICAgd3JhcEFwcCxcbiAgICAgICAgZXJyOiBpbml0aWFsRXJyLFxuICAgICAgICBpc0ZhbGxiYWNrOiBCb29sZWFuKGluaXRpYWxEYXRhLmlzRmFsbGJhY2spLFxuICAgICAgICBzdWJzY3JpcHRpb246IChpbmZvLCBBcHAsIHNjcm9sbCk9PnJlbmRlcihPYmplY3QuYXNzaWduKHt9LCBpbmZvLCB7XG4gICAgICAgICAgICAgICAgQXBwLFxuICAgICAgICAgICAgICAgIHNjcm9sbFxuICAgICAgICAgICAgfSkpLFxuICAgICAgICBsb2NhbGU6IGluaXRpYWxEYXRhLmxvY2FsZSxcbiAgICAgICAgbG9jYWxlczogaW5pdGlhbERhdGEubG9jYWxlcyxcbiAgICAgICAgZGVmYXVsdExvY2FsZSxcbiAgICAgICAgZG9tYWluTG9jYWxlczogaW5pdGlhbERhdGEuZG9tYWluTG9jYWxlcyxcbiAgICAgICAgaXNQcmV2aWV3OiBpbml0aWFsRGF0YS5pc1ByZXZpZXdcbiAgICB9KTtcbiAgICBpbml0aWFsTWF0Y2hlc01pZGRsZXdhcmUgPSBhd2FpdCByb3V0ZXIuX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2U7XG4gICAgY29uc3QgcmVuZGVyQ3R4ID0ge1xuICAgICAgICBBcHA6IENhY2hlZEFwcCxcbiAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgQ29tcG9uZW50OiBDYWNoZWRDb21wb25lbnQsXG4gICAgICAgIHByb3BzOiBpbml0aWFsRGF0YS5wcm9wcyxcbiAgICAgICAgZXJyOiBpbml0aWFsRXJyXG4gICAgfTtcbiAgICBpZiAob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5iZWZvcmVSZW5kZXIpIHtcbiAgICAgICAgYXdhaXQgb3B0cy5iZWZvcmVSZW5kZXIoKTtcbiAgICB9XG4gICAgcmVuZGVyKHJlbmRlckN0eCk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsInZlcnNpb24iLCJyb3V0ZXIiLCJlbWl0dGVyIiwiaW5pdGlhbGl6ZSIsImh5ZHJhdGUiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiX3JlYWN0IiwiXyIsIl9jbGllbnQiLCJfaGVhZG1hbmFnZXJjb250ZXh0IiwiX21pdHQiLCJfcm91dGVyY29udGV4dCIsIl9oYW5kbGVzbW9vdGhzY3JvbGwiLCJfaXNkeW5hbWljIiwiX3F1ZXJ5c3RyaW5nIiwiX3J1bnRpbWVjb25maWciLCJfdXRpbHMiLCJfcG9ydGFsIiwiX2hlYWRtYW5hZ2VyIiwiX3BhZ2Vsb2FkZXIiLCJfcGVyZm9ybWFuY2VyZWxheWVyIiwiX3JvdXRlYW5ub3VuY2VyIiwiX3JvdXRlciIsIl9pc2Vycm9yIiwiX2ltYWdlY29uZmlnY29udGV4dCIsIl9yZW1vdmViYXNlcGF0aCIsIl9oYXNiYXNlcGF0aCIsIl9hcHByb3V0ZXJjb250ZXh0IiwiX2FkYXB0ZXJzIiwiX2hvb2tzY2xpZW50Y29udGV4dCIsIl9vbnJlY292ZXJhYmxlZXJyb3IiLCJfdHJhY2VyIiwiX3JlcG9ydHRvc29ja2V0IiwiZGVmYXVsdCIsImxvb3NlVG9BcnJheSIsImlucHV0Iiwic2xpY2UiLCJjYWxsIiwiaW5pdGlhbERhdGEiLCJkZWZhdWx0TG9jYWxlIiwidW5kZWZpbmVkIiwiYXNQYXRoIiwicGFnZUxvYWRlciIsImFwcEVsZW1lbnQiLCJoZWFkTWFuYWdlciIsImluaXRpYWxNYXRjaGVzTWlkZGxld2FyZSIsImxhc3RBcHBQcm9wcyIsImxhc3RSZW5kZXJSZWplY3QiLCJ3ZWJwYWNrSE1SIiwiQ2FjaGVkQXBwIiwib25QZXJmRW50cnkiLCJDYWNoZWRDb21wb25lbnQiLCJDb250YWluZXIiLCJDb21wb25lbnQiLCJjb21wb25lbnREaWRDYXRjaCIsImNvbXBvbmVudEVyciIsImluZm8iLCJwcm9wcyIsImZuIiwiY29tcG9uZW50RGlkTW91bnQiLCJzY3JvbGxUb0hhc2giLCJpc1NzciIsImlzRmFsbGJhY2siLCJuZXh0RXhwb3J0IiwiaXNEeW5hbWljUm91dGUiLCJwYXRobmFtZSIsImxvY2F0aW9uIiwic2VhcmNoIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9IQVNfUkVXUklURVMiLCJfX05fU1NHIiwicmVwbGFjZSIsIlN0cmluZyIsImFzc2lnbiIsInVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMiLCJxdWVyeSIsIlVSTFNlYXJjaFBhcmFtcyIsIl9oIiwic2hhbGxvdyIsImNhdGNoIiwiZXJyIiwiY2FuY2VsbGVkIiwiY29tcG9uZW50RGlkVXBkYXRlIiwiaGFzaCIsInN1YnN0cmluZyIsImVsIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsInNldFRpbWVvdXQiLCJzY3JvbGxJbnRvVmlldyIsInJlbmRlciIsImNoaWxkcmVuIiwiUmVhY3REZXZPdmVybGF5IiwiY3JlYXRlRWxlbWVudCIsIm9wdHMiLCJvblNwYW5FbmQiLCJKU09OIiwicGFyc2UiLCJ0ZXh0Q29udGVudCIsIndpbmRvdyIsIl9fTkVYVF9EQVRBX18iLCJwcmVmaXgiLCJhc3NldFByZWZpeCIsInNlbGYiLCJfX25leHRfc2V0X3B1YmxpY19wYXRoX18iLCJzZXRDb25maWciLCJzZXJ2ZXJSdW50aW1lQ29uZmlnIiwicHVibGljUnVudGltZUNvbmZpZyIsInJ1bnRpbWVDb25maWciLCJnZXRVUkwiLCJoYXNCYXNlUGF0aCIsInJlbW92ZUJhc2VQYXRoIiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJkZXRlY3REb21haW5Mb2NhbGUiLCJwYXJzZVJlbGF0aXZlVXJsIiwiZm9ybWF0VXJsIiwibG9jYWxlcyIsInBhcnNlZEFzIiwibG9jYWxlUGF0aFJlc3VsdCIsImRldGVjdGVkTG9jYWxlIiwibG9jYWxlIiwiZGV0ZWN0ZWREb21haW4iLCJfX05FWFRfSTE4Tl9ET01BSU5TIiwiaG9zdG5hbWUiLCJzY3JpcHRMb2FkZXIiLCJpbml0U2NyaXB0TG9hZGVyIiwiYnVpbGRJZCIsInJlZ2lzdGVyIiwicGFyYW0iLCJyIiwiZiIsInJvdXRlTG9hZGVyIiwib25FbnRyeXBvaW50IiwiX19ORVhUX1AiLCJtYXAiLCJwIiwicHVzaCIsImdldElzU3NyIiwicmVuZGVyQXBwIiwiQXBwIiwiYXBwUHJvcHMiLCJBcHBDb250YWluZXIiLCJhZGFwdGVkRm9yQXBwUm91dGVyIiwidXNlTWVtbyIsImFkYXB0Rm9yQXBwUm91dGVySW5zdGFuY2UiLCJfc2VsZl9fX05FWFRfREFUQV9fX2F1dG9FeHBvcnQiLCJlcnJvciIsInJlbmRlckVycm9yIiwiY29uc29sZSIsIkFwcFJvdXRlckNvbnRleHQiLCJQcm92aWRlciIsIlNlYXJjaFBhcmFtc0NvbnRleHQiLCJhZGFwdEZvclNlYXJjaFBhcmFtcyIsIlBhdGhuYW1lQ29udGV4dFByb3ZpZGVyQWRhcHRlciIsImlzQXV0b0V4cG9ydCIsImF1dG9FeHBvcnQiLCJSb3V0ZXJDb250ZXh0IiwibWFrZVB1YmxpY1JvdXRlckluc3RhbmNlIiwiSGVhZE1hbmFnZXJDb250ZXh0IiwiSW1hZ2VDb25maWdDb250ZXh0IiwiX19ORVhUX0lNQUdFX09QVFMiLCJ3cmFwQXBwIiwid3JhcHBlZEFwcFByb3BzIiwicmVuZGVyRXJyb3JQcm9wcyIsIm9uVW5yZWNvdmVyYWJsZUVycm9yIiwiZG9SZW5kZXIiLCJzdHlsZVNoZWV0cyIsImxvYWRQYWdlIiwidGhlbiIsInBhZ2UiLCJFcnJvckNvbXBvbmVudCIsImVycm9yTW9kdWxlIiwiYXBwTW9kdWxlIiwibSIsIl9yZW5kZXJFcnJvclByb3BzX3Byb3BzIiwiQXBwVHJlZSIsImFwcEN0eCIsImN0eCIsIlByb21pc2UiLCJyZXNvbHZlIiwibG9hZEdldEluaXRpYWxQcm9wcyIsImluaXRQcm9wcyIsIkhlYWQiLCJjYWxsYmFjayIsInVzZUxheW91dEVmZmVjdCIsInJlYWN0Um9vdCIsInNob3VsZEh5ZHJhdGUiLCJjbGVhck1hcmtzIiwiZm9yRWFjaCIsIm1hcmsiLCJwZXJmb3JtYW5jZSIsIm1hcmtIeWRyYXRlQ29tcGxldGUiLCJTVCIsImJlZm9yZUh5ZHJhdGlvbk1lYXN1cmUiLCJtZWFzdXJlIiwiaHlkcmF0aW9uTWVhc3VyZSIsInN0YXJ0U3BhbiIsInN0YXJ0VGltZSIsInRpbWVPcmlnaW4iLCJhdHRyaWJ1dGVzIiwiZW5kIiwiZHVyYXRpb24iLCJnZXRFbnRyaWVzQnlOYW1lIiwibWFya1JlbmRlckNvbXBsZXRlIiwibmF2U3RhcnRFbnRyaWVzIiwibGVuZ3RoIiwiY2xlYXJNZWFzdXJlcyIsInJlbmRlclJlYWN0RWxlbWVudCIsImRvbUVsIiwicmVhY3RFbCIsImh5ZHJhdGVSb290Iiwib25SZWNvdmVyYWJsZUVycm9yIiwic3RhcnRUcmFuc2l0aW9uIiwiUm9vdCIsImNhbGxiYWNrcyIsInVzZUVmZmVjdCIsIl9fTkVYVF9URVNUX01PREUiLCJfX05FWFRfSFlEUkFURUQiLCJfX05FWFRfSFlEUkFURURfQ0IiLCJjYW5jZWxlZCIsInJlc29sdmVQcm9taXNlIiwicmVuZGVyUHJvbWlzZSIsInJlamVjdCIsIkVycm9yIiwib25TdGFydCIsImN1cnJlbnRTdHlsZVRhZ3MiLCJxdWVyeVNlbGVjdG9yQWxsIiwiY3VycmVudEhyZWZzIiwiU2V0IiwidGFnIiwiZ2V0QXR0cmlidXRlIiwibm9zY3JpcHQiLCJxdWVyeVNlbGVjdG9yIiwibm9uY2UiLCJocmVmIiwidGV4dCIsImhhcyIsInN0eWxlVGFnIiwic2V0QXR0cmlidXRlIiwiaGVhZCIsImFwcGVuZENoaWxkIiwiY3JlYXRlVGV4dE5vZGUiLCJvbkhlYWRDb21taXQiLCJkZXNpcmVkSHJlZnMiLCJzIiwiaWR4IiwicmVtb3ZlQXR0cmlidXRlIiwicmVmZXJlbmNlTm9kZSIsInRhcmdldFRhZyIsInBhcmVudE5vZGUiLCJpbnNlcnRCZWZvcmUiLCJuZXh0U2libGluZyIsInJlbW92ZUNoaWxkIiwic2Nyb2xsIiwieCIsInkiLCJoYW5kbGVTbW9vdGhTY3JvbGwiLCJzY3JvbGxUbyIsIm9uUm9vdENvbW1pdCIsImVsZW0iLCJGcmFnbWVudCIsIlBvcnRhbCIsInR5cGUiLCJSb3V0ZUFubm91bmNlciIsIl9fTkVYVF9TVFJJQ1RfTU9ERSIsIlN0cmljdE1vZGUiLCJyZW5kZXJpbmdQcm9wcyIsInJlbmRlckVyciIsImdldFByb3BlckVycm9yIiwiaW5pdGlhbEVyciIsImFwcEVudHJ5cG9pbnQiLCJ3aGVuRW50cnlwb2ludCIsImNvbXBvbmVudCIsImFwcCIsIm1vZCIsInJlcG9ydFdlYlZpdGFscyIsImlkIiwiZW50cnlUeXBlIiwiZW50cmllcyIsImF0dHJpYnV0aW9uIiwidW5pcXVlSUQiLCJEYXRlIiwibm93IiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwicGVyZlN0YXJ0RW50cnkiLCJ3ZWJWaXRhbHMiLCJsYWJlbCIsInBhZ2VFbnRyeXBvaW50IiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwiZ2V0U2VydmVyRXJyb3IiLCJtZXNzYWdlIiwiZSIsInN0YWNrIiwic291cmNlIiwiX19ORVhUX1BSRUxPQURSRUFEWSIsImR5bmFtaWNJZHMiLCJjcmVhdGVSb3V0ZXIiLCJpbml0aWFsUHJvcHMiLCJCb29sZWFuIiwic3Vic2NyaXB0aW9uIiwiZG9tYWluTG9jYWxlcyIsImlzUHJldmlldyIsIl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlIiwicmVuZGVyQ3R4IiwiaW5pdGlhbCIsImJlZm9yZVJlbmRlciIsIl9fZXNNb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/next-dev.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/client/next-dev.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// TODO: Remove use of `any` type.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\n__webpack_require__(/*! ./webpack */ \"./node_modules/next/dist/client/webpack.js\");\nconst _ = __webpack_require__(/*! ./ */ \"./node_modules/next/dist/client/index.js\");\nconst _ondemandentriesclient = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./dev/on-demand-entries-client */ \"./node_modules/next/dist/client/dev/on-demand-entries-client.js\"));\nconst _webpackhotmiddlewareclient = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./dev/webpack-hot-middleware-client */ \"./node_modules/next/dist/client/dev/webpack-hot-middleware-client.js\"));\nconst _devbuildwatcher = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./dev/dev-build-watcher */ \"./node_modules/next/dist/client/dev/dev-build-watcher.js\"));\nconst _fouc = __webpack_require__(/*! ./dev/fouc */ \"./node_modules/next/dist/client/dev/fouc.js\");\nconst _websocket = __webpack_require__(/*! ./dev/error-overlay/websocket */ \"./node_modules/next/dist/client/dev/error-overlay/websocket.js\");\nconst _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\n__webpack_require__(/*! ./setup-hydration-warning */ \"./node_modules/next/dist/client/setup-hydration-warning.js\");\nwindow.next = {\n    version: _.version,\n    // router is initialized later so it has to be live-binded\n    get router () {\n        return _.router;\n    },\n    emitter: _.emitter\n};\nconst webpackHMR = (0, _webpackhotmiddlewareclient.default)();\n(0, _.initialize)({\n    webpackHMR\n}).then((param)=>{\n    let { assetPrefix } = param;\n    (0, _websocket.connectHMR)({\n        assetPrefix,\n        path: \"/_next/webpack-hmr\"\n    });\n    return (0, _.hydrate)({\n        beforeRender: _fouc.displayContent\n    }).then(()=>{\n        (0, _ondemandentriesclient.default)();\n        let buildIndicatorHandler = ()=>{};\n        function devPagesHmrListener(event) {\n            let payload;\n            try {\n                payload = JSON.parse(event.data);\n            } catch (e) {}\n            if (payload.event === \"server-error\" && payload.errorJSON) {\n                const { stack, message } = JSON.parse(payload.errorJSON);\n                const error = new Error(message);\n                error.stack = stack;\n                throw error;\n            } else if (payload.action === \"reloadPage\") {\n                window.location.reload();\n            } else if (payload.action === \"devPagesManifestUpdate\") {\n                fetch(\"\" + assetPrefix + \"/_next/static/development/_devPagesManifest.json\").then((res)=>res.json()).then((manifest)=>{\n                    window.__DEV_PAGES_MANIFEST = manifest;\n                }).catch((err)=>{\n                    console.log(\"Failed to fetch devPagesManifest\", err);\n                });\n            } else if (payload.event === \"middlewareChanges\") {\n                return window.location.reload();\n            } else if (payload.event === \"serverOnlyChanges\") {\n                const { pages } = payload;\n                // Make sure to reload when the dev-overlay is showing for an\n                // API route\n                if (pages.includes(_.router.query.__NEXT_PAGE)) {\n                    return window.location.reload();\n                }\n                if (!_.router.clc && pages.includes(_.router.pathname)) {\n                    console.log(\"Refreshing page data due to server-side change\");\n                    buildIndicatorHandler(\"building\");\n                    const clearIndicator = ()=>buildIndicatorHandler(\"built\");\n                    _.router.replace(_.router.pathname + \"?\" + String((0, _querystring.assign)((0, _querystring.urlQueryToSearchParams)(_.router.query), new URLSearchParams(location.search))), _.router.asPath, {\n                        scroll: false\n                    }).catch(()=>{\n                        // trigger hard reload when failing to refresh data\n                        // to show error overlay properly\n                        location.reload();\n                    }).finally(clearIndicator);\n                }\n            }\n        }\n        (0, _websocket.addMessageListener)(devPagesHmrListener);\n        if (true) {\n            (0, _devbuildwatcher.default)((handler)=>{\n                buildIndicatorHandler = handler;\n            }, \"bottom-right\");\n        }\n    });\n}).catch((err)=>{\n    console.error(\"Error was not caught\", err);\n});\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=next-dev.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9uZXh0LWRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQ0FBa0M7QUFDckI7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQyw0R0FBeUM7QUFDbEZBLG1CQUFPQSxDQUFDLDZEQUFXO0FBQ25CLE1BQU1DLElBQUlELG1CQUFPQSxDQUFDLG9EQUFJO0FBQ3RCLE1BQU1FLHlCQUF5QixXQUFXLEdBQUdILHlCQUF5QkUsQ0FBQyxDQUFDRCxtQkFBT0EsQ0FBQyx1R0FBZ0M7QUFDaEgsTUFBTUcsOEJBQThCLFdBQVcsR0FBR0oseUJBQXlCRSxDQUFDLENBQUNELG1CQUFPQSxDQUFDLGlIQUFxQztBQUMxSCxNQUFNSSxtQkFBbUIsV0FBVyxHQUFHTCx5QkFBeUJFLENBQUMsQ0FBQ0QsbUJBQU9BLENBQUMseUZBQXlCO0FBQ25HLE1BQU1LLFFBQVFMLG1CQUFPQSxDQUFDLCtEQUFZO0FBQ2xDLE1BQU1NLGFBQWFOLG1CQUFPQSxDQUFDLHFHQUErQjtBQUMxRCxNQUFNTyxlQUFlUCxtQkFBT0EsQ0FBQywrR0FBd0M7QUFDckVBLG1CQUFPQSxDQUFDLDZGQUEyQjtBQUNuQ1EsT0FBT0MsSUFBSSxHQUFHO0lBQ1ZDLFNBQVNULEVBQUVTLE9BQU87SUFDbEIsMERBQTBEO0lBQzFELElBQUlDLFVBQVU7UUFDVixPQUFPVixFQUFFVSxNQUFNO0lBQ25CO0lBQ0FDLFNBQVNYLEVBQUVXLE9BQU87QUFDdEI7QUFDQSxNQUFNQyxhQUFhLENBQUMsR0FBR1YsNEJBQTRCVyxPQUFPO0FBQ3pELElBQUdiLEVBQUVjLFVBQVUsRUFBRTtJQUNkRjtBQUNKLEdBQUdHLElBQUksQ0FBQyxDQUFDQztJQUNMLElBQUksRUFBRUMsV0FBVyxFQUFHLEdBQUdEO0lBQ3RCLElBQUdYLFdBQVdhLFVBQVUsRUFBRTtRQUN2QkQ7UUFDQUUsTUFBTTtJQUNWO0lBQ0EsT0FB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QUFRaUIsT0FBTyxLQUFLLFlBQVlqQixRQUFRaUIsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPakIsUUFBUWlCLE9BQU8sQ0FBQ3lELFVBQVUsS0FBSyxhQUFhO0lBQ3JLNUUsT0FBT0MsY0FBYyxDQUFDQyxRQUFRaUIsT0FBTyxFQUFFLGNBQWM7UUFBRWhCLE9BQU87SUFBSztJQUNuRUgsT0FBTytELE1BQU0sQ0FBQzdELFFBQVFpQixPQUFPLEVBQUVqQjtJQUMvQjJFLE9BQU8zRSxPQUFPLEdBQUdBLFFBQVFpQixPQUFPO0FBQ2xDLEVBRUEsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L25leHQtZGV2LmpzPzM1MTUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVE9ETzogUmVtb3ZlIHVzZSBvZiBgYW55YCB0eXBlLlxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xucmVxdWlyZShcIi4vd2VicGFja1wiKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwiLi9cIik7XG5jb25zdCBfb25kZW1hbmRlbnRyaWVzY2xpZW50ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwiLi9kZXYvb24tZGVtYW5kLWVudHJpZXMtY2xpZW50XCIpKTtcbmNvbnN0IF93ZWJwYWNraG90bWlkZGxld2FyZWNsaWVudCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4vZGV2L3dlYnBhY2staG90LW1pZGRsZXdhcmUtY2xpZW50XCIpKTtcbmNvbnN0IF9kZXZidWlsZHdhdGNoZXIgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCIuL2Rldi9kZXYtYnVpbGQtd2F0Y2hlclwiKSk7XG5jb25zdCBfZm91YyA9IHJlcXVpcmUoXCIuL2Rldi9mb3VjXCIpO1xuY29uc3QgX3dlYnNvY2tldCA9IHJlcXVpcmUoXCIuL2Rldi9lcnJvci1vdmVybGF5L3dlYnNvY2tldFwiKTtcbmNvbnN0IF9xdWVyeXN0cmluZyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9xdWVyeXN0cmluZ1wiKTtcbnJlcXVpcmUoXCIuL3NldHVwLWh5ZHJhdGlvbi13YXJuaW5nXCIpO1xud2luZG93Lm5leHQgPSB7XG4gICAgdmVyc2lvbjogXy52ZXJzaW9uLFxuICAgIC8vIHJvdXRlciBpcyBpbml0aWFsaXplZCBsYXRlciBzbyBpdCBoYXMgdG8gYmUgbGl2ZS1iaW5kZWRcbiAgICBnZXQgcm91dGVyICgpIHtcbiAgICAgICAgcmV0dXJuIF8ucm91dGVyO1xuICAgIH0sXG4gICAgZW1pdHRlcjogXy5lbWl0dGVyXG59O1xuY29uc3Qgd2VicGFja0hNUiA9ICgwLCBfd2VicGFja2hvdG1pZGRsZXdhcmVjbGllbnQuZGVmYXVsdCkoKTtcbigwLCBfLmluaXRpYWxpemUpKHtcbiAgICB3ZWJwYWNrSE1SXG59KS50aGVuKChwYXJhbSk9PntcbiAgICBsZXQgeyBhc3NldFByZWZpeCAgfSA9IHBhcmFtO1xuICAgICgwLCBfd2Vic29ja2V0LmNvbm5lY3RITVIpKHtcbiAgICAgICAgYXNzZXRQcmVmaXgsXG4gICAgICAgIHBhdGg6IFwiL19uZXh0L3dlYnBhY2staG1yXCJcbiAgICB9KTtcbiAgICByZXR1cm4gKDAsIF8uaHlkcmF0ZSkoe1xuICAgICAgICBiZWZvcmVSZW5kZXI6IF9mb3VjLmRpc3BsYXlDb250ZW50XG4gICAgfSkudGhlbigoKT0+e1xuICAgICAgICAoMCwgX29uZGVtYW5kZW50cmllc2NsaWVudC5kZWZhdWx0KSgpO1xuICAgICAgICBsZXQgYnVpbGRJbmRpY2F0b3JIYW5kbGVyID0gKCk9Pnt9O1xuICAgICAgICBmdW5jdGlvbiBkZXZQYWdlc0htckxpc3RlbmVyKGV2ZW50KSB7XG4gICAgICAgICAgICBsZXQgcGF5bG9hZDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgaWYgKHBheWxvYWQuZXZlbnQgPT09IFwic2VydmVyLWVycm9yXCIgJiYgcGF5bG9hZC5lcnJvckpTT04pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHN0YWNrICwgbWVzc2FnZSAgfSA9IEpTT04ucGFyc2UocGF5bG9hZC5lcnJvckpTT04pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGVycm9yLnN0YWNrID0gc3RhY2s7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBheWxvYWQuYWN0aW9uID09PSBcInJlbG9hZFBhZ2VcIikge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGF5bG9hZC5hY3Rpb24gPT09IFwiZGV2UGFnZXNNYW5pZmVzdFVwZGF0ZVwiKSB7XG4gICAgICAgICAgICAgICAgZmV0Y2goXCJcIiArIGFzc2V0UHJlZml4ICsgXCIvX25leHQvc3RhdGljL2RldmVsb3BtZW50L19kZXZQYWdlc01hbmlmZXN0Lmpzb25cIikudGhlbigocmVzKT0+cmVzLmpzb24oKSkudGhlbigobWFuaWZlc3QpPT57XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5fX0RFVl9QQUdFU19NQU5JRkVTVCA9IG1hbmlmZXN0O1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRmFpbGVkIHRvIGZldGNoIGRldlBhZ2VzTWFuaWZlc3RcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGF5bG9hZC5ldmVudCA9PT0gXCJtaWRkbGV3YXJlQ2hhbmdlc1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGF5bG9hZC5ldmVudCA9PT0gXCJzZXJ2ZXJPbmx5Q2hhbmdlc1wiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYWdlcyAgfSA9IHBheWxvYWQ7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRvIHJlbG9hZCB3aGVuIHRoZSBkZXYtb3ZlcmxheSBpcyBzaG93aW5nIGZvciBhblxuICAgICAgICAgICAgICAgIC8vIEFQSSByb3V0ZVxuICAgICAgICAgICAgICAgIGlmIChwYWdlcy5pbmNsdWRlcyhfLnJvdXRlci5xdWVyeS5fX05FWFRfUEFHRSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFfLnJvdXRlci5jbGMgJiYgcGFnZXMuaW5jbHVkZXMoXy5yb3V0ZXIucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmVmcmVzaGluZyBwYWdlIGRhdGEgZHVlIHRvIHNlcnZlci1zaWRlIGNoYW5nZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRJbmRpY2F0b3JIYW5kbGVyKFwiYnVpbGRpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsZWFySW5kaWNhdG9yID0gKCk9PmJ1aWxkSW5kaWNhdG9ySGFuZGxlcihcImJ1aWx0XCIpO1xuICAgICAgICAgICAgICAgICAgICBfLnJvdXRlci5yZXBsYWNlKF8ucm91dGVyLnBhdGhuYW1lICsgXCI/XCIgKyBTdHJpbmcoKDAsIF9xdWVyeXN0cmluZy5hc3NpZ24pKCgwLCBfcXVlcnlzdHJpbmcudXJsUXVlcnlUb1NlYXJjaFBhcmFtcykoXy5yb3V0ZXIucXVlcnkpLCBuZXcgVVJMU2VhcmNoUGFyYW1zKGxvY2F0aW9uLnNlYXJjaCkpKSwgXy5yb3V0ZXIuYXNQYXRoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGw6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKCgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyIGhhcmQgcmVsb2FkIHdoZW4gZmFpbGluZyB0byByZWZyZXNoIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIHNob3cgZXJyb3Igb3ZlcmxheSBwcm9wZXJseVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pLmZpbmFsbHkoY2xlYXJJbmRpY2F0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAoMCwgX3dlYnNvY2tldC5hZGRNZXNzYWdlTGlzdGVuZXIpKGRldlBhZ2VzSG1yTGlzdGVuZXIpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0JVSUxEX0lORElDQVRPUikge1xuICAgICAgICAgICAgKDAsIF9kZXZidWlsZHdhdGNoZXIuZGVmYXVsdCkoKGhhbmRsZXIpPT57XG4gICAgICAgICAgICAgICAgYnVpbGRJbmRpY2F0b3JIYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgICAgIH0sIHByb2Nlc3MuZW52Ll9fTkVYVF9CVUlMRF9JTkRJQ0FUT1JfUE9TSVRJT04pO1xuICAgICAgICB9XG4gICAgfSk7XG59KS5jYXRjaCgoZXJyKT0+e1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB3YXMgbm90IGNhdWdodFwiLCBlcnIpO1xufSk7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5leHQtZGV2LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfIiwiX29uZGVtYW5kZW50cmllc2NsaWVudCIsIl93ZWJwYWNraG90bWlkZGxld2FyZWNsaWVudCIsIl9kZXZidWlsZHdhdGNoZXIiLCJfZm91YyIsIl93ZWJzb2NrZXQiLCJfcXVlcnlzdHJpbmciLCJ3aW5kb3ciLCJuZXh0IiwidmVyc2lvbiIsInJvdXRlciIsImVtaXR0ZXIiLCJ3ZWJwYWNrSE1SIiwiZGVmYXVsdCIsImluaXRpYWxpemUiLCJ0aGVuIiwicGFyYW0iLCJhc3NldFByZWZpeCIsImNvbm5lY3RITVIiLCJwYXRoIiwiaHlkcmF0ZSIsImJlZm9yZVJlbmRlciIsImRpc3BsYXlDb250ZW50IiwiYnVpbGRJbmRpY2F0b3JIYW5kbGVyIiwiZGV2UGFnZXNIbXJMaXN0ZW5lciIsImV2ZW50IiwicGF5bG9hZCIsIkpTT04iLCJwYXJzZSIsImRhdGEiLCJlIiwiZXJyb3JKU09OIiwic3RhY2siLCJtZXNzYWdlIiwiZXJyb3IiLCJFcnJvciIsImFjdGlvbiIsImxvY2F0aW9uIiwicmVsb2FkIiwiZmV0Y2giLCJyZXMiLCJqc29uIiwibWFuaWZlc3QiLCJfX0RFVl9QQUdFU19NQU5JRkVTVCIsImNhdGNoIiwiZXJyIiwiY29uc29sZSIsImxvZyIsInBhZ2VzIiwiaW5jbHVkZXMiLCJxdWVyeSIsIl9fTkVYVF9QQUdFIiwiY2xjIiwicGF0aG5hbWUiLCJjbGVhckluZGljYXRvciIsInJlcGxhY2UiLCJTdHJpbmciLCJhc3NpZ24iLCJ1cmxRdWVyeVRvU2VhcmNoUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwic2VhcmNoIiwiYXNQYXRoIiwic2Nyb2xsIiwiZmluYWxseSIsImFkZE1lc3NhZ2VMaXN0ZW5lciIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfQlVJTERfSU5ESUNBVE9SIiwiaGFuZGxlciIsIl9fTkVYVF9CVUlMRF9JTkRJQ0FUT1JfUE9TSVRJT04iLCJfX2VzTW9kdWxlIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/next-dev.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/remove-base-path.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/remove-base-path.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"removeBasePath\", ({\n    enumerable: true,\n    get: function() {\n        return removeBasePath;\n    }\n}));\nconst _hasbasepath = __webpack_require__(/*! ./has-base-path */ \"./node_modules/next/dist/client/has-base-path.js\");\nconst basePath =  false || \"\";\nfunction removeBasePath(path) {\n    if (false) {}\n    // Can't trim the basePath if it has zero length!\n    if (basePath.length === 0) return path;\n    path = path.slice(basePath.length);\n    if (!path.startsWith(\"/\")) path = \"/\" + path;\n    return path;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=remove-base-path.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yZW1vdmUtYmFzZS1wYXRoLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCxrREFBaUQ7SUFDN0NJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxlQUFlQyxtQkFBT0EsQ0FBQyx5RUFBaUI7QUFDOUMsTUFBTUMsV0FBV0MsTUFBa0MsSUFBSTtBQUN2RCxTQUFTSixlQUFlTyxJQUFJO0lBQ3hCLElBQUlILEtBQTBDLEVBQUUsRUFJL0M7SUFDRCxpREFBaUQ7SUFDakQsSUFBSUQsU0FBU08sTUFBTSxLQUFLLEdBQUcsT0FBT0g7SUFDbENBLE9BQU9BLEtBQUtJLEtBQUssQ0FBQ1IsU0FBU08sTUFBTTtJQUNqQyxJQUFJLENBQUNILEtBQUtLLFVBQVUsQ0FBQyxNQUFNTCxPQUFPLE1BQU1BO0lBQ3hDLE9BQU9BO0FBQ1g7QUFFQSxJQUFJLENBQUMsT0FBT1gsUUFBUWlCLE9BQU8sS0FBSyxjQUFlLE9BQU9qQixRQUFRaUIsT0FBTyxLQUFLLFlBQVlqQixRQUFRaUIsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPakIsUUFBUWlCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktwQixPQUFPQyxjQUFjLENBQUNDLFFBQVFpQixPQUFPLEVBQUUsY0FBYztRQUFFaEIsT0FBTztJQUFLO0lBQ25FSCxPQUFPcUIsTUFBTSxDQUFDbkIsUUFBUWlCLE9BQU8sRUFBRWpCO0lBQy9Cb0IsT0FBT3BCLE9BQU8sR0FBR0EsUUFBUWlCLE9BQU87QUFDbEMsRUFFQSw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvcmVtb3ZlLWJhc2UtcGF0aC5qcz9iNGYxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVtb3ZlQmFzZVBhdGhcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZUJhc2VQYXRoO1xuICAgIH1cbn0pO1xuY29uc3QgX2hhc2Jhc2VwYXRoID0gcmVxdWlyZShcIi4vaGFzLWJhc2UtcGF0aFwiKTtcbmNvbnN0IGJhc2VQYXRoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCB8fCBcIlwiO1xuZnVuY3Rpb24gcmVtb3ZlQmFzZVBhdGgocGF0aCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfTUFOVUFMX0NMSUVOVF9CQVNFX1BBVEgpIHtcbiAgICAgICAgaWYgKCEoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShwYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2FuJ3QgdHJpbSB0aGUgYmFzZVBhdGggaWYgaXQgaGFzIHplcm8gbGVuZ3RoIVxuICAgIGlmIChiYXNlUGF0aC5sZW5ndGggPT09IDApIHJldHVybiBwYXRoO1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKGJhc2VQYXRoLmxlbmd0aCk7XG4gICAgaWYgKCFwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSBwYXRoID0gXCIvXCIgKyBwYXRoO1xuICAgIHJldHVybiBwYXRoO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdmUtYmFzZS1wYXRoLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJyZW1vdmVCYXNlUGF0aCIsIl9oYXNiYXNlcGF0aCIsInJlcXVpcmUiLCJiYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwicGF0aCIsIl9fTkVYVF9NQU5VQUxfQ0xJRU5UX0JBU0VfUEFUSCIsImhhc0Jhc2VQYXRoIiwibGVuZ3RoIiwic2xpY2UiLCJzdGFydHNXaXRoIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/remove-base-path.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/script.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/client/script.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    handleClientScriptLoad: function() {\n        return handleClientScriptLoad;\n    },\n    initScriptLoader: function() {\n        return initScriptLoader;\n    },\n    default: function() {\n        return _default;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\"));\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nconst _headmanagercontext = __webpack_require__(/*! ../shared/lib/head-manager-context */ \"./node_modules/next/dist/shared/lib/head-manager-context.js\");\nconst _headmanager = __webpack_require__(/*! ./head-manager */ \"./node_modules/next/dist/client/head-manager.js\");\nconst _requestidlecallback = __webpack_require__(/*! ./request-idle-callback */ \"./node_modules/next/dist/client/request-idle-callback.js\");\nconst ScriptCache = new Map();\nconst LoadCache = new Set();\nconst ignoreProps = [\n    \"onLoad\",\n    \"onReady\",\n    \"dangerouslySetInnerHTML\",\n    \"children\",\n    \"onError\",\n    \"strategy\",\n    \"stylesheets\"\n];\nconst insertStylesheets = (stylesheets)=>{\n    // Case 1: Styles for afterInteractive/lazyOnload with appDir injected via handleClientScriptLoad\n    //\n    // Using ReactDOM.preinit to feature detect appDir and inject styles\n    // Stylesheets might have already been loaded if initialized with Script component\n    // Re-inject styles here to handle scripts loaded via handleClientScriptLoad\n    // ReactDOM.preinit handles dedup and ensures the styles are loaded only once\n    if (_reactdom.default.preinit) {\n        stylesheets.forEach((stylesheet)=>{\n            _reactdom.default.preinit(stylesheet, {\n                as: \"style\"\n            });\n        });\n        return;\n    }\n    // Case 2: Styles for afterInteractive/lazyOnload with pages injected via handleClientScriptLoad\n    //\n    // We use this function to load styles when appdir is not detected\n    // TODO: Use React float APIs to load styles once available for pages dir\n    if (true) {\n        let head = document.head;\n        stylesheets.forEach((stylesheet)=>{\n            let link = document.createElement(\"link\");\n            link.type = \"text/css\";\n            link.rel = \"stylesheet\";\n            link.href = stylesheet;\n            head.appendChild(link);\n        });\n    }\n};\nconst loadScript = (props)=>{\n    const { src, id, onLoad = ()=>{}, onReady = null, dangerouslySetInnerHTML, children = \"\", strategy = \"afterInteractive\", onError, stylesheets } = props;\n    const cacheKey = id || src;\n    // Script has already loaded\n    if (cacheKey && LoadCache.has(cacheKey)) {\n        return;\n    }\n    // Contents of this script are already loading/loaded\n    if (ScriptCache.has(src)) {\n        LoadCache.add(cacheKey);\n        // It is possible that multiple `next/script` components all have same \"src\", but has different \"onLoad\"\n        // This is to make sure the same remote script will only load once, but \"onLoad\" are executed in order\n        ScriptCache.get(src).then(onLoad, onError);\n        return;\n    }\n    /** Execute after the script first loaded */ const afterLoad = ()=>{\n        // Run onReady for the first time after load event\n        if (onReady) {\n            onReady();\n        }\n        // add cacheKey to LoadCache when load successfully\n        LoadCache.add(cacheKey);\n    };\n    const el = document.createElement(\"script\");\n    const loadPromise = new Promise((resolve, reject)=>{\n        el.addEventListener(\"load\", function(e) {\n            resolve();\n            if (onLoad) {\n                onLoad.call(this, e);\n            }\n            afterLoad();\n        });\n        el.addEventListener(\"error\", function(e) {\n            reject(e);\n        });\n    }).catch(function(e) {\n        if (onError) {\n            onError(e);\n        }\n    });\n    if (dangerouslySetInnerHTML) {\n        // Casting since lib.dom.d.ts doesn't have TrustedHTML yet.\n        el.innerHTML = dangerouslySetInnerHTML.__html || \"\";\n        afterLoad();\n    } else if (children) {\n        el.textContent = typeof children === \"string\" ? children : Array.isArray(children) ? children.join(\"\") : \"\";\n        afterLoad();\n    } else if (src) {\n        el.src = src;\n        // do not add cacheKey into LoadCache for remote script here\n        // cacheKey will be added to LoadCache when it is actually loaded (see loadPromise above)\n        ScriptCache.set(src, loadPromise);\n    }\n    for (const [k, value] of Object.entries(props)){\n        if (value === undefined || ignoreProps.includes(k)) {\n            continue;\n        }\n        const attr = _headmanager.DOMAttributeNames[k] || k.toLowerCase();\n        el.setAttribute(attr, value);\n    }\n    if (strategy === \"worker\") {\n        el.setAttribute(\"type\", \"text/partytown\");\n    }\n    el.setAttribute(\"data-nscript\", strategy);\n    // Load styles associated with this script\n    if (stylesheets) {\n        insertStylesheets(stylesheets);\n    }\n    document.body.appendChild(el);\n};\nfunction handleClientScriptLoad(props) {\n    const { strategy = \"afterInteractive\" } = props;\n    if (strategy === \"lazyOnload\") {\n        window.addEventListener(\"load\", ()=>{\n            (0, _requestidlecallback.requestIdleCallback)(()=>loadScript(props));\n        });\n    } else {\n        loadScript(props);\n    }\n}\nfunction loadLazyScript(props) {\n    if (document.readyState === \"complete\") {\n        (0, _requestidlecallback.requestIdleCallback)(()=>loadScript(props));\n    } else {\n        window.addEventListener(\"load\", ()=>{\n            (0, _requestidlecallback.requestIdleCallback)(()=>loadScript(props));\n        });\n    }\n}\nfunction addBeforeInteractiveToCache() {\n    const scripts = [\n        ...document.querySelectorAll('[data-nscript=\"beforeInteractive\"]'),\n        ...document.querySelectorAll('[data-nscript=\"beforePageRender\"]')\n    ];\n    scripts.forEach((script)=>{\n        const cacheKey = script.id || script.getAttribute(\"src\");\n        LoadCache.add(cacheKey);\n    });\n}\nfunction initScriptLoader(scriptLoaderItems) {\n    scriptLoaderItems.forEach(handleClientScriptLoad);\n    addBeforeInteractiveToCache();\n}\nfunction Script(props) {\n    const { id, src = \"\", onLoad = ()=>{}, onReady = null, strategy = \"afterInteractive\", onError, stylesheets, ...restProps } = props;\n    // Context is available only during SSR\n    const { updateScripts, scripts, getIsSsr, appDir, nonce } = (0, _react.useContext)(_headmanagercontext.HeadManagerContext);\n    /**\n   * - First mount:\n   *   1. The useEffect for onReady executes\n   *   2. hasOnReadyEffectCalled.current is false, but the script hasn't loaded yet (not in LoadCache)\n   *      onReady is skipped, set hasOnReadyEffectCalled.current to true\n   *   3. The useEffect for loadScript executes\n   *   4. hasLoadScriptEffectCalled.current is false, loadScript executes\n   *      Once the script is loaded, the onLoad and onReady will be called by then\n   *   [If strict mode is enabled / is wrapped in <OffScreen /> component]\n   *   5. The useEffect for onReady executes again\n   *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped\n   *   7. The useEffect for loadScript executes again\n   *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped\n   *\n   * - Second mount:\n   *   1. The useEffect for onReady executes\n   *   2. hasOnReadyEffectCalled.current is false, but the script has already loaded (found in LoadCache)\n   *      onReady is called, set hasOnReadyEffectCalled.current to true\n   *   3. The useEffect for loadScript executes\n   *   4. The script is already loaded, loadScript bails out\n   *   [If strict mode is enabled / is wrapped in <OffScreen /> component]\n   *   5. The useEffect for onReady executes again\n   *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped\n   *   7. The useEffect for loadScript executes again\n   *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped\n   */ const hasOnReadyEffectCalled = (0, _react.useRef)(false);\n    (0, _react.useEffect)(()=>{\n        const cacheKey = id || src;\n        if (!hasOnReadyEffectCalled.current) {\n            // Run onReady if script has loaded before but component is re-mounted\n            if (onReady && cacheKey && LoadCache.has(cacheKey)) {\n                onReady();\n            }\n            hasOnReadyEffectCalled.current = true;\n        }\n    }, [\n        onReady,\n        id,\n        src\n    ]);\n    const hasLoadScriptEffectCalled = (0, _react.useRef)(false);\n    (0, _react.useEffect)(()=>{\n        if (!hasLoadScriptEffectCalled.current) {\n            if (strategy === \"afterInteractive\") {\n                loadScript(props);\n            } else if (strategy === \"lazyOnload\") {\n                loadLazyScript(props);\n            }\n            hasLoadScriptEffectCalled.current = true;\n        }\n    }, [\n        props,\n        strategy\n    ]);\n    if (strategy === \"beforeInteractive\" || strategy === \"worker\") {\n        if (updateScripts) {\n            scripts[strategy] = (scripts[strategy] || []).concat([\n                {\n                    id,\n                    src,\n                    onLoad,\n                    onReady,\n                    onError,\n                    ...restProps\n                }\n            ]);\n            updateScripts(scripts);\n        } else if (getIsSsr && getIsSsr()) {\n            // Script has already loaded during SSR\n            LoadCache.add(id || src);\n        } else if (getIsSsr && !getIsSsr()) {\n            loadScript(props);\n        }\n    }\n    // For the app directory, we need React Float to preload these scripts.\n    if (appDir) {\n        // Injecting stylesheets here handles beforeInteractive and worker scripts correctly\n        // For other strategies injecting here ensures correct stylesheet order\n        // ReactDOM.preinit handles loading the styles in the correct order,\n        // also ensures the stylesheet is loaded only once and in a consistent manner\n        //\n        // Case 1: Styles for beforeInteractive/worker with appDir - handled here\n        // Case 2: Styles for beforeInteractive/worker with pages dir - Not handled yet\n        // Case 3: Styles for afterInteractive/lazyOnload with appDir - handled here\n        // Case 4: Styles for afterInteractive/lazyOnload with pages dir - handled in insertStylesheets function\n        if (stylesheets) {\n            stylesheets.forEach((styleSrc)=>{\n                _reactdom.default.preinit(styleSrc, {\n                    as: \"style\"\n                });\n            });\n        }\n        // Before interactive scripts need to be loaded by Next.js' runtime instead\n        // of native <script> tags, because they no longer have `defer`.\n        if (strategy === \"beforeInteractive\") {\n            if (!src) {\n                // For inlined scripts, we put the content in `children`.\n                if (restProps.dangerouslySetInnerHTML) {\n                    // Casting since lib.dom.d.ts doesn't have TrustedHTML yet.\n                    restProps.children = restProps.dangerouslySetInnerHTML.__html;\n                    delete restProps.dangerouslySetInnerHTML;\n                }\n                return /*#__PURE__*/ _react.default.createElement(\"script\", {\n                    nonce: nonce,\n                    dangerouslySetInnerHTML: {\n                        __html: \"(self.__next_s=self.__next_s||[]).push(\" + JSON.stringify([\n                            0,\n                            {\n                                ...restProps\n                            }\n                        ]) + \")\"\n                    }\n                });\n            } else {\n                // @ts-ignore\n                _reactdom.default.preload(src, restProps.integrity ? {\n                    as: \"script\",\n                    integrity: restProps.integrity\n                } : {\n                    as: \"script\"\n                });\n                return /*#__PURE__*/ _react.default.createElement(\"script\", {\n                    nonce: nonce,\n                    dangerouslySetInnerHTML: {\n                        __html: \"(self.__next_s=self.__next_s||[]).push(\" + JSON.stringify([\n                            src\n                        ]) + \")\"\n                    }\n                });\n            }\n        } else if (strategy === \"afterInteractive\") {\n            if (src) {\n                // @ts-ignore\n                _reactdom.default.preload(src, restProps.integrity ? {\n                    as: \"script\",\n                    integrity: restProps.integrity\n                } : {\n                    as: \"script\"\n                });\n            }\n        }\n    }\n    return null;\n}\n_c = Script;\nObject.defineProperty(Script, \"__nextScript\", {\n    value: true\n});\nconst _default = Script;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=script.js.map\nvar _c;\n$RefreshReg$(_c, \"Script\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9zY3JpcHQuanMiLCJtYXBwaW5ncyI6InFEQUNhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGLEtBQU1DLENBQUFBLENBSU47QUFDQSxTQUFTSSxRQUFRQyxNQUFNLEVBQUVDLEdBQUc7SUFDeEIsSUFBSSxJQUFJQyxRQUFRRCxJQUFJVixPQUFPQyxjQUFjLENBQUNRLFFBQVFFLE1BQU07UUFDcERDLFlBQVk7UUFDWkMsS0FBS0gsR0FBRyxDQUFDQyxLQUFLO0lBQ2xCO0FBQ0o7QUFDQUgsUUFBUU4sU0FBUztJQUNiRyx3QkFBd0I7UUFDcEIsT0FBT0E7SUFDWDtJQUNBQyxrQkFBa0I7UUFDZCxPQUFPQTtJQUNYO0lBQ0FDLFNBQVM7UUFDTCxPQUFPTztJQUNYO0FBQ0o7QUFDQSxNQUFNQywyQkFBMkJDLG1CQUFPQSxDQUFDLDRHQUF5QztBQUNsRixNQUFNQyw0QkFBNEJELG1CQUFPQSxDQUFDLDhHQUEwQztBQUNwRixNQUFNRSxZQUFZLFdBQVcsR0FBR0gseUJBQXlCSSxDQUFDLENBQUNILG1CQUFPQSxDQUFDLG9EQUFXO0FBQzlFLE1BQU1JLFNBQVMsV0FBVyxHQUFHSCwwQkFBMEJFLENBQUMsQ0FBQ0gsbUJBQU9BLENBQUMsNENBQU87QUFDeEUsTUFBTUssc0JBQXNCTCxtQkFBT0EsQ0FBQyx1R0FBb0M7QUFDeEUsTUFBTU0sZUFBZU4sbUJBQU9BLENBQUMsdUVBQWdCO0FBQzdDLE1BQU1PLHVCQUF1QlAsbUJBQU9BLENBQUMseUZBQXlCO0FBRTlELE1BQU1RLGNBQWMsSUFBSUM7QUFDeEIsTUFBTUMsWUFBWSxJQUFJQztBQUN0QixNQUFNQyxjQUFjO0lBQ2hCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0g7QUFDRCxNQUFNQyxvQkFBb0IsQ0FBQ0M7SUFDdkIsaUdBQWlHO0lBQ2pHLEVBQUU7SUFDRixvRUFBb0U7SUFDcEUsa0ZBQWtGO0lBQ2xGLDRF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SztJQUNuRUgsT0FBT2lILE1BQU0sQ0FBQy9HLFFBQVFLLE9BQU8sRUFBRUw7SUFDL0JFLE9BQU9GLE9BQU8sR0FBR0EsUUFBUUssT0FBTztBQUNsQyxFQUVBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9zY3JpcHQuanM/YmQ2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgaGFuZGxlQ2xpZW50U2NyaXB0TG9hZDogbnVsbCxcbiAgICBpbml0U2NyaXB0TG9hZGVyOiBudWxsLFxuICAgIGRlZmF1bHQ6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgaGFuZGxlQ2xpZW50U2NyaXB0TG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVDbGllbnRTY3JpcHRMb2FkO1xuICAgIH0sXG4gICAgaW5pdFNjcmlwdExvYWRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpbml0U2NyaXB0TG9hZGVyO1xuICAgIH0sXG4gICAgZGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdDtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHRcIik7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmRcIik7XG5jb25zdCBfcmVhY3Rkb20gPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCJyZWFjdC1kb21cIikpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcInJlYWN0XCIpKTtcbmNvbnN0IF9oZWFkbWFuYWdlcmNvbnRleHQgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9oZWFkLW1hbmFnZXItY29udGV4dFwiKTtcbmNvbnN0IF9oZWFkbWFuYWdlciA9IHJlcXVpcmUoXCIuL2hlYWQtbWFuYWdlclwiKTtcbmNvbnN0IF9yZXF1ZXN0aWRsZWNhbGxiYWNrID0gcmVxdWlyZShcIi4vcmVxdWVzdC1pZGxlLWNhbGxiYWNrXCIpO1xuXG5jb25zdCBTY3JpcHRDYWNoZSA9IG5ldyBNYXAoKTtcbmNvbnN0IExvYWRDYWNoZSA9IG5ldyBTZXQoKTtcbmNvbnN0IGlnbm9yZVByb3BzID0gW1xuICAgIFwib25Mb2FkXCIsXG4gICAgXCJvblJlYWR5XCIsXG4gICAgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiLFxuICAgIFwiY2hpbGRyZW5cIixcbiAgICBcIm9uRXJyb3JcIixcbiAgICBcInN0cmF0ZWd5XCIsXG4gICAgXCJzdHlsZXNoZWV0c1wiXG5dO1xuY29uc3QgaW5zZXJ0U3R5bGVzaGVldHMgPSAoc3R5bGVzaGVldHMpPT57XG4gICAgLy8gQ2FzZSAxOiBTdHlsZXMgZm9yIGFmdGVySW50ZXJhY3RpdmUvbGF6eU9ubG9hZCB3aXRoIGFwcERpciBpbmplY3RlZCB2aWEgaGFuZGxlQ2xpZW50U2NyaXB0TG9hZFxuICAgIC8vXG4gICAgLy8gVXNpbmcgUmVhY3RET00ucHJlaW5pdCB0byBmZWF0dXJlIGRldGVjdCBhcHBEaXIgYW5kIGluamVjdCBzdHlsZXNcbiAgICAvLyBTdHlsZXNoZWV0cyBtaWdodCBoYXZlIGFscmVhZHkgYmVlbiBsb2FkZWQgaWYgaW5pdGlhbGl6ZWQgd2l0aCBTY3JpcHQgY29tcG9uZW50XG4gICAgLy8gUmUtaW5qZWN0IHN0eWxlcyBoZXJlIHRvIGhhbmRsZSBzY3JpcHRzIGxvYWRlZCB2aWEgaGFuZGxlQ2xpZW50U2NyaXB0TG9hZFxuICAgIC8vIFJlYWN0RE9NLnByZWluaXQgaGFuZGxlcyBkZWR1cCBhbmQgZW5zdXJlcyB0aGUgc3R5bGVzIGFyZSBsb2FkZWQgb25seSBvbmNlXG4gICAgaWYgKF9yZWFjdGRvbS5kZWZhdWx0LnByZWluaXQpIHtcbiAgICAgICAgc3R5bGVzaGVldHMuZm9yRWFjaCgoc3R5bGVzaGVldCk9PntcbiAgICAgICAgICAgIF9yZWFjdGRvbS5kZWZhdWx0LnByZWluaXQoc3R5bGVzaGVldCwge1xuICAgICAgICAgICAgICAgIGFzOiBcInN0eWxlXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDYXNlIDI6IFN0eWxlcyBmb3IgYWZ0ZXJJbnRlcmFjdGl2ZS9sYXp5T25sb2FkIHdpdGggcGFnZXMgaW5qZWN0ZWQgdmlhIGhhbmRsZUNsaWVudFNjcmlwdExvYWRcbiAgICAvL1xuICAgIC8vIFdlIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGxvYWQgc3R5bGVzIHdoZW4gYXBwZGlyIGlzIG5vdCBkZXRlY3RlZFxuICAgIC8vIFRPRE86IFVzZSBSZWFjdCBmbG9hdCBBUElzIHRvIGxvYWQgc3R5bGVzIG9uY2UgYXZhaWxhYmxlIGZvciBwYWdlcyBkaXJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBsZXQgaGVhZCA9IGRvY3VtZW50LmhlYWQ7XG4gICAgICAgIHN0eWxlc2hlZXRzLmZvckVhY2goKHN0eWxlc2hlZXQpPT57XG4gICAgICAgICAgICBsZXQgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuICAgICAgICAgICAgbGluay50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuICAgICAgICAgICAgbGluay5yZWwgPSBcInN0eWxlc2hlZXRcIjtcbiAgICAgICAgICAgIGxpbmsuaHJlZiA9IHN0eWxlc2hlZXQ7XG4gICAgICAgICAgICBoZWFkLmFwcGVuZENoaWxkKGxpbmspO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuY29uc3QgbG9hZFNjcmlwdCA9IChwcm9wcyk9PntcbiAgICBjb25zdCB7IHNyYyAsIGlkICwgb25Mb2FkID0oKT0+e30gLCBvblJlYWR5ID1udWxsICwgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgLCBjaGlsZHJlbiA9XCJcIiAsIHN0cmF0ZWd5ID1cImFmdGVySW50ZXJhY3RpdmVcIiAsIG9uRXJyb3IgLCBzdHlsZXNoZWV0cyAgfSA9IHByb3BzO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gaWQgfHwgc3JjO1xuICAgIC8vIFNjcmlwdCBoYXMgYWxyZWFkeSBsb2FkZWRcbiAgICBpZiAoY2FjaGVLZXkgJiYgTG9hZENhY2hlLmhhcyhjYWNoZUtleSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDb250ZW50cyBvZiB0aGlzIHNjcmlwdCBhcmUgYWxyZWFkeSBsb2FkaW5nL2xvYWRlZFxuICAgIGlmIChTY3JpcHRDYWNoZS5oYXMoc3JjKSkge1xuICAgICAgICBMb2FkQ2FjaGUuYWRkKGNhY2hlS2V5KTtcbiAgICAgICAgLy8gSXQgaXMgcG9zc2libGUgdGhhdCBtdWx0aXBsZSBgbmV4dC9zY3JpcHRgIGNvbXBvbmVudHMgYWxsIGhhdmUgc2FtZSBcInNyY1wiLCBidXQgaGFzIGRpZmZlcmVudCBcIm9uTG9hZFwiXG4gICAgICAgIC8vIFRoaXMgaXMgdG8gbWFrZSBzdXJlIHRoZSBzYW1lIHJlbW90ZSBzY3JpcHQgd2lsbCBvbmx5IGxvYWQgb25jZSwgYnV0IFwib25Mb2FkXCIgYXJlIGV4ZWN1dGVkIGluIG9yZGVyXG4gICAgICAgIFNjcmlwdENhY2hlLmdldChzcmMpLnRoZW4ob25Mb2FkLCBvbkVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKiogRXhlY3V0ZSBhZnRlciB0aGUgc2NyaXB0IGZpcnN0IGxvYWRlZCAqLyBjb25zdCBhZnRlckxvYWQgPSAoKT0+e1xuICAgICAgICAvLyBSdW4gb25SZWFkeSBmb3IgdGhlIGZpcnN0IHRpbWUgYWZ0ZXIgbG9hZCBldmVudFxuICAgICAgICBpZiAob25SZWFkeSkge1xuICAgICAgICAgICAgb25SZWFkeSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCBjYWNoZUtleSB0byBMb2FkQ2FjaGUgd2hlbiBsb2FkIHN1Y2Nlc3NmdWxseVxuICAgICAgICBMb2FkQ2FjaGUuYWRkKGNhY2hlS2V5KTtcbiAgICB9O1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICBjb25zdCBsb2FkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIGlmIChvbkxvYWQpIHtcbiAgICAgICAgICAgICAgICBvbkxvYWQuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFmdGVyTG9hZCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfSk7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgICAgb25FcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChkYW5nZXJvdXNseVNldElubmVySFRNTCkge1xuICAgICAgICAvLyBDYXN0aW5nIHNpbmNlIGxpYi5kb20uZC50cyBkb2Vzbid0IGhhdmUgVHJ1c3RlZEhUTUwgeWV0LlxuICAgICAgICBlbC5pbm5lckhUTUwgPSBkYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWwgfHwgXCJcIjtcbiAgICAgICAgYWZ0ZXJMb2FkKCk7XG4gICAgfSBlbHNlIGlmIChjaGlsZHJlbikge1xuICAgICAgICBlbC50ZXh0Q29udGVudCA9IHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJzdHJpbmdcIiA/IGNoaWxkcmVuIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbi5qb2luKFwiXCIpIDogXCJcIjtcbiAgICAgICAgYWZ0ZXJMb2FkKCk7XG4gICAgfSBlbHNlIGlmIChzcmMpIHtcbiAgICAgICAgZWwuc3JjID0gc3JjO1xuICAgICAgICAvLyBkbyBub3QgYWRkIGNhY2hlS2V5IGludG8gTG9hZENhY2hlIGZvciByZW1vdGUgc2NyaXB0IGhlcmVcbiAgICAgICAgLy8gY2FjaGVLZXkgd2lsbCBiZSBhZGRlZCB0byBMb2FkQ2FjaGUgd2hlbiBpdCBpcyBhY3R1YWxseSBsb2FkZWQgKHNlZSBsb2FkUHJvbWlzZSBhYm92ZSlcbiAgICAgICAgU2NyaXB0Q2FjaGUuc2V0KHNyYywgbG9hZFByb21pc2UpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcHMpKXtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgaWdub3JlUHJvcHMuaW5jbHVkZXMoaykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF0dHIgPSBfaGVhZG1hbmFnZXIuRE9NQXR0cmlidXRlTmFtZXNba10gfHwgay50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAoc3RyYXRlZ3kgPT09IFwid29ya2VyXCIpIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcInRleHQvcGFydHl0b3duXCIpO1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLW5zY3JpcHRcIiwgc3RyYXRlZ3kpO1xuICAgIC8vIExvYWQgc3R5bGVzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHNjcmlwdFxuICAgIGlmIChzdHlsZXNoZWV0cykge1xuICAgICAgICBpbnNlcnRTdHlsZXNoZWV0cyhzdHlsZXNoZWV0cyk7XG4gICAgfVxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwpO1xufTtcbmZ1bmN0aW9uIGhhbmRsZUNsaWVudFNjcmlwdExvYWQocHJvcHMpIHtcbiAgICBjb25zdCB7IHN0cmF0ZWd5ID1cImFmdGVySW50ZXJhY3RpdmVcIiAgfSA9IHByb3BzO1xuICAgIGlmIChzdHJhdGVneSA9PT0gXCJsYXp5T25sb2FkXCIpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpPT57XG4gICAgICAgICAgICAoMCwgX3JlcXVlc3RpZGxlY2FsbGJhY2sucmVxdWVzdElkbGVDYWxsYmFjaykoKCk9PmxvYWRTY3JpcHQocHJvcHMpKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbG9hZFNjcmlwdChwcm9wcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gbG9hZExhenlTY3JpcHQocHJvcHMpIHtcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgICgwLCBfcmVxdWVzdGlkbGVjYWxsYmFjay5yZXF1ZXN0SWRsZUNhbGxiYWNrKSgoKT0+bG9hZFNjcmlwdChwcm9wcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKT0+e1xuICAgICAgICAgICAgKDAsIF9yZXF1ZXN0aWRsZWNhbGxiYWNrLnJlcXVlc3RJZGxlQ2FsbGJhY2spKCgpPT5sb2FkU2NyaXB0KHByb3BzKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZEJlZm9yZUludGVyYWN0aXZlVG9DYWNoZSgpIHtcbiAgICBjb25zdCBzY3JpcHRzID0gW1xuICAgICAgICAuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1uc2NyaXB0PVwiYmVmb3JlSW50ZXJhY3RpdmVcIl0nKSxcbiAgICAgICAgLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbnNjcmlwdD1cImJlZm9yZVBhZ2VSZW5kZXJcIl0nKVxuICAgIF07XG4gICAgc2NyaXB0cy5mb3JFYWNoKChzY3JpcHQpPT57XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gc2NyaXB0LmlkIHx8IHNjcmlwdC5nZXRBdHRyaWJ1dGUoXCJzcmNcIik7XG4gICAgICAgIExvYWRDYWNoZS5hZGQoY2FjaGVLZXkpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaW5pdFNjcmlwdExvYWRlcihzY3JpcHRMb2FkZXJJdGVtcykge1xuICAgIHNjcmlwdExvYWRlckl0ZW1zLmZvckVhY2goaGFuZGxlQ2xpZW50U2NyaXB0TG9hZCk7XG4gICAgYWRkQmVmb3JlSW50ZXJhY3RpdmVUb0NhY2hlKCk7XG59XG5mdW5jdGlvbiBTY3JpcHQocHJvcHMpIHtcbiAgICBjb25zdCB7IGlkICwgc3JjID1cIlwiICwgb25Mb2FkID0oKT0+e30gLCBvblJlYWR5ID1udWxsICwgc3RyYXRlZ3kgPVwiYWZ0ZXJJbnRlcmFjdGl2ZVwiICwgb25FcnJvciAsIHN0eWxlc2hlZXRzICwgLi4ucmVzdFByb3BzIH0gPSBwcm9wcztcbiAgICAvLyBDb250ZXh0IGlzIGF2YWlsYWJsZSBvbmx5IGR1cmluZyBTU1JcbiAgICBjb25zdCB7IHVwZGF0ZVNjcmlwdHMgLCBzY3JpcHRzICwgZ2V0SXNTc3IgLCBhcHBEaXIgLCBub25jZSAgfSA9ICgwLCBfcmVhY3QudXNlQ29udGV4dCkoX2hlYWRtYW5hZ2VyY29udGV4dC5IZWFkTWFuYWdlckNvbnRleHQpO1xuICAgIC8qKlxuICAgKiAtIEZpcnN0IG1vdW50OlxuICAgKiAgIDEuIFRoZSB1c2VFZmZlY3QgZm9yIG9uUmVhZHkgZXhlY3V0ZXNcbiAgICogICAyLiBoYXNPblJlYWR5RWZmZWN0Q2FsbGVkLmN1cnJlbnQgaXMgZmFsc2UsIGJ1dCB0aGUgc2NyaXB0IGhhc24ndCBsb2FkZWQgeWV0IChub3QgaW4gTG9hZENhY2hlKVxuICAgKiAgICAgIG9uUmVhZHkgaXMgc2tpcHBlZCwgc2V0IGhhc09uUmVhZHlFZmZlY3RDYWxsZWQuY3VycmVudCB0byB0cnVlXG4gICAqICAgMy4gVGhlIHVzZUVmZmVjdCBmb3IgbG9hZFNjcmlwdCBleGVjdXRlc1xuICAgKiAgIDQuIGhhc0xvYWRTY3JpcHRFZmZlY3RDYWxsZWQuY3VycmVudCBpcyBmYWxzZSwgbG9hZFNjcmlwdCBleGVjdXRlc1xuICAgKiAgICAgIE9uY2UgdGhlIHNjcmlwdCBpcyBsb2FkZWQsIHRoZSBvbkxvYWQgYW5kIG9uUmVhZHkgd2lsbCBiZSBjYWxsZWQgYnkgdGhlblxuICAgKiAgIFtJZiBzdHJpY3QgbW9kZSBpcyBlbmFibGVkIC8gaXMgd3JhcHBlZCBpbiA8T2ZmU2NyZWVuIC8+IGNvbXBvbmVudF1cbiAgICogICA1LiBUaGUgdXNlRWZmZWN0IGZvciBvblJlYWR5IGV4ZWN1dGVzIGFnYWluXG4gICAqICAgNi4gaGFzT25SZWFkeUVmZmVjdENhbGxlZC5jdXJyZW50IGlzIHRydWUsIHNvIGVudGlyZSBlZmZlY3QgaXMgc2tpcHBlZFxuICAgKiAgIDcuIFRoZSB1c2VFZmZlY3QgZm9yIGxvYWRTY3JpcHQgZXhlY3V0ZXMgYWdhaW5cbiAgICogICA4LiBoYXNMb2FkU2NyaXB0RWZmZWN0Q2FsbGVkLmN1cnJlbnQgaXMgdHJ1ZSwgc28gZW50aXJlIGVmZmVjdCBpcyBza2lwcGVkXG4gICAqXG4gICAqIC0gU2Vjb25kIG1vdW50OlxuICAgKiAgIDEuIFRoZSB1c2VFZmZlY3QgZm9yIG9uUmVhZHkgZXhlY3V0ZXNcbiAgICogICAyLiBoYXNPblJlYWR5RWZmZWN0Q2FsbGVkLmN1cnJlbnQgaXMgZmFsc2UsIGJ1dCB0aGUgc2NyaXB0IGhhcyBhbHJlYWR5IGxvYWRlZCAoZm91bmQgaW4gTG9hZENhY2hlKVxuICAgKiAgICAgIG9uUmVhZHkgaXMgY2FsbGVkLCBzZXQgaGFzT25SZWFkeUVmZmVjdENhbGxlZC5jdXJyZW50IHRvIHRydWVcbiAgICogICAzLiBUaGUgdXNlRWZmZWN0IGZvciBsb2FkU2NyaXB0IGV4ZWN1dGVzXG4gICAqICAgNC4gVGhlIHNjcmlwdCBpcyBhbHJlYWR5IGxvYWRlZCwgbG9hZFNjcmlwdCBiYWlscyBvdXRcbiAgICogICBbSWYgc3RyaWN0IG1vZGUgaXMgZW5hYmxlZCAvIGlzIHdyYXBwZWQgaW4gPE9mZlNjcmVlbiAvPiBjb21wb25lbnRdXG4gICAqICAgNS4gVGhlIHVzZUVmZmVjdCBmb3Igb25SZWFkeSBleGVjdXRlcyBhZ2FpblxuICAgKiAgIDYuIGhhc09uUmVhZHlFZmZlY3RDYWxsZWQuY3VycmVudCBpcyB0cnVlLCBzbyBlbnRpcmUgZWZmZWN0IGlzIHNraXBwZWRcbiAgICogICA3LiBUaGUgdXNlRWZmZWN0IGZvciBsb2FkU2NyaXB0IGV4ZWN1dGVzIGFnYWluXG4gICAqICAgOC4gaGFzTG9hZFNjcmlwdEVmZmVjdENhbGxlZC5jdXJyZW50IGlzIHRydWUsIHNvIGVudGlyZSBlZmZlY3QgaXMgc2tpcHBlZFxuICAgKi8gY29uc3QgaGFzT25SZWFkeUVmZmVjdENhbGxlZCA9ICgwLCBfcmVhY3QudXNlUmVmKShmYWxzZSk7XG4gICAgKDAsIF9yZWFjdC51c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gaWQgfHwgc3JjO1xuICAgICAgICBpZiAoIWhhc09uUmVhZHlFZmZlY3RDYWxsZWQuY3VycmVudCkge1xuICAgICAgICAgICAgLy8gUnVuIG9uUmVhZHkgaWYgc2NyaXB0IGhhcyBsb2FkZWQgYmVmb3JlIGJ1dCBjb21wb25lbnQgaXMgcmUtbW91bnRlZFxuICAgICAgICAgICAgaWYgKG9uUmVhZHkgJiYgY2FjaGVLZXkgJiYgTG9hZENhY2hlLmhhcyhjYWNoZUtleSkpIHtcbiAgICAgICAgICAgICAgICBvblJlYWR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYXNPblJlYWR5RWZmZWN0Q2FsbGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBvblJlYWR5LFxuICAgICAgICBpZCxcbiAgICAgICAgc3JjXG4gICAgXSk7XG4gICAgY29uc3QgaGFzTG9hZFNjcmlwdEVmZmVjdENhbGxlZCA9ICgwLCBfcmVhY3QudXNlUmVmKShmYWxzZSk7XG4gICAgKDAsIF9yZWFjdC51c2VFZmZlY3QpKCgpPT57XG4gICAgICAgIGlmICghaGFzTG9hZFNjcmlwdEVmZmVjdENhbGxlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICBpZiAoc3RyYXRlZ3kgPT09IFwiYWZ0ZXJJbnRlcmFjdGl2ZVwiKSB7XG4gICAgICAgICAgICAgICAgbG9hZFNjcmlwdChwcm9wcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmF0ZWd5ID09PSBcImxhenlPbmxvYWRcIikge1xuICAgICAgICAgICAgICAgIGxvYWRMYXp5U2NyaXB0KHByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhc0xvYWRTY3JpcHRFZmZlY3RDYWxsZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIHByb3BzLFxuICAgICAgICBzdHJhdGVneVxuICAgIF0pO1xuICAgIGlmIChzdHJhdGVneSA9PT0gXCJiZWZvcmVJbnRlcmFjdGl2ZVwiIHx8IHN0cmF0ZWd5ID09PSBcIndvcmtlclwiKSB7XG4gICAgICAgIGlmICh1cGRhdGVTY3JpcHRzKSB7XG4gICAgICAgICAgICBzY3JpcHRzW3N0cmF0ZWd5XSA9IChzY3JpcHRzW3N0cmF0ZWd5XSB8fCBbXSkuY29uY2F0KFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICAgICAgICAgIG9uTG9hZCxcbiAgICAgICAgICAgICAgICAgICAgb25SZWFkeSxcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgICAgICAgICAgLi4ucmVzdFByb3BzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB1cGRhdGVTY3JpcHRzKHNjcmlwdHMpO1xuICAgICAgICB9IGVsc2UgaWYgKGdldElzU3NyICYmIGdldElzU3NyKCkpIHtcbiAgICAgICAgICAgIC8vIFNjcmlwdCBoYXMgYWxyZWFkeSBsb2FkZWQgZHVyaW5nIFNTUlxuICAgICAgICAgICAgTG9hZENhY2hlLmFkZChpZCB8fCBzcmMpO1xuICAgICAgICB9IGVsc2UgaWYgKGdldElzU3NyICYmICFnZXRJc1NzcigpKSB7XG4gICAgICAgICAgICBsb2FkU2NyaXB0KHByb3BzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBGb3IgdGhlIGFwcCBkaXJlY3RvcnksIHdlIG5lZWQgUmVhY3QgRmxvYXQgdG8gcHJlbG9hZCB0aGVzZSBzY3JpcHRzLlxuICAgIGlmIChhcHBEaXIpIHtcbiAgICAgICAgLy8gSW5qZWN0aW5nIHN0eWxlc2hlZXRzIGhlcmUgaGFuZGxlcyBiZWZvcmVJbnRlcmFjdGl2ZSBhbmQgd29ya2VyIHNjcmlwdHMgY29ycmVjdGx5XG4gICAgICAgIC8vIEZvciBvdGhlciBzdHJhdGVnaWVzIGluamVjdGluZyBoZXJlIGVuc3VyZXMgY29ycmVjdCBzdHlsZXNoZWV0IG9yZGVyXG4gICAgICAgIC8vIFJlYWN0RE9NLnByZWluaXQgaGFuZGxlcyBsb2FkaW5nIHRoZSBzdHlsZXMgaW4gdGhlIGNvcnJlY3Qgb3JkZXIsXG4gICAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGUgc3R5bGVzaGVldCBpcyBsb2FkZWQgb25seSBvbmNlIGFuZCBpbiBhIGNvbnNpc3RlbnQgbWFubmVyXG4gICAgICAgIC8vXG4gICAgICAgIC8vIENhc2UgMTogU3R5bGVzIGZvciBiZWZvcmVJbnRlcmFjdGl2ZS93b3JrZXIgd2l0aCBhcHBEaXIgLSBoYW5kbGVkIGhlcmVcbiAgICAgICAgLy8gQ2FzZSAyOiBTdHlsZXMgZm9yIGJlZm9yZUludGVyYWN0aXZlL3dvcmtlciB3aXRoIHBhZ2VzIGRpciAtIE5vdCBoYW5kbGVkIHlldFxuICAgICAgICAvLyBDYXNlIDM6IFN0eWxlcyBmb3IgYWZ0ZXJJbnRlcmFjdGl2ZS9sYXp5T25sb2FkIHdpdGggYXBwRGlyIC0gaGFuZGxlZCBoZXJlXG4gICAgICAgIC8vIENhc2UgNDogU3R5bGVzIGZvciBhZnRlckludGVyYWN0aXZlL2xhenlPbmxvYWQgd2l0aCBwYWdlcyBkaXIgLSBoYW5kbGVkIGluIGluc2VydFN0eWxlc2hlZXRzIGZ1bmN0aW9uXG4gICAgICAgIGlmIChzdHlsZXNoZWV0cykge1xuICAgICAgICAgICAgc3R5bGVzaGVldHMuZm9yRWFjaCgoc3R5bGVTcmMpPT57XG4gICAgICAgICAgICAgICAgX3JlYWN0ZG9tLmRlZmF1bHQucHJlaW5pdChzdHlsZVNyYywge1xuICAgICAgICAgICAgICAgICAgICBhczogXCJzdHlsZVwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCZWZvcmUgaW50ZXJhY3RpdmUgc2NyaXB0cyBuZWVkIHRvIGJlIGxvYWRlZCBieSBOZXh0LmpzJyBydW50aW1lIGluc3RlYWRcbiAgICAgICAgLy8gb2YgbmF0aXZlIDxzY3JpcHQ+IHRhZ3MsIGJlY2F1c2UgdGhleSBubyBsb25nZXIgaGF2ZSBgZGVmZXJgLlxuICAgICAgICBpZiAoc3RyYXRlZ3kgPT09IFwiYmVmb3JlSW50ZXJhY3RpdmVcIikge1xuICAgICAgICAgICAgaWYgKCFzcmMpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgaW5saW5lZCBzY3JpcHRzLCB3ZSBwdXQgdGhlIGNvbnRlbnQgaW4gYGNoaWxkcmVuYC5cbiAgICAgICAgICAgICAgICBpZiAocmVzdFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhc3Rpbmcgc2luY2UgbGliLmRvbS5kLnRzIGRvZXNuJ3QgaGF2ZSBUcnVzdGVkSFRNTCB5ZXQuXG4gICAgICAgICAgICAgICAgICAgIHJlc3RQcm9wcy5jaGlsZHJlbiA9IHJlc3RQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWw7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwge1xuICAgICAgICAgICAgICAgICAgICBub25jZTogbm9uY2UsXG4gICAgICAgICAgICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfX2h0bWw6IFwiKHNlbGYuX19uZXh0X3M9c2VsZi5fX25leHRfc3x8W10pLnB1c2goXCIgKyBKU09OLnN0cmluZ2lmeShbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnJlc3RQcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF0pICsgXCIpXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgX3JlYWN0ZG9tLmRlZmF1bHQucHJlbG9hZChzcmMsIHJlc3RQcm9wcy5pbnRlZ3JpdHkgPyB7XG4gICAgICAgICAgICAgICAgICAgIGFzOiBcInNjcmlwdFwiLFxuICAgICAgICAgICAgICAgICAgICBpbnRlZ3JpdHk6IHJlc3RQcm9wcy5pbnRlZ3JpdHlcbiAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgICBhczogXCJzY3JpcHRcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwge1xuICAgICAgICAgICAgICAgICAgICBub25jZTogbm9uY2UsXG4gICAgICAgICAgICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfX2h0bWw6IFwiKHNlbGYuX19uZXh0X3M9c2VsZi5fX25leHRfc3x8W10pLnB1c2goXCIgKyBKU09OLnN0cmluZ2lmeShbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSArIFwiKVwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzdHJhdGVneSA9PT0gXCJhZnRlckludGVyYWN0aXZlXCIpIHtcbiAgICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgX3JlYWN0ZG9tLmRlZmF1bHQucHJlbG9hZChzcmMsIHJlc3RQcm9wcy5pbnRlZ3JpdHkgPyB7XG4gICAgICAgICAgICAgICAgICAgIGFzOiBcInNjcmlwdFwiLFxuICAgICAgICAgICAgICAgICAgICBpbnRlZ3JpdHk6IHJlc3RQcm9wcy5pbnRlZ3JpdHlcbiAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgICBhczogXCJzY3JpcHRcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjcmlwdCwgXCJfX25leHRTY3JpcHRcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmNvbnN0IF9kZWZhdWx0ID0gU2NyaXB0O1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY3JpcHQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiaGFuZGxlQ2xpZW50U2NyaXB0TG9hZCIsImluaXRTY3JpcHRMb2FkZXIiLCJkZWZhdWx0IiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX2RlZmF1bHQiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsIl9yZWFjdGRvbSIsIl8iLCJfcmVhY3QiLCJfaGVhZG1hbmFnZXJjb250ZXh0IiwiX2hlYWRtYW5hZ2VyIiwiX3JlcXVlc3RpZGxlY2FsbGJhY2siLCJTY3JpcHRDYWNoZSIsIk1hcCIsIkxvYWRDYWNoZSIsIlNldCIsImlnbm9yZVByb3BzIiwiaW5zZXJ0U3R5bGVzaGVldHMiLCJzdHlsZXNoZWV0cyIsInByZWluaXQiLCJmb3JFYWNoIiwic3R5bGVzaGVldCIsImFzIiwiaGVhZCIsImRvY3VtZW50IiwibGluayIsImNyZWF0ZUVsZW1lbnQiLCJ0eXBlIiwicmVsIiwiaHJlZiIsImFwcGVuZENoaWxkIiwibG9hZFNjcmlwdCIsInByb3BzIiwic3JjIiwiaWQiLCJvbkxvYWQiLCJvblJlYWR5IiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJjaGlsZHJlbiIsInN0cmF0ZWd5Iiwib25FcnJvciIsImNhY2hlS2V5IiwiaGFzIiwiYWRkIiwidGhlbiIsImFmdGVyTG9hZCIsImVsIiwibG9hZFByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwiY2FsbCIsImNhdGNoIiwiaW5uZXJIVE1MIiwiX19odG1sIiwidGV4dENvbnRlbnQiLCJBcnJheSIsImlzQXJyYXkiLCJqb2luIiwic2V0IiwiayIsImVudHJpZXMiLCJ1bmRlZmluZWQiLCJpbmNsdWRlcyIsImF0dHIiLCJET01BdHRyaWJ1dGVOYW1lcyIsInRvTG93ZXJDYXNlIiwic2V0QXR0cmlidXRlIiwiYm9keSIsIndpbmRvdyIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJsb2FkTGF6eVNjcmlwdCIsInJlYWR5U3RhdGUiLCJhZGRCZWZvcmVJbnRlcmFjdGl2ZVRvQ2FjaGUiLCJzY3JpcHRzIiwicXVlcnlTZWxlY3RvckFsbCIsInNjcmlwdCIsImdldEF0dHJpYnV0ZSIsInNjcmlwdExvYWRlckl0ZW1zIiwiU2NyaXB0IiwicmVzdFByb3BzIiwidXBkYXRlU2NyaXB0cyIsImdldElzU3NyIiwiYXBwRGlyIiwibm9uY2UiLCJ1c2VDb250ZXh0IiwiSGVhZE1hbmFnZXJDb250ZXh0IiwiaGFzT25SZWFkeUVmZmVjdENhbGxlZCIsInVzZVJlZiIsInVzZUVmZmVjdCIsImN1cnJlbnQiLCJoYXNMb2FkU2NyaXB0RWZmZWN0Q2FsbGVkIiwiY29uY2F0Iiwic3R5bGVTcmMiLCJKU09OIiwic3RyaW5naWZ5IiwicHJlbG9hZCIsImludGVncml0eSIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/script.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/setup-hydration-warning.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/client/setup-hydration-warning.js ***!
  \******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nif (!window._nextSetupHydrationWarning) {\n    const origConsoleError = window.console.error;\n    window.console.error = function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        const isHydrateError = args.some((arg)=>typeof arg === \"string\" && arg.match(/(hydration|content does not match|did not match)/i));\n        if (isHydrateError) {\n            args = [\n                ...args,\n                \"\\n\\nSee more info here: https://nextjs.org/docs/messages/react-hydration-error\"\n            ];\n        }\n        origConsoleError.apply(window.console, args);\n    };\n    window._nextSetupHydrationWarning = true;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=setup-hydration-warning.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9zZXR1cC1oeWRyYXRpb24td2FybmluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixJQUFJLENBQUNDLE9BQU9DLDBCQUEwQixFQUFFO0lBQ3BDLE1BQU1DLG1CQUFtQkYsT0FBT0csT0FBTyxDQUFDQyxLQUFLO0lBQzdDSixPQUFPRyxPQUFPLENBQUNDLEtBQUssR0FBRztRQUNuQixJQUFJLElBQUlDLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsT0FBTyxJQUFJQyxNQUFNSixPQUFPSyxPQUFPLEdBQUdBLE9BQU9MLE1BQU1LLE9BQU87WUFDbkZGLElBQUksQ0FBQ0UsS0FBSyxHQUFHSixTQUFTLENBQUNJLEtBQUs7UUFDaEM7UUFDQSxNQUFNQyxpQkFBaUJILEtBQUtJLElBQUksQ0FBQyxDQUFDQyxNQUFNLE9BQU9BLFFBQVEsWUFBWUEsSUFBSUMsS0FBSyxDQUFDO1FBQzdFLElBQUlILGdCQUFnQjtZQUNoQkgsT0FBTzttQkFDQUE7Z0JBQ0g7YUFDSDtRQUNMO1FBQ0FOLGlCQUFpQmEsS0FBSyxDQUFDZixPQUFPRyxPQUFPLEVBQUVLO0lBQzNDO0lBQ0FSLE9BQU9DLDBCQUEwQixHQUFHO0FBQ3hDO0FBRUEsSUFBSSxDQUFDLE9BQU9ILFFBQVFrQixPQUFPLEtBQUssY0FBZSxPQUFPbEIsUUFBUWtCLE9BQU8sS0FBSyxZQUFZbEIsUUFBUWtCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2xCLFFBQVFrQixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLckIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRa0IsT0FBTyxFQUFFLGNBQWM7UUFBRWpCLE9BQU87SUFBSztJQUNuRUgsT0FBT3NCLE1BQU0sQ0FBQ3BCLFFBQVFrQixPQUFPLEVBQUVsQjtJQUMvQnFCLE9BQU9yQixPQUFPLEdBQUdBLFFBQVFrQixPQUFPO0FBQ2xDLEVBRUEsbURBQW1EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3NldHVwLWh5ZHJhdGlvbi13YXJuaW5nLmpzPzdkZGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5pZiAoIXdpbmRvdy5fbmV4dFNldHVwSHlkcmF0aW9uV2FybmluZykge1xuICAgIGNvbnN0IG9yaWdDb25zb2xlRXJyb3IgPSB3aW5kb3cuY29uc29sZS5lcnJvcjtcbiAgICB3aW5kb3cuY29uc29sZS5lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzSHlkcmF0ZUVycm9yID0gYXJncy5zb21lKChhcmcpPT50eXBlb2YgYXJnID09PSBcInN0cmluZ1wiICYmIGFyZy5tYXRjaCgvKGh5ZHJhdGlvbnxjb250ZW50IGRvZXMgbm90IG1hdGNofGRpZCBub3QgbWF0Y2gpL2kpKTtcbiAgICAgICAgaWYgKGlzSHlkcmF0ZUVycm9yKSB7XG4gICAgICAgICAgICBhcmdzID0gW1xuICAgICAgICAgICAgICAgIC4uLmFyZ3MsXG4gICAgICAgICAgICAgICAgXCJcXG5cXG5TZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3JlYWN0LWh5ZHJhdGlvbi1lcnJvclwiXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIG9yaWdDb25zb2xlRXJyb3IuYXBwbHkod2luZG93LmNvbnNvbGUsIGFyZ3MpO1xuICAgIH07XG4gICAgd2luZG93Ll9uZXh0U2V0dXBIeWRyYXRpb25XYXJuaW5nID0gdHJ1ZTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2V0dXAtaHlkcmF0aW9uLXdhcm5pbmcuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwid2luZG93IiwiX25leHRTZXR1cEh5ZHJhdGlvbldhcm5pbmciLCJvcmlnQ29uc29sZUVycm9yIiwiY29uc29sZSIsImVycm9yIiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJpc0h5ZHJhdGVFcnJvciIsInNvbWUiLCJhcmciLCJtYXRjaCIsImFwcGx5IiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/setup-hydration-warning.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/tracing/report-to-socket.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/tracing/report-to-socket.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return reportToSocket;\n    }\n}));\nconst _websocket = __webpack_require__(/*! ../dev/error-overlay/websocket */ \"./node_modules/next/dist/client/dev/error-overlay/websocket.js\");\nfunction reportToSocket(span) {\n    if (span.state.state !== \"ended\") {\n        throw new Error(\"Expected span to be ended\");\n    }\n    (0, _websocket.sendMessage)(JSON.stringify({\n        event: \"span-end\",\n        startTime: span.startTime,\n        endTime: span.state.endTime,\n        spanName: span.name,\n        attributes: span.attributes\n    }));\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=report-to-socket.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC90cmFjaW5nL3JlcG9ydC10by1zb2NrZXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILDJDQUEwQztJQUN0Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLGFBQWFDLG1CQUFPQSxDQUFDLHNHQUFnQztBQUMzRCxTQUFTRixlQUFlRyxJQUFJO0lBQ3hCLElBQUlBLEtBQUtDLEtBQUssQ0FBQ0EsS0FBSyxLQUFLLFNBQVM7UUFDOUIsTUFBTSxJQUFJQyxNQUFNO0lBQ3BCO0lBQ0MsSUFBR0osV0FBV0ssV0FBVyxFQUFFQyxLQUFLQyxTQUFTLENBQUM7UUFDdkNDLE9BQU87UUFDUEMsV0FBV1AsS0FBS08sU0FBUztRQUN6QkMsU0FBU1IsS0FBS0MsS0FBSyxDQUFDTyxPQUFPO1FBQzNCQyxVQUFVVCxLQUFLVSxJQUFJO1FBQ25CQyxZQUFZWCxLQUFLVyxVQUFVO0lBQy9CO0FBQ0o7QUFFQSxJQUFJLENBQUMsT0FBT2xCLFFBQVFtQixPQUFPLEtBQUssY0FBZSxPQUFPbkIsUUFBUW1CLE9BQU8sS0FBSyxZQUFZbkIsUUFBUW1CLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT25CLFFBQVFtQixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLdEIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRbUIsT0FBTyxFQUFFLGNBQWM7UUFBRWxCLE9BQU87SUFBSztJQUNuRUgsT0FBT3VCLE1BQU0sQ0FBQ3JCLFFBQVFtQixPQUFPLEVBQUVuQjtJQUMvQnNCLE9BQU90QixPQUFPLEdBQUdBLFFBQVFtQixPQUFPO0FBQ2xDLEVBRUEsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3RyYWNpbmcvcmVwb3J0LXRvLXNvY2tldC5qcz8zODczIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVmYXVsdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcmVwb3J0VG9Tb2NrZXQ7XG4gICAgfVxufSk7XG5jb25zdCBfd2Vic29ja2V0ID0gcmVxdWlyZShcIi4uL2Rldi9lcnJvci1vdmVybGF5L3dlYnNvY2tldFwiKTtcbmZ1bmN0aW9uIHJlcG9ydFRvU29ja2V0KHNwYW4pIHtcbiAgICBpZiAoc3Bhbi5zdGF0ZS5zdGF0ZSAhPT0gXCJlbmRlZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHNwYW4gdG8gYmUgZW5kZWRcIik7XG4gICAgfVxuICAgICgwLCBfd2Vic29ja2V0LnNlbmRNZXNzYWdlKShKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGV2ZW50OiBcInNwYW4tZW5kXCIsXG4gICAgICAgIHN0YXJ0VGltZTogc3Bhbi5zdGFydFRpbWUsXG4gICAgICAgIGVuZFRpbWU6IHNwYW4uc3RhdGUuZW5kVGltZSxcbiAgICAgICAgc3Bhbk5hbWU6IHNwYW4ubmFtZSxcbiAgICAgICAgYXR0cmlidXRlczogc3Bhbi5hdHRyaWJ1dGVzXG4gICAgfSkpO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXBvcnQtdG8tc29ja2V0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJyZXBvcnRUb1NvY2tldCIsIl93ZWJzb2NrZXQiLCJyZXF1aXJlIiwic3BhbiIsInN0YXRlIiwiRXJyb3IiLCJzZW5kTWVzc2FnZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJldmVudCIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJzcGFuTmFtZSIsIm5hbWUiLCJhdHRyaWJ1dGVzIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/tracing/report-to-socket.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/tracing/tracer.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/client/tracing/tracer.js ***!
  \*********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _mitt = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../shared/lib/mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\nclass Span {\n    end(endTime) {\n        if (this.state.state === \"ended\") {\n            throw new Error(\"Span has already ended\");\n        }\n        this.state = {\n            state: \"ended\",\n            endTime: endTime != null ? endTime : Date.now()\n        };\n        this.onSpanEnd(this);\n    }\n    constructor(name, options, onSpanEnd){\n        this.name = name;\n        var _options_attributes;\n        this.attributes = (_options_attributes = options.attributes) != null ? _options_attributes : {};\n        var _options_startTime;\n        this.startTime = (_options_startTime = options.startTime) != null ? _options_startTime : Date.now();\n        this.onSpanEnd = onSpanEnd;\n        this.state = {\n            state: \"inprogress\"\n        };\n    }\n}\nclass Tracer {\n    startSpan(name, options) {\n        return new Span(name, options, this.handleSpanEnd);\n    }\n    onSpanEnd(cb) {\n        this._emitter.on(\"spanend\", cb);\n        return ()=>{\n            this._emitter.off(\"spanend\", cb);\n        };\n    }\n    constructor(){\n        this._emitter = (0, _mitt.default)();\n        this.handleSpanEnd = (span)=>{\n            this._emitter.emit(\"spanend\", span);\n        };\n    }\n}\nconst _default = new Tracer();\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=tracer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC90cmFjaW5nL3RyYWNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsMkNBQTBDO0lBQ3RDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQyw0R0FBeUM7QUFDbEYsTUFBTUMsUUFBUSxXQUFXLEdBQUdGLHlCQUF5QkcsQ0FBQyxDQUFDRixtQkFBT0EsQ0FBQywwRUFBdUI7QUFDdEYsTUFBTUc7SUFDRkMsSUFBSUMsT0FBTyxFQUFFO1FBQ1QsSUFBSSxJQUFJLENBQUNDLEtBQUssQ0FBQ0EsS0FBSyxLQUFLLFNBQVM7WUFDOUIsTUFBTSxJQUFJQyxNQUFNO1FBQ3BCO1FBQ0EsSUFBSSxDQUFDRCxLQUFLLEdBQUc7WUFDVEEsT0FBTztZQUNQRCxTQUFTQSxXQUFXLE9BQU9BLFVBQVVHLEtBQUtDLEdBQUc7UUFDakQ7UUFDQSxJQUFJLENBQUNDLFNBQVMsQ0FBQyxJQUFJO0lBQ3ZCO0lBQ0FDLFlBQVlDLElBQUksRUFBRUMsT0FBTyxFQUFFSCxTQUFTLENBQUM7UUFDakMsSUFBSSxDQUFDRSxJQUFJLEdBQUdBO1FBQ1osSUFBSUU7UUFDSixJQUFJLENBQUNDLFVBQVUsR0FBRyxDQUFDRCxzQkFBc0JELFFBQVFFLFVBQVUsS0FBSyxPQUFPRCxzQkFBc0IsQ0FBQztRQUM5RixJQUFJRTtRQUNKLElBQUksQ0FBQ0MsU0FBUyxHQUFHLENBQUNELHFCQUFxQkgsUUFBUUksU0FBUyxLQUFLLE9BQU9ELHFCQUFxQlIsS0FBS0MsR0FBRztRQUNqRyxJQUFJLENBQUNDLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDSixLQUFLLEdBQUc7WUFDVEEsT0FBTztRQUNYO0lBQ0o7QUFDSjtBQUNBLE1BQU1ZO0lBQ0ZDLFVBQVVQLElBQUksRUFBRUMsT0FBTyxFQUFFO1FBQ3JCLE9BQU8sSUFBSVYsS0FBS1MsTUFBTUMsU0FBUyxJQUFJLENBQUNPLGFBQWE7SUFDckQ7SUFDQVYsVUFBVVcsRUFBRSxFQUFFO1FBQ1YsSUFBSSxDQUFDQyxRQUFRLENBQUNDLEVBQUUsQ0FBQyxXQUFXRjtRQUM1QixPQUFPO1lBQ0gsSUFBSSxDQUFDQyxRQUFRLENBQUNFLEdBQUcsQ0FBQyxXQUFXSDtRQUNqQztJQUNKO0lBQ0FWLGFBQWE7UUFDVCxJQUFJLENBQUNXLFFBQVEsR0FBRyxDQUFDLEdBQUdyQixNQUFNd0IsT0FBTztRQUNqQyxJQUFJLENBQUNMLGFBQWEsR0FBRyxDQUFDTTtZQUNsQixJQUFJLENBQUNKLFFBQVEsQ0FBQ0ssSUFBSSxDQUFDLFdBQVdEO1FBQ2xDO0lBQ0o7QUFDSjtBQUNBLE1BQU01QixXQUFXLElBQUlvQjtBQUVyQixJQUFJLENBQUMsT0FBT3hCLFFBQVErQixPQUFPLEtBQUssY0FBZSxPQUFPL0IsUUFBUStCLE9BQU8sS0FBSyxZQUFZL0IsUUFBUStCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBTy9CLFFBQVErQixPQUFPLENBQUNHLFVBQVUsS0FBSyxhQUFhO0lBQ3JLcEMsT0FBT0MsY0FBYyxDQUFDQyxRQUFRK0IsT0FBTyxFQUFFLGNBQWM7UUFBRTlCLE9BQU87SUFBSztJQUNuRUgsT0FBT3FDLE1BQU0sQ0FBQ25DLFFBQVErQixPQUFPLEVBQUUvQjtJQUMvQm9DLE9BQU9wQyxPQUFPLEdBQUdBLFFBQVErQixPQUFPO0FBQ2xDLEVBRUEsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3RyYWNpbmcvdHJhY2VyLmpzPzA1ODgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdDtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHRcIik7XG5jb25zdCBfbWl0dCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvbWl0dFwiKSk7XG5jbGFzcyBTcGFuIHtcbiAgICBlbmQoZW5kVGltZSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zdGF0ZSA9PT0gXCJlbmRlZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTcGFuIGhhcyBhbHJlYWR5IGVuZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBzdGF0ZTogXCJlbmRlZFwiLFxuICAgICAgICAgICAgZW5kVGltZTogZW5kVGltZSAhPSBudWxsID8gZW5kVGltZSA6IERhdGUubm93KClcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblNwYW5FbmQodGhpcyk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIG9wdGlvbnMsIG9uU3BhbkVuZCl7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHZhciBfb3B0aW9uc19hdHRyaWJ1dGVzO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSAoX29wdGlvbnNfYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcykgIT0gbnVsbCA/IF9vcHRpb25zX2F0dHJpYnV0ZXMgOiB7fTtcbiAgICAgICAgdmFyIF9vcHRpb25zX3N0YXJ0VGltZTtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSAoX29wdGlvbnNfc3RhcnRUaW1lID0gb3B0aW9ucy5zdGFydFRpbWUpICE9IG51bGwgPyBfb3B0aW9uc19zdGFydFRpbWUgOiBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLm9uU3BhbkVuZCA9IG9uU3BhbkVuZDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHN0YXRlOiBcImlucHJvZ3Jlc3NcIlxuICAgICAgICB9O1xuICAgIH1cbn1cbmNsYXNzIFRyYWNlciB7XG4gICAgc3RhcnRTcGFuKG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTcGFuKG5hbWUsIG9wdGlvbnMsIHRoaXMuaGFuZGxlU3BhbkVuZCk7XG4gICAgfVxuICAgIG9uU3BhbkVuZChjYikge1xuICAgICAgICB0aGlzLl9lbWl0dGVyLm9uKFwic3BhbmVuZFwiLCBjYik7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgdGhpcy5fZW1pdHRlci5vZmYoXCJzcGFuZW5kXCIsIGNiKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5fZW1pdHRlciA9ICgwLCBfbWl0dC5kZWZhdWx0KSgpO1xuICAgICAgICB0aGlzLmhhbmRsZVNwYW5FbmQgPSAoc3Bhbik9PntcbiAgICAgICAgICAgIHRoaXMuX2VtaXR0ZXIuZW1pdChcInNwYW5lbmRcIiwgc3Bhbik7XG4gICAgICAgIH07XG4gICAgfVxufVxuY29uc3QgX2RlZmF1bHQgPSBuZXcgVHJhY2VyKCk7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYWNlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX2RlZmF1bHQiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiX21pdHQiLCJfIiwiU3BhbiIsImVuZCIsImVuZFRpbWUiLCJzdGF0ZSIsIkVycm9yIiwiRGF0ZSIsIm5vdyIsIm9uU3BhbkVuZCIsImNvbnN0cnVjdG9yIiwibmFtZSIsIm9wdGlvbnMiLCJfb3B0aW9uc19hdHRyaWJ1dGVzIiwiYXR0cmlidXRlcyIsIl9vcHRpb25zX3N0YXJ0VGltZSIsInN0YXJ0VGltZSIsIlRyYWNlciIsInN0YXJ0U3BhbiIsImhhbmRsZVNwYW5FbmQiLCJjYiIsIl9lbWl0dGVyIiwib24iLCJvZmYiLCJkZWZhdWx0Iiwic3BhbiIsImVtaXQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/tracing/tracer.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/webpack.js":
/*!**************************************************!*\
  !*** ./node_modules/next/dist/client/webpack.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst addChunkSuffix = (getOriginalChunk)=>(chunkId)=>{\n        return getOriginalChunk(chunkId) + (\"\" + ( false ? 0 : \"\"));\n    };\n// ensure dynamic imports have deployment id added if enabled\nconst getChunkScriptFilename = __webpack_require__.u;\n// eslint-disable-next-line no-undef\n__webpack_require__.u = addChunkSuffix(getChunkScriptFilename);\n// eslint-disable-next-line no-undef\nconst getChunkCssFilename = __webpack_require__.k;\n// eslint-disable-next-line no-undef\n__webpack_require__.k = addChunkSuffix(getChunkCssFilename);\n// eslint-disable-next-line no-undef\nconst getMiniCssFilename = __webpack_require__.miniCssF;\n// eslint-disable-next-line no-undef\n__webpack_require__.miniCssF = addChunkSuffix(getMiniCssFilename);\nself.__next_require__ = __webpack_require__;\nself.__next_set_public_path__ = (path)=>{\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    __webpack_require__.p = path;\n};\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=webpack.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC93ZWJwYWNrLmpzIiwibWFwcGluZ3MiOiJBQUFBLDZEQUE2RDtBQUNoRDtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixNQUFNQyxpQkFBaUIsQ0FBQ0MsbUJBQW1CLENBQUNDO1FBQ3BDLE9BQU9ELGlCQUFpQkMsV0FBWSxNQUFNQyxDQUFBQSxNQUE4QixHQUFHLENBQXdDLEdBQUcsRUFBQyxDQUFDO0lBQzVIO0FBQ0osNkRBQTZEO0FBQzdELE1BQU1HLHlCQUF5QkMsbUJBQW1CQSxDQUFDQyxDQUFDO0FBQ3BELG9DQUFvQztBQUNwQ0QsbUJBQW1CQSxDQUFDQyxDQUFDLEdBQUdSLGVBQWVNO0FBQ3ZDLG9DQUFvQztBQUNwQyxNQUFNRyxzQkFBc0JGLG1CQUFtQkEsQ0FBQ0csQ0FBQztBQUNqRCxvQ0FBb0M7QUFDcENILG1CQUFtQkEsQ0FBQ0csQ0FBQyxHQUFHVixlQUFlUztBQUN2QyxvQ0FBb0M7QUFDcEMsTUFBTUUscUJBQXFCSixtQkFBbUJBLENBQUNLLFFBQVE7QUFDdkQsb0NBQW9DO0FBQ3BDTCxtQkFBbUJBLENBQUNLLFFBQVEsR0FBR1osZUFBZVc7QUFDOUNFLEtBQUtDLGdCQUFnQixHQUFHUCxtQkFBbUJBO0FBQzNDTSxLQUFLRSx3QkFBd0IsR0FBRyxDQUFDQztJQUM3Qiw2REFBNkQ7SUFDN0RDLHFCQUF1QkEsR0FBR0Q7QUFDOUI7QUFFQSxJQUFJLENBQUMsT0FBT2xCLFFBQVFvQixPQUFPLEtBQUssY0FBZSxPQUFPcEIsUUFBUW9CLE9BQU8sS0FBSyxZQUFZcEIsUUFBUW9CLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT3BCLFFBQVFvQixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLdkIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRb0IsT0FBTyxFQUFFLGNBQWM7UUFBRW5CLE9BQU87SUFBSztJQUNuRUgsT0FBT3dCLE1BQU0sQ0FBQ3RCLFFBQVFvQixPQUFPLEVBQUVwQjtJQUMvQnVCLE9BQU92QixPQUFPLEdBQUdBLFFBQVFvQixPQUFPO0FBQ2xDLEVBRUEsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3dlYnBhY2suanM/MDhkOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmNvbnN0IGFkZENodW5rU3VmZml4ID0gKGdldE9yaWdpbmFsQ2h1bmspPT4oY2h1bmtJZCk9PntcbiAgICAgICAgcmV0dXJuIGdldE9yaWdpbmFsQ2h1bmsoY2h1bmtJZCkgKyAoXCJcIiArIChwcm9jZXNzLmVudi5ORVhUX0RFUExPWU1FTlRfSUQgPyBcIj9kcGw9XCIgKyBwcm9jZXNzLmVudi5ORVhUX0RFUExPWU1FTlRfSUQgOiBcIlwiKSk7XG4gICAgfTtcbi8vIGVuc3VyZSBkeW5hbWljIGltcG9ydHMgaGF2ZSBkZXBsb3ltZW50IGlkIGFkZGVkIGlmIGVuYWJsZWRcbmNvbnN0IGdldENodW5rU2NyaXB0RmlsZW5hbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLnU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbl9fd2VicGFja19yZXF1aXJlX18udSA9IGFkZENodW5rU3VmZml4KGdldENodW5rU2NyaXB0RmlsZW5hbWUpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5jb25zdCBnZXRDaHVua0Nzc0ZpbGVuYW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXy5rO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmsgPSBhZGRDaHVua1N1ZmZpeChnZXRDaHVua0Nzc0ZpbGVuYW1lKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuY29uc3QgZ2V0TWluaUNzc0ZpbGVuYW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXy5taW5pQ3NzRjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuX193ZWJwYWNrX3JlcXVpcmVfXy5taW5pQ3NzRiA9IGFkZENodW5rU3VmZml4KGdldE1pbmlDc3NGaWxlbmFtZSk7XG5zZWxmLl9fbmV4dF9yZXF1aXJlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fO1xuc2VsZi5fX25leHRfc2V0X3B1YmxpY19wYXRoX18gPSAocGF0aCk9PntcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gPSBwYXRoO1xufTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2VicGFjay5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJhZGRDaHVua1N1ZmZpeCIsImdldE9yaWdpbmFsQ2h1bmsiLCJjaHVua0lkIiwicHJvY2VzcyIsImVudiIsIk5FWFRfREVQTE9ZTUVOVF9JRCIsImdldENodW5rU2NyaXB0RmlsZW5hbWUiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwidSIsImdldENodW5rQ3NzRmlsZW5hbWUiLCJrIiwiZ2V0TWluaUNzc0ZpbGVuYW1lIiwibWluaUNzc0YiLCJzZWxmIiwiX19uZXh0X3JlcXVpcmVfXyIsIl9fbmV4dF9zZXRfcHVibGljX3BhdGhfXyIsInBhdGgiLCJfX3dlYnBhY2tfcHVibGljX3BhdGhfXyIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/webpack.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/adapters.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/adapters.js ***!
  \**************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    adaptForAppRouterInstance: function() {\n        return adaptForAppRouterInstance;\n    },\n    adaptForSearchParams: function() {\n        return adaptForSearchParams;\n    },\n    PathnameContextProviderAdapter: function() {\n        return PathnameContextProviderAdapter;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nconst _hooksclientcontext = __webpack_require__(/*! ../hooks-client-context */ \"./node_modules/next/dist/shared/lib/hooks-client-context.js\");\nconst _utils = __webpack_require__(/*! ./utils */ \"./node_modules/next/dist/shared/lib/router/utils/index.js\");\nfunction adaptForAppRouterInstance(router) {\n    return {\n        back () {\n            router.back();\n        },\n        forward () {\n            router.forward();\n        },\n        refresh () {\n            router.reload();\n        },\n        push (href, param) {\n            let { scroll } = param === void 0 ? {} : param;\n            void router.push(href, undefined, {\n                scroll\n            });\n        },\n        replace (href, param) {\n            let { scroll } = param === void 0 ? {} : param;\n            void router.replace(href, undefined, {\n                scroll\n            });\n        },\n        prefetch (href) {\n            void router.prefetch(href);\n        }\n    };\n}\n/**\n * transforms the ParsedUrlQuery into a URLSearchParams.\n *\n * @param query the query to transform\n * @returns URLSearchParams\n */ function transformQuery(query) {\n    const params = new URLSearchParams();\n    for (const [name, value] of Object.entries(query)){\n        if (Array.isArray(value)) {\n            for (const val of value){\n                params.append(name, val);\n            }\n        } else if (typeof value !== \"undefined\") {\n            params.append(name, value);\n        }\n    }\n    return params;\n}\nfunction adaptForSearchParams(router) {\n    if (!router.isReady || !router.query) {\n        return new URLSearchParams();\n    }\n    return transformQuery(router.query);\n}\nfunction PathnameContextProviderAdapter(param) {\n    let { children, router, ...props } = param;\n    const ref = (0, _react.useRef)(props.isAutoExport);\n    const value = (0, _react.useMemo)(()=>{\n        // isAutoExport is only ever `true` on the first render from the server,\n        // so reset it to `false` after we read it for the first time as `true`. If\n        // we don't use the value, then we don't need it.\n        const isAutoExport = ref.current;\n        if (isAutoExport) {\n            ref.current = false;\n        }\n        // When the route is a dynamic route, we need to do more processing to\n        // determine if we need to stop showing the pathname.\n        if ((0, _utils.isDynamicRoute)(router.pathname)) {\n            // When the router is rendering the fallback page, it can't possibly know\n            // the path, so return `null` here. Read more about fallback pages over\n            // at:\n            // https://nextjs.org/docs/api-reference/data-fetching/get-static-paths#fallback-pages\n            if (router.isFallback) {\n                return null;\n            }\n            // When `isAutoExport` is true, meaning this is a page page has been\n            // automatically statically optimized, and the router is not ready, then\n            // we can't know the pathname yet. Read more about automatic static\n            // optimization at:\n            // https://nextjs.org/docs/advanced-features/automatic-static-optimization\n            if (isAutoExport && !router.isReady) {\n                return null;\n            }\n        }\n        // The `router.asPath` contains the pathname seen by the browser (including\n        // any query strings), so it should have that stripped. Read more about the\n        // `asPath` option over at:\n        // https://nextjs.org/docs/api-reference/next/router#router-object\n        let url;\n        try {\n            url = new URL(router.asPath, \"http://f\");\n        } catch (_) {\n            // fallback to / for invalid asPath values e.g. //\n            return \"/\";\n        }\n        return url.pathname;\n    }, [\n        router.asPath,\n        router.isFallback,\n        router.isReady,\n        router.pathname\n    ]);\n    return /*#__PURE__*/ _react.default.createElement(_hooksclientcontext.PathnameContext.Provider, {\n        value: value\n    }, children);\n} //# sourceMappingURL=adapters.js.map\n_c = PathnameContextProviderAdapter;\nvar _c;\n$RefreshReg$(_c, \"PathnameContextProviderAdapter\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL2FkYXB0ZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGLEtBQU1DLENBQUFBLENBSU47QUFDQSxTQUFTSSxRQUFRQyxNQUFNLEVBQUVDLEdBQUc7SUFDeEIsSUFBSSxJQUFJQyxRQUFRRCxJQUFJVixPQUFPQyxjQUFjLENBQUNRLFFBQVFFLE1BQU07UUFDcERDLFlBQVk7UUFDWkMsS0FBS0gsR0FBRyxDQUFDQyxLQUFLO0lBQ2xCO0FBQ0o7QUFDQUgsUUFBUU4sU0FBUztJQUNiRywyQkFBMkI7UUFDdkIsT0FBT0E7SUFDWDtJQUNBQyxzQkFBc0I7UUFDbEIsT0FBT0E7SUFDWDtJQUNBQyxnQ0FBZ0M7UUFDNUIsT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTU8sNEJBQTRCQyxtQkFBT0EsQ0FBQyw4R0FBMEM7QUFDcEYsTUFBTUMsU0FBUyxXQUFXLEdBQUdGLDBCQUEwQkcsQ0FBQyxDQUFDRixtQkFBT0EsQ0FBQyw0Q0FBTztBQUN4RSxNQUFNRyxzQkFBc0JILG1CQUFPQSxDQUFDLDRGQUF5QjtBQUM3RCxNQUFNSSxTQUFTSixtQkFBT0EsQ0FBQywwRUFBUztBQUNoQyxTQUFTViwwQkFBMEJlLE1BQU07SUFDckMsT0FBTztRQUNIQztZQUNJRCxPQUFPQyxJQUFJO1FBQ2Y7UUFDQUM7WUFDSUYsT0FBT0UsT0FBTztRQUNsQjtRQUNBQztZQUNJSCxPQUFPSSxNQUFNO1FBQ2pCO1FBQ0FDLE1BQU1DLElBQUksRUFBRUMsS0FBSztZQUNiLElBQUksRUFBRUMsTUFBTSxFQUFHLEdBQUdELFVBQVUsS0FBSyxJQUFJLENBQUMsSUFBSUE7WUFDMUMsS0FBS1AsT0FBT0ssSUFBSSxDQUFDQyxNQUFNRyxXQUFXO2dCQUM5QkQ7WUFDSjtRQUNKO1FBQ0FFLFNBQVNKLElBQUksRUFBRUMsS0FBSztZQUNoQixJQUFJLEVBQUVDLE1BQU0sRUFBRyxHQUFHRCxVQUFVLEtBQUssSUFBSSxDQUFDLElBQUlBO1lBQzFDLEtBQUtQLE9BQU9VLE9BQU8sQ0FBQ0osTUFBTUcsV0FBVztnQkFDakNEO1lBQ0o7UUFDSjtRQUNBRyxVQUFVTCxJQUFJO1lBQ1YsS0FBS04sT0FBT1csUUFBUSxDQUFDTDtRQUN6QjtJQUNKO0FBQ0o7QUFDQTs7Ozs7Q0FLQyxHQUFHLFNBQVNNLGVBQWVDLEtBQUs7SUFDN0IsTUFBTUMsU0FBUyxJQUFJQztJQUNuQixLQUFLLE1BQU0sQ0FBQ3hCLE1BQU1SLE1BQU0sSUFBSUgsT0FBT29DLE9BQU8sQ0FBQ0gsT0FBTztRQUM5QyxJQUFJSSxNQUFNQyxPQUFPLENBQUNuQyxRQUFRO1lBQ3RCLEtBQUssTUFBTW9DLE9BQU9wQyxNQUFNO2dCQUNwQitCLE9BQU9NLE1BQU0sQ0FBQzdCLE1BQU00QjtZQUN4QjtRQUNKLE9BQU8sSUFBSSxPQUFPcEMsVUFBVSxhQUFhO1lBQ3JDK0IsT0FBT00sTUFBTSxDQUFDN0IsTUFBTVI7UUFDeEI7SUFDSjtJQUNBLE9BQU8rQjtBQUNYO0FBQ0EsU0FBUzVCLHFCQUFxQmMsTUFBTTtJQUNoQyxJQUFJLENBQUNBLE9BQU9xQixPQUFPLElBQUksQ0FBQ3JCLE9BQU9hLEtBQUssRUFBRTtRQUNsQyxPQUFPLElBQUlFO0lBQ2Y7SUFDQSxPQUFPSCxlQUFlWixPQUFPYSxLQUFLO0FBQ3RDO0FBQ0EsU0FBUzFCLCtCQUErQm9CLEtBQUs7SUFDekMsSUFBSSxFQUFFZSxRQUFRLEVBQUd0QixNQUFNLEVBQUcsR0FBR3VCLE9BQU8sR0FBR2hCO0lBQ3ZDLE1BQU1pQixNQUFNLENBQUMsR0FBRzVCLE9BQU82QixNQUFNLEVBQUVGLE1BQU1HLFlBQVk7SUFDakQsTUFBTTNDLFFBQVEsQ0FBQyxHQUFHYSxPQUFPK0IsT0FBTyxFQUFFO1FBQzlCLHdFQUF3RTtRQUN4RSwyRUFBMkU7UUFDM0UsaURBQWlEO1FBQ2pELE1BQU1ELGVBQWVGLElBQUlJLE9BQU87UUFDaEMsSUFBSUYsY0FBYztZQUNkRixJQUFJSSxPQUFPLEdBQUc7UUFDbEI7UUFDQSxzRUFBc0U7UUFDdEUscURBQXFEO1FBQ3JELElBQUksQ0FBQyxHQUFHN0IsT0FBTzhCLGNBQWMsRUFBRTdCLE9BQU84QixRQUFRLEdBQUc7WUFDN0MseUVBQXlFO1lBQ3pFLHVFQUF1RTtZQUN2RSxNQUFNO1lBQ04sc0ZBQXNGO1lBQ3RGLElBQUk5QixPQUFPK0IsVUFBVSxFQUFFO2dCQUNuQixPQUFPO1lBQ1g7WUFDQSxvRUFBb0U7WUFDcEUsd0VBQXdFO1lBQ3hFLG1FQUFtRTtZQUNuRSxtQkFBbUI7WUFDbkIsMEVBQTBFO1lBQzFFLElBQUlMLGdCQUFnQixDQUFDMUIsT0FBT3FCLE9BQU8sRUFBRTtnQkFDakMsT0FBTztZQUNYO1FBQ0o7UUFDQSwyRUFBMkU7UUFDM0UsMkVBQTJFO1FBQzNFLDJCQUEyQjtRQUMzQixrRUFBa0U7UUFDbEUsSUFBSVc7UUFDSixJQUFJO1lBQ0FBLE1BQU0sSUFBSUMsSUFBSWpDLE9BQU9rQyxNQUFNLEVBQUU7UUFDakMsRUFBRSxPQUFPckMsR0FBRztZQUNSLGtEQUFrRDtZQUNsRCxPQUFPO1FBQ1g7UUFDQSxPQUFPbUMsSUFBSUYsUUFBUTtJQUN2QixHQUFHO1FBQ0M5QixPQUFPa0MsTUFBTTtRQUNibEMsT0FBTytCLFVBQVU7UUFDakIvQixPQUFPcUIsT0FBTztRQUNkckIsT0FBTzhCLFFBQVE7S0FDbEI7SUFDRCxPQUFPLFdBQVcsR0FBR2xDLE9BQU91QyxPQUFPLENBQUNDLGFBQWEsQ0FBQ3RDLG9CQUFvQnVDLGVBQWUsQ0FBQ0MsUUFBUSxFQUFFO1FBQzVGdkQsT0FBT0E7SUFDWCxHQUFHdUM7QUFDUCxFQUVBLG9DQUFvQztLQXJEM0JuQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL2FkYXB0ZXJzLmpzP2U2NzUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBhZGFwdEZvckFwcFJvdXRlckluc3RhbmNlOiBudWxsLFxuICAgIGFkYXB0Rm9yU2VhcmNoUGFyYW1zOiBudWxsLFxuICAgIFBhdGhuYW1lQ29udGV4dFByb3ZpZGVyQWRhcHRlcjogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBhZGFwdEZvckFwcFJvdXRlckluc3RhbmNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGFkYXB0Rm9yQXBwUm91dGVySW5zdGFuY2U7XG4gICAgfSxcbiAgICBhZGFwdEZvclNlYXJjaFBhcmFtczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBhZGFwdEZvclNlYXJjaFBhcmFtcztcbiAgICB9LFxuICAgIFBhdGhuYW1lQ29udGV4dFByb3ZpZGVyQWRhcHRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQYXRobmFtZUNvbnRleHRQcm92aWRlckFkYXB0ZXI7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmRcIik7XG5jb25zdCBfcmVhY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuXyhyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgX2hvb2tzY2xpZW50Y29udGV4dCA9IHJlcXVpcmUoXCIuLi9ob29rcy1jbGllbnQtY29udGV4dFwiKTtcbmNvbnN0IF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZnVuY3Rpb24gYWRhcHRGb3JBcHBSb3V0ZXJJbnN0YW5jZShyb3V0ZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBiYWNrICgpIHtcbiAgICAgICAgICAgIHJvdXRlci5iYWNrKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZvcndhcmQgKCkge1xuICAgICAgICAgICAgcm91dGVyLmZvcndhcmQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVmcmVzaCAoKSB7XG4gICAgICAgICAgICByb3V0ZXIucmVsb2FkKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHB1c2ggKGhyZWYsIHBhcmFtKSB7XG4gICAgICAgICAgICBsZXQgeyBzY3JvbGwgIH0gPSBwYXJhbSA9PT0gdm9pZCAwID8ge30gOiBwYXJhbTtcbiAgICAgICAgICAgIHZvaWQgcm91dGVyLnB1c2goaHJlZiwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVwbGFjZSAoaHJlZiwgcGFyYW0pIHtcbiAgICAgICAgICAgIGxldCB7IHNjcm9sbCAgfSA9IHBhcmFtID09PSB2b2lkIDAgPyB7fSA6IHBhcmFtO1xuICAgICAgICAgICAgdm9pZCByb3V0ZXIucmVwbGFjZShocmVmLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBwcmVmZXRjaCAoaHJlZikge1xuICAgICAgICAgICAgdm9pZCByb3V0ZXIucHJlZmV0Y2goaHJlZik7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG4gKiB0cmFuc2Zvcm1zIHRoZSBQYXJzZWRVcmxRdWVyeSBpbnRvIGEgVVJMU2VhcmNoUGFyYW1zLlxuICpcbiAqIEBwYXJhbSBxdWVyeSB0aGUgcXVlcnkgdG8gdHJhbnNmb3JtXG4gKiBAcmV0dXJucyBVUkxTZWFyY2hQYXJhbXNcbiAqLyBmdW5jdGlvbiB0cmFuc2Zvcm1RdWVyeShxdWVyeSkge1xuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocXVlcnkpKXtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB2YWx1ZSl7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChuYW1lLCB2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcztcbn1cbmZ1bmN0aW9uIGFkYXB0Rm9yU2VhcmNoUGFyYW1zKHJvdXRlcikge1xuICAgIGlmICghcm91dGVyLmlzUmVhZHkgfHwgIXJvdXRlci5xdWVyeSkge1xuICAgICAgICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNmb3JtUXVlcnkocm91dGVyLnF1ZXJ5KTtcbn1cbmZ1bmN0aW9uIFBhdGhuYW1lQ29udGV4dFByb3ZpZGVyQWRhcHRlcihwYXJhbSkge1xuICAgIGxldCB7IGNoaWxkcmVuICwgcm91dGVyICwgLi4ucHJvcHMgfSA9IHBhcmFtO1xuICAgIGNvbnN0IHJlZiA9ICgwLCBfcmVhY3QudXNlUmVmKShwcm9wcy5pc0F1dG9FeHBvcnQpO1xuICAgIGNvbnN0IHZhbHVlID0gKDAsIF9yZWFjdC51c2VNZW1vKSgoKT0+e1xuICAgICAgICAvLyBpc0F1dG9FeHBvcnQgaXMgb25seSBldmVyIGB0cnVlYCBvbiB0aGUgZmlyc3QgcmVuZGVyIGZyb20gdGhlIHNlcnZlcixcbiAgICAgICAgLy8gc28gcmVzZXQgaXQgdG8gYGZhbHNlYCBhZnRlciB3ZSByZWFkIGl0IGZvciB0aGUgZmlyc3QgdGltZSBhcyBgdHJ1ZWAuIElmXG4gICAgICAgIC8vIHdlIGRvbid0IHVzZSB0aGUgdmFsdWUsIHRoZW4gd2UgZG9uJ3QgbmVlZCBpdC5cbiAgICAgICAgY29uc3QgaXNBdXRvRXhwb3J0ID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChpc0F1dG9FeHBvcnQpIHtcbiAgICAgICAgICAgIHJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hlbiB0aGUgcm91dGUgaXMgYSBkeW5hbWljIHJvdXRlLCB3ZSBuZWVkIHRvIGRvIG1vcmUgcHJvY2Vzc2luZyB0b1xuICAgICAgICAvLyBkZXRlcm1pbmUgaWYgd2UgbmVlZCB0byBzdG9wIHNob3dpbmcgdGhlIHBhdGhuYW1lLlxuICAgICAgICBpZiAoKDAsIF91dGlscy5pc0R5bmFtaWNSb3V0ZSkocm91dGVyLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgLy8gV2hlbiB0aGUgcm91dGVyIGlzIHJlbmRlcmluZyB0aGUgZmFsbGJhY2sgcGFnZSwgaXQgY2FuJ3QgcG9zc2libHkga25vd1xuICAgICAgICAgICAgLy8gdGhlIHBhdGgsIHNvIHJldHVybiBgbnVsbGAgaGVyZS4gUmVhZCBtb3JlIGFib3V0IGZhbGxiYWNrIHBhZ2VzIG92ZXJcbiAgICAgICAgICAgIC8vIGF0OlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9kYXRhLWZldGNoaW5nL2dldC1zdGF0aWMtcGF0aHMjZmFsbGJhY2stcGFnZXNcbiAgICAgICAgICAgIGlmIChyb3V0ZXIuaXNGYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2hlbiBgaXNBdXRvRXhwb3J0YCBpcyB0cnVlLCBtZWFuaW5nIHRoaXMgaXMgYSBwYWdlIHBhZ2UgaGFzIGJlZW5cbiAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgc3RhdGljYWxseSBvcHRpbWl6ZWQsIGFuZCB0aGUgcm91dGVyIGlzIG5vdCByZWFkeSwgdGhlblxuICAgICAgICAgICAgLy8gd2UgY2FuJ3Qga25vdyB0aGUgcGF0aG5hbWUgeWV0LiBSZWFkIG1vcmUgYWJvdXQgYXV0b21hdGljIHN0YXRpY1xuICAgICAgICAgICAgLy8gb3B0aW1pemF0aW9uIGF0OlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYWR2YW5jZWQtZmVhdHVyZXMvYXV0b21hdGljLXN0YXRpYy1vcHRpbWl6YXRpb25cbiAgICAgICAgICAgIGlmIChpc0F1dG9FeHBvcnQgJiYgIXJvdXRlci5pc1JlYWR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGByb3V0ZXIuYXNQYXRoYCBjb250YWlucyB0aGUgcGF0aG5hbWUgc2VlbiBieSB0aGUgYnJvd3NlciAoaW5jbHVkaW5nXG4gICAgICAgIC8vIGFueSBxdWVyeSBzdHJpbmdzKSwgc28gaXQgc2hvdWxkIGhhdmUgdGhhdCBzdHJpcHBlZC4gUmVhZCBtb3JlIGFib3V0IHRoZVxuICAgICAgICAvLyBgYXNQYXRoYCBvcHRpb24gb3ZlciBhdDpcbiAgICAgICAgLy8gaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L3JvdXRlciNyb3V0ZXItb2JqZWN0XG4gICAgICAgIGxldCB1cmw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB1cmwgPSBuZXcgVVJMKHJvdXRlci5hc1BhdGgsIFwiaHR0cDovL2ZcIik7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRvIC8gZm9yIGludmFsaWQgYXNQYXRoIHZhbHVlcyBlLmcuIC8vXG4gICAgICAgICAgICByZXR1cm4gXCIvXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybC5wYXRobmFtZTtcbiAgICB9LCBbXG4gICAgICAgIHJvdXRlci5hc1BhdGgsXG4gICAgICAgIHJvdXRlci5pc0ZhbGxiYWNrLFxuICAgICAgICByb3V0ZXIuaXNSZWFkeSxcbiAgICAgICAgcm91dGVyLnBhdGhuYW1lXG4gICAgXSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfaG9va3NjbGllbnRjb250ZXh0LlBhdGhuYW1lQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICB9LCBjaGlsZHJlbik7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkYXB0ZXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsImFkYXB0Rm9yQXBwUm91dGVySW5zdGFuY2UiLCJhZGFwdEZvclNlYXJjaFBhcmFtcyIsIlBhdGhuYW1lQ29udGV4dFByb3ZpZGVyQWRhcHRlciIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJyZXF1aXJlIiwiX3JlYWN0IiwiXyIsIl9ob29rc2NsaWVudGNvbnRleHQiLCJfdXRpbHMiLCJyb3V0ZXIiLCJiYWNrIiwiZm9yd2FyZCIsInJlZnJlc2giLCJyZWxvYWQiLCJwdXNoIiwiaHJlZiIsInBhcmFtIiwic2Nyb2xsIiwidW5kZWZpbmVkIiwicmVwbGFjZSIsInByZWZldGNoIiwidHJhbnNmb3JtUXVlcnkiLCJxdWVyeSIsInBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsImVudHJpZXMiLCJBcnJheSIsImlzQXJyYXkiLCJ2YWwiLCJhcHBlbmQiLCJpc1JlYWR5IiwiY2hpbGRyZW4iLCJwcm9wcyIsInJlZiIsInVzZVJlZiIsImlzQXV0b0V4cG9ydCIsInVzZU1lbW8iLCJjdXJyZW50IiwiaXNEeW5hbWljUm91dGUiLCJwYXRobmFtZSIsImlzRmFsbGJhY2siLCJ1cmwiLCJVUkwiLCJhc1BhdGgiLCJkZWZhdWx0IiwiY3JlYXRlRWxlbWVudCIsIlBhdGhuYW1lQ29udGV4dCIsIlByb3ZpZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/adapters.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/router.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/router.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// tslint:disable:no-console\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    default: function() {\n        return Router;\n    },\n    matchesMiddleware: function() {\n        return matchesMiddleware;\n    },\n    createKey: function() {\n        return createKey;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _removetrailingslash = __webpack_require__(/*! ./utils/remove-trailing-slash */ \"./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nconst _routeloader = __webpack_require__(/*! ../../../client/route-loader */ \"./node_modules/next/dist/client/route-loader.js\");\nconst _script = __webpack_require__(/*! ../../../client/script */ \"./node_modules/next/dist/client/script.js\");\nconst _iserror = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ../../../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\"));\nconst _denormalizepagepath = __webpack_require__(/*! ../page-path/denormalize-page-path */ \"./node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js\");\nconst _normalizelocalepath = __webpack_require__(/*! ../i18n/normalize-locale-path */ \"./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\nconst _mitt = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\nconst _utils = __webpack_require__(/*! ../utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nconst _isdynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nconst _parserelativeurl = __webpack_require__(/*! ./utils/parse-relative-url */ \"./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\nconst _resolverewrites = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./utils/resolve-rewrites */ \"?506d\"));\nconst _routematcher = __webpack_require__(/*! ./utils/route-matcher */ \"./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nconst _routeregex = __webpack_require__(/*! ./utils/route-regex */ \"./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nconst _formaturl = __webpack_require__(/*! ./utils/format-url */ \"./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _detectdomainlocale = __webpack_require__(/*! ../../../client/detect-domain-locale */ \"./node_modules/next/dist/client/detect-domain-locale.js\");\nconst _parsepath = __webpack_require__(/*! ./utils/parse-path */ \"./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nconst _addlocale = __webpack_require__(/*! ../../../client/add-locale */ \"./node_modules/next/dist/client/add-locale.js\");\nconst _removelocale = __webpack_require__(/*! ../../../client/remove-locale */ \"./node_modules/next/dist/client/remove-locale.js\");\nconst _removebasepath = __webpack_require__(/*! ../../../client/remove-base-path */ \"./node_modules/next/dist/client/remove-base-path.js\");\nconst _addbasepath = __webpack_require__(/*! ../../../client/add-base-path */ \"./node_modules/next/dist/client/add-base-path.js\");\nconst _hasbasepath = __webpack_require__(/*! ../../../client/has-base-path */ \"./node_modules/next/dist/client/has-base-path.js\");\nconst _isapiroute = __webpack_require__(/*! ../../../lib/is-api-route */ \"./node_modules/next/dist/lib/is-api-route.js\");\nconst _getnextpathnameinfo = __webpack_require__(/*! ./utils/get-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js\");\nconst _formatnextpathnameinfo = __webpack_require__(/*! ./utils/format-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js\");\nconst _comparestates = __webpack_require__(/*! ./utils/compare-states */ \"./node_modules/next/dist/shared/lib/router/utils/compare-states.js\");\nconst _islocalurl = __webpack_require__(/*! ./utils/is-local-url */ \"./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _isbot = __webpack_require__(/*! ./utils/is-bot */ \"./node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\nconst _omit = __webpack_require__(/*! ./utils/omit */ \"./node_modules/next/dist/shared/lib/router/utils/omit.js\");\nconst _resolvehref = __webpack_require__(/*! ./utils/resolve-href */ \"./node_modules/next/dist/shared/lib/router/utils/resolve-href.js\");\nconst _interpolateas = __webpack_require__(/*! ./utils/interpolate-as */ \"./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\nconst _handlesmoothscroll = __webpack_require__(/*! ./utils/handle-smooth-scroll */ \"./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\");\nfunction buildCancellationError() {\n    return Object.assign(new Error(\"Route Cancelled\"), {\n        cancelled: true\n    });\n}\nasync function matchesMiddleware(options) {\n    const matchers = await Promise.resolve(options.router.pageLoader.getMiddleware());\n    if (!matchers) return false;\n    const { pathname: asPathname } = (0, _parsepath.parsePath)(options.asPath);\n    // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`\n    const cleanedAs = (0, _hasbasepath.hasBasePath)(asPathname) ? (0, _removebasepath.removeBasePath)(asPathname) : asPathname;\n    const asWithBasePathAndLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, options.locale));\n    // Check only path match on client. Matching \"has\" should be done on server\n    // where we can access more info such as headers, HttpOnly cookie, etc.\n    return matchers.some((m)=>new RegExp(m.regexp).test(asWithBasePathAndLocale));\n}\nfunction stripOrigin(url) {\n    const origin = (0, _utils.getLocationOrigin)();\n    return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction prepareUrlAs(router, url, as) {\n    // If url and as provided as an object representation,\n    // we'll format them into the string version here.\n    let [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(router, url, true);\n    const origin = (0, _utils.getLocationOrigin)();\n    const hrefWasAbsolute = resolvedHref.startsWith(origin);\n    const asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);\n    resolvedHref = stripOrigin(resolvedHref);\n    resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n    const preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addbasepath.addBasePath)(resolvedHref);\n    const preparedAs = as ? stripOrigin((0, _resolvehref.resolveHref)(router, as)) : resolvedAs || resolvedHref;\n    return {\n        url: preparedUrl,\n        as: asWasAbsolute ? preparedAs : (0, _addbasepath.addBasePath)(preparedAs)\n    };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n    const cleanPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _denormalizepagepath.denormalizePagePath)(pathname));\n    if (cleanPathname === \"/404\" || cleanPathname === \"/_error\") {\n        return pathname;\n    }\n    // handle resolving href for dynamic routes\n    if (!pages.includes(cleanPathname)) {\n        // eslint-disable-next-line array-callback-return\n        pages.some((page)=>{\n            if ((0, _isdynamic.isDynamicRoute)(page) && (0, _routeregex.getRouteRegex)(page).re.test(cleanPathname)) {\n                pathname = page;\n                return true;\n            }\n        });\n    }\n    return (0, _removetrailingslash.removeTrailingSlash)(pathname);\n}\nfunction getMiddlewareData(source, response, options) {\n    const nextConfig = {\n        basePath: options.router.basePath,\n        i18n: {\n            locales: options.router.locales\n        },\n        trailingSlash: Boolean(false)\n    };\n    const rewriteHeader = response.headers.get(\"x-nextjs-rewrite\");\n    let rewriteTarget = rewriteHeader || response.headers.get(\"x-nextjs-matched-path\");\n    const matchedPath = response.headers.get(\"x-matched-path\");\n    if (matchedPath && !rewriteTarget && !matchedPath.includes(\"__next_data_catchall\") && !matchedPath.includes(\"/_error\") && !matchedPath.includes(\"/404\")) {\n        // leverage x-matched-path to detect next.config.js rewrites\n        rewriteTarget = matchedPath;\n    }\n    if (rewriteTarget) {\n        if (rewriteTarget.startsWith(\"/\") || undefined) {\n            const parsedRewriteTarget = (0, _parserelativeurl.parseRelativeUrl)(rewriteTarget);\n            const pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(parsedRewriteTarget.pathname, {\n                nextConfig,\n                parseData: true\n            });\n            let fsPathname = (0, _removetrailingslash.removeTrailingSlash)(pathnameInfo.pathname);\n            return Promise.all([\n                options.router.pageLoader.getPageList(),\n                (0, _routeloader.getClientBuildManifest)()\n            ]).then((param)=>{\n                let [pages, { __rewrites: rewrites }] = param;\n                let as = (0, _addlocale.addLocale)(pathnameInfo.pathname, pathnameInfo.locale);\n                if ((0, _isdynamic.isDynamicRoute)(as) || !rewriteHeader && pages.includes((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(as), options.router.locales).pathname)) {\n                    const parsedSource = (0, _getnextpathnameinfo.getNextPathnameInfo)((0, _parserelativeurl.parseRelativeUrl)(source).pathname, {\n                        nextConfig:  false ? 0 : nextConfig,\n                        parseData: true\n                    });\n                    as = (0, _addbasepath.addBasePath)(parsedSource.pathname);\n                    parsedRewriteTarget.pathname = as;\n                }\n                if (false) {} else if (!pages.includes(fsPathname)) {\n                    const resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n                    if (resolvedPathname !== fsPathname) {\n                        fsPathname = resolvedPathname;\n                    }\n                }\n                const resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n                if ((0, _isdynamic.isDynamicRoute)(resolvedHref)) {\n                    const matches = (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(resolvedHref))(as);\n                    Object.assign(parsedRewriteTarget.query, matches || {});\n                }\n                return {\n                    type: \"rewrite\",\n                    parsedAs: parsedRewriteTarget,\n                    resolvedHref\n                };\n            });\n        }\n        const src = (0, _parsepath.parsePath)(source);\n        const pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)({\n            ...(0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n                nextConfig,\n                parseData: true\n            }),\n            defaultLocale: options.router.defaultLocale,\n            buildId: \"\"\n        });\n        return Promise.resolve({\n            type: \"redirect-external\",\n            destination: \"\" + pathname + src.query + src.hash\n        });\n    }\n    const redirectTarget = response.headers.get(\"x-nextjs-redirect\");\n    if (redirectTarget) {\n        if (redirectTarget.startsWith(\"/\")) {\n            const src = (0, _parsepath.parsePath)(redirectTarget);\n            const pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)({\n                ...(0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n                    nextConfig,\n                    parseData: true\n                }),\n                defaultLocale: options.router.defaultLocale,\n                buildId: \"\"\n            });\n            return Promise.resolve({\n                type: \"redirect-internal\",\n                newAs: \"\" + pathname + src.query + src.hash,\n                newUrl: \"\" + pathname + src.query + src.hash\n            });\n        }\n        return Promise.resolve({\n            type: \"redirect-external\",\n            destination: redirectTarget\n        });\n    }\n    return Promise.resolve({\n        type: \"next\"\n    });\n}\nasync function withMiddlewareEffects(options) {\n    const matches = await matchesMiddleware(options);\n    if (!matches || !options.fetchData) {\n        return null;\n    }\n    try {\n        const data = await options.fetchData();\n        const effect = await getMiddlewareData(data.dataHref, data.response, options);\n        return {\n            dataHref: data.dataHref,\n            json: data.json,\n            response: data.response,\n            text: data.text,\n            cacheKey: data.cacheKey,\n            effect\n        };\n    } catch (e) {\n        /**\n     * TODO: Revisit this in the future.\n     * For now we will not consider middleware data errors to be fatal.\n     * maybe we should revisit in the future.\n     */ return null;\n    }\n}\nconst manualScrollRestoration =  false && 0;\nconst SSG_DATA_NOT_FOUND = Symbol(\"SSG_DATA_NOT_FOUND\");\nfunction fetchRetry(url, attempts, options) {\n    return fetch(url, {\n        // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n        // Cookies may also be required for `getServerSideProps`.\n        //\n        // > `fetch` wont send cookies, unless you set the credentials init\n        // > option.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n        //\n        // > For maximum browser compatibility when it comes to sending &\n        // > receiving cookies, always supply the `credentials: 'same-origin'`\n        // > option instead of relying on the default.\n        // https://github.com/github/fetch#caveats\n        credentials: \"same-origin\",\n        method: options.method || \"GET\",\n        headers: Object.assign({}, options.headers, {\n            \"x-nextjs-data\": \"1\"\n        })\n    }).then((response)=>{\n        return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n    });\n}\nfunction tryToParseAsJSON(text) {\n    try {\n        return JSON.parse(text);\n    } catch (error) {\n        return null;\n    }\n}\nfunction fetchNextData(param) {\n    let { dataHref, inflightCache, isPrefetch, hasMiddleware, isServerRender, parseJSON, persistCache, isBackground, unstable_skipClientCache } = param;\n    const { href: cacheKey } = new URL(dataHref, window.location.href);\n    var _params_method;\n    const getData = (params)=>{\n        return fetchRetry(dataHref, isServerRender ? 3 : 1, {\n            headers: Object.assign({}, isPrefetch ? {\n                purpose: \"prefetch\"\n            } : {}, isPrefetch && hasMiddleware ? {\n                \"x-middleware-prefetch\": \"1\"\n            } : {}),\n            method: (_params_method = params == null ? void 0 : params.method) != null ? _params_method : \"GET\"\n        }).then((response)=>{\n            if (response.ok && (params == null ? void 0 : params.method) === \"HEAD\") {\n                return {\n                    dataHref,\n                    response,\n                    text: \"\",\n                    json: {},\n                    cacheKey\n                };\n            }\n            return response.text().then((text)=>{\n                if (!response.ok) {\n                    /**\n             * When the data response is a redirect because of a middleware\n             * we do not consider it an error. The headers must bring the\n             * mapped location.\n             * TODO: Change the status code in the handler.\n             */ if (hasMiddleware && [\n                        301,\n                        302,\n                        307,\n                        308\n                    ].includes(response.status)) {\n                        return {\n                            dataHref,\n                            response,\n                            text,\n                            json: {},\n                            cacheKey\n                        };\n                    }\n                    if (response.status === 404) {\n                        var _tryToParseAsJSON;\n                        if ((_tryToParseAsJSON = tryToParseAsJSON(text)) == null ? void 0 : _tryToParseAsJSON.notFound) {\n                            return {\n                                dataHref,\n                                json: {\n                                    notFound: SSG_DATA_NOT_FOUND\n                                },\n                                response,\n                                text,\n                                cacheKey\n                            };\n                        }\n                    }\n                    const error = new Error(\"Failed to load static props\");\n                    /**\n             * We should only trigger a server-side transition if this was\n             * caused on a client-side transition. Otherwise, we'd get into\n             * an infinite loop.\n             */ if (!isServerRender) {\n                        (0, _routeloader.markAssetError)(error);\n                    }\n                    throw error;\n                }\n                return {\n                    dataHref,\n                    json: parseJSON ? tryToParseAsJSON(text) : null,\n                    response,\n                    text,\n                    cacheKey\n                };\n            });\n        }).then((data)=>{\n            if (!persistCache || \"development\" !== \"production\" || 0) {\n                delete inflightCache[cacheKey];\n            }\n            return data;\n        }).catch((err)=>{\n            if (!unstable_skipClientCache) {\n                delete inflightCache[cacheKey];\n            }\n            if (err.message === \"Failed to fetch\" || // firefox\n            err.message === \"NetworkError when attempting to fetch resource.\" || // safari\n            err.message === \"Load failed\") {\n                (0, _routeloader.markAssetError)(err);\n            }\n            throw err;\n        });\n    };\n    // when skipping client cache we wait to update\n    // inflight cache until successful data response\n    // this allows racing click event with fetching newer data\n    // without blocking navigation when stale data is available\n    if (unstable_skipClientCache && persistCache) {\n        return getData({}).then((data)=>{\n            inflightCache[cacheKey] = Promise.resolve(data);\n            return data;\n        });\n    }\n    if (inflightCache[cacheKey] !== undefined) {\n        return inflightCache[cacheKey];\n    }\n    return inflightCache[cacheKey] = getData(isBackground ? {\n        method: \"HEAD\"\n    } : {});\n}\nfunction createKey() {\n    return Math.random().toString(36).slice(2, 10);\n}\nfunction handleHardNavigation(param) {\n    let { url, router } = param;\n    // ensure we don't trigger a hard navigation to the same\n    // URL as this can end up with an infinite refresh\n    if (url === (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(router.asPath, router.locale))) {\n        throw new Error(\"Invariant: attempted to hard navigate to the same URL \" + url + \" \" + location.href);\n    }\n    window.location.href = url;\n}\nconst getCancelledHandler = (param)=>{\n    let { route, router } = param;\n    let cancelled = false;\n    const cancel = router.clc = ()=>{\n        cancelled = true;\n    };\n    const handleCancelled = ()=>{\n        if (cancelled) {\n            const error = new Error('Abort fetching component for route: \"' + route + '\"');\n            error.cancelled = true;\n            throw error;\n        }\n        if (cancel === router.clc) {\n            router.clc = null;\n        }\n    };\n    return handleCancelled;\n};\nclass Router {\n    reload() {\n        window.location.reload();\n    }\n    /**\n   * Go back in history\n   */ back() {\n        window.history.back();\n    }\n    /**\n   * Go forward in history\n   */ forward() {\n        window.history.forward();\n    }\n    /**\n   * Performs a `pushState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ push(url, as, options) {\n        if (options === void 0) options = {};\n        if (false) {}\n        ({ url, as } = prepareUrlAs(this, url, as));\n        return this.change(\"pushState\", url, as, options);\n    }\n    /**\n   * Performs a `replaceState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ replace(url, as, options) {\n        if (options === void 0) options = {};\n        ({ url, as } = prepareUrlAs(this, url, as));\n        return this.change(\"replaceState\", url, as, options);\n    }\n    async _bfl(as, resolvedAs, locale, skipNavigate) {\n        if (true) {\n            let matchesBflStatic = false;\n            let matchesBflDynamic = false;\n            for (const curAs of [\n                as,\n                resolvedAs\n            ]){\n                if (curAs) {\n                    const asNoSlash = (0, _removetrailingslash.removeTrailingSlash)(new URL(curAs, \"http://n\").pathname);\n                    const asNoSlashLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asNoSlash, locale || this.locale));\n                    if (asNoSlash !== (0, _removetrailingslash.removeTrailingSlash)(new URL(this.asPath, \"http://n\").pathname)) {\n                        var _this__bfl_s, _this__bfl_s1;\n                        matchesBflStatic = matchesBflStatic || !!((_this__bfl_s = this._bfl_s) == null ? void 0 : _this__bfl_s.contains(asNoSlash)) || !!((_this__bfl_s1 = this._bfl_s) == null ? void 0 : _this__bfl_s1.contains(asNoSlashLocale));\n                        for (const normalizedAS of [\n                            asNoSlash,\n                            asNoSlashLocale\n                        ]){\n                            // if any sub-path of as matches a dynamic filter path\n                            // it should be hard navigated\n                            const curAsParts = normalizedAS.split(\"/\");\n                            for(let i = 0; !matchesBflDynamic && i < curAsParts.length + 1; i++){\n                                var _this__bfl_d;\n                                const currentPart = curAsParts.slice(0, i).join(\"/\");\n                                if (currentPart && ((_this__bfl_d = this._bfl_d) == null ? void 0 : _this__bfl_d.contains(currentPart))) {\n                                    matchesBflDynamic = true;\n                                    break;\n                                }\n                            }\n                        }\n                        // if the client router filter is matched then we trigger\n                        // a hard navigation\n                        if (matchesBflStatic || matchesBflDynamic) {\n                            if (skipNavigate) {\n                                return true;\n                            }\n                            handleHardNavigation({\n                                url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || this.locale, this.defaultLocale)),\n                                router: this\n                            });\n                            return new Promise(()=>{});\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    async change(method, url, as, options, forcedScroll) {\n        var _this_components_pathname;\n        if (!(0, _islocalurl.isLocalURL)(url)) {\n            handleHardNavigation({\n                url,\n                router: this\n            });\n            return false;\n        }\n        // WARNING: `_h` is an internal option for handing Next.js client-side\n        // hydration. Your app should _never_ use this property. It may change at\n        // any time without notice.\n        const isQueryUpdating = options._h === 1;\n        if (!isQueryUpdating && !options.shallow) {\n            await this._bfl(as, undefined, options.locale);\n        }\n        let shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsepath.parsePath)(url).pathname === (0, _parsepath.parsePath)(as).pathname;\n        const nextState = {\n            ...this.state\n        };\n        // for static pages with query params in the URL we delay\n        // marking the router ready until after the query is updated\n        // or a navigation has occurred\n        const readyStateChange = this.isReady !== true;\n        this.isReady = true;\n        const isSsr = this.isSsr;\n        if (!isQueryUpdating) {\n            this.isSsr = false;\n        }\n        // if a route transition is already in progress before\n        // the query updating is triggered ignore query updating\n        if (isQueryUpdating && this.clc) {\n            return false;\n        }\n        const prevLocale = nextState.locale;\n        if (false) { var _this_locales; }\n        // marking route changes as a navigation start entry\n        if (_utils.ST) {\n            performance.mark(\"routeChange\");\n        }\n        const { shallow = false, scroll = true } = options;\n        const routeProps = {\n            shallow\n        };\n        if (this._inFlightRoute && this.clc) {\n            if (!isSsr) {\n                Router.events.emit(\"routeChangeError\", buildCancellationError(), this._inFlightRoute, routeProps);\n            }\n            this.clc();\n            this.clc = null;\n        }\n        as = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, options.locale, this.defaultLocale));\n        const cleanedAs = (0, _removelocale.removeLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, nextState.locale);\n        this._inFlightRoute = as;\n        const localeChange = prevLocale !== nextState.locale;\n        // If the url change is only related to a hash change\n        // We should not proceed. We should only change the state.\n        if (!isQueryUpdating && this.onlyAHashChange(cleanedAs) && !localeChange) {\n            nextState.asPath = cleanedAs;\n            Router.events.emit(\"hashChangeStart\", as, routeProps);\n            // TODO: do we need the resolved href when only a hash change?\n            this.changeState(method, url, as, {\n                ...options,\n                scroll: false\n            });\n            if (scroll) {\n                this.scrollToHash(cleanedAs);\n            }\n            try {\n                await this.set(nextState, this.components[nextState.route], null);\n            } catch (err) {\n                if ((0, _iserror.default)(err) && err.cancelled) {\n                    Router.events.emit(\"routeChangeError\", err, cleanedAs, routeProps);\n                }\n                throw err;\n            }\n            Router.events.emit(\"hashChangeComplete\", as, routeProps);\n            return true;\n        }\n        let parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n        let { pathname, query } = parsed;\n        // if we detected the path as app route during prefetching\n        // trigger hard navigation\n        if ((_this_components_pathname = this.components[pathname]) == null ? void 0 : _this_components_pathname.__appRouter) {\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            return new Promise(()=>{});\n        }\n        // The build manifest needs to be loaded before auto-static dynamic pages\n        // get their query parameters to allow ensuring they can be parsed properly\n        // when rewritten to\n        let pages, rewrites;\n        try {\n            [pages, { __rewrites: rewrites }] = await Promise.all([\n                this.pageLoader.getPageList(),\n                (0, _routeloader.getClientBuildManifest)(),\n                this.pageLoader.getMiddleware()\n            ]);\n        } catch (err) {\n            // If we fail to resolve the page list or client-build manifest, we must\n            // do a server-side transition:\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            return false;\n        }\n        // If asked to change the current URL we should reload the current page\n        // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n        // We also need to set the method = replaceState always\n        // as this should not go into the history (That's how browsers work)\n        // We should compare the new asPath to the current asPath, not the url\n        if (!this.urlIsNew(cleanedAs) && !localeChange) {\n            method = \"replaceState\";\n        }\n        // we need to resolve the as value using rewrites for dynamic SSG\n        // pages to allow building the data URL correctly\n        let resolvedAs = as;\n        // url and as should always be prefixed with basePath by this\n        // point by either next/link or router.push/replace so strip the\n        // basePath from the pathname to match the pages dir 1-to-1\n        pathname = pathname ? (0, _removetrailingslash.removeTrailingSlash)((0, _removebasepath.removeBasePath)(pathname)) : pathname;\n        let route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        const parsedAsPathname = as.startsWith(\"/\") && (0, _parserelativeurl.parseRelativeUrl)(as).pathname;\n        const isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isdynamic.isDynamicRoute)(route) || !(0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(route))(parsedAsPathname)));\n        // we don't attempt resolve asPath when we need to execute\n        // middleware as the resolving will occur server-side\n        const isMiddlewareMatch = !options.shallow && await matchesMiddleware({\n            asPath: as,\n            locale: nextState.locale,\n            router: this\n        });\n        if (isQueryUpdating && isMiddlewareMatch) {\n            shouldResolveHref = false;\n        }\n        if (shouldResolveHref && pathname !== \"/_error\") {\n            options._shouldResolveHref = true;\n            if (false) {} else {\n                parsed.pathname = resolveDynamicRoute(pathname, pages);\n                if (parsed.pathname !== pathname) {\n                    pathname = parsed.pathname;\n                    parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n                    if (!isMiddlewareMatch) {\n                        url = (0, _formaturl.formatWithValidation)(parsed);\n                    }\n                }\n            }\n        }\n        if (!(0, _islocalurl.isLocalURL)(as)) {\n            if (true) {\n                throw new Error('Invalid href: \"' + url + '\" and as: \"' + as + '\", received relative href and external as' + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n            }\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            return false;\n        }\n        resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(resolvedAs), nextState.locale);\n        route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        let routeMatch = false;\n        if ((0, _isdynamic.isDynamicRoute)(route)) {\n            const parsedAs = (0, _parserelativeurl.parseRelativeUrl)(resolvedAs);\n            const asPathname = parsedAs.pathname;\n            const routeRegex = (0, _routeregex.getRouteRegex)(route);\n            routeMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(asPathname);\n            const shouldInterpolate = route === asPathname;\n            const interpolatedAs = shouldInterpolate ? (0, _interpolateas.interpolateAs)(route, asPathname, query) : {};\n            if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n                const missingParams = Object.keys(routeRegex.groups).filter((param)=>!query[param] && !routeRegex.groups[param].optional);\n                if (missingParams.length > 0 && !isMiddlewareMatch) {\n                    if (true) {\n                        console.warn(\"\" + (shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\") + \" failed to manually provide \" + (\"the params: \" + missingParams.join(\", \") + \" in the `href`'s `query`\"));\n                    }\n                    throw new Error((shouldInterpolate ? \"The provided `href` (\" + url + \") value is missing query values (\" + missingParams.join(\", \") + \") to be interpolated properly. \" : \"The provided `as` value (\" + asPathname + \") is incompatible with the `href` value (\" + route + \"). \") + (\"Read more: https://nextjs.org/docs/messages/\" + (shouldInterpolate ? \"href-interpolation-failed\" : \"incompatible-href-as\")));\n                }\n            } else if (shouldInterpolate) {\n                as = (0, _formaturl.formatWithValidation)(Object.assign({}, parsedAs, {\n                    pathname: interpolatedAs.result,\n                    query: (0, _omit.omit)(query, interpolatedAs.params)\n                }));\n            } else {\n                // Merge params into `query`, overwriting any specified in search\n                Object.assign(query, routeMatch);\n            }\n        }\n        if (!isQueryUpdating) {\n            Router.events.emit(\"routeChangeStart\", as, routeProps);\n        }\n        const isErrorRoute = this.pathname === \"/404\" || this.pathname === \"/_error\";\n        try {\n            var _self___NEXT_DATA___props, _self___NEXT_DATA___props_pageProps, _routeInfo_props;\n            let routeInfo = await this.getRouteInfo({\n                route,\n                pathname,\n                query,\n                as,\n                resolvedAs,\n                routeProps,\n                locale: nextState.locale,\n                isPreview: nextState.isPreview,\n                hasMiddleware: isMiddlewareMatch,\n                unstable_skipClientCache: options.unstable_skipClientCache,\n                isQueryUpdating: isQueryUpdating && !this.isFallback,\n                isMiddlewareRewrite\n            });\n            if (!isQueryUpdating && !options.shallow) {\n                await this._bfl(as, \"resolvedAs\" in routeInfo ? routeInfo.resolvedAs : undefined, nextState.locale);\n            }\n            if (\"route\" in routeInfo && isMiddlewareMatch) {\n                pathname = routeInfo.route || route;\n                route = pathname;\n                if (!routeProps.shallow) {\n                    query = Object.assign({}, routeInfo.query || {}, query);\n                }\n                const cleanedParsedPathname = (0, _hasbasepath.hasBasePath)(parsed.pathname) ? (0, _removebasepath.removeBasePath)(parsed.pathname) : parsed.pathname;\n                if (routeMatch && pathname !== cleanedParsedPathname) {\n                    Object.keys(routeMatch).forEach((key)=>{\n                        if (routeMatch && query[key] === routeMatch[key]) {\n                            delete query[key];\n                        }\n                    });\n                }\n                if ((0, _isdynamic.isDynamicRoute)(pathname)) {\n                    const prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(new URL(as, location.href).pathname, nextState.locale), true);\n                    let rewriteAs = prefixedAs;\n                    if ((0, _hasbasepath.hasBasePath)(rewriteAs)) {\n                        rewriteAs = (0, _removebasepath.removeBasePath)(rewriteAs);\n                    }\n                    if (false) {}\n                    const routeRegex = (0, _routeregex.getRouteRegex)(pathname);\n                    const curRouteMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(new URL(rewriteAs, location.href).pathname);\n                    if (curRouteMatch) {\n                        Object.assign(query, curRouteMatch);\n                    }\n                }\n            }\n            // If the routeInfo brings a redirect we simply apply it.\n            if (\"type\" in routeInfo) {\n                if (routeInfo.type === \"redirect-internal\") {\n                    return this.change(method, routeInfo.newUrl, routeInfo.newAs, options);\n                } else {\n                    handleHardNavigation({\n                        url: routeInfo.destination,\n                        router: this\n                    });\n                    return new Promise(()=>{});\n                }\n            }\n            const component = routeInfo.Component;\n            if (component && component.unstable_scriptLoader) {\n                const scripts = [].concat(component.unstable_scriptLoader());\n                scripts.forEach((script)=>{\n                    (0, _script.handleClientScriptLoad)(script.props);\n                });\n            }\n            // handle redirect on client-transition\n            if ((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props) {\n                if (routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT) {\n                    // Use the destination from redirect without adding locale\n                    options.locale = false;\n                    const destination = routeInfo.props.pageProps.__N_REDIRECT;\n                    // check if destination is internal (resolves to a page) and attempt\n                    // client-navigation if it is falling back to hard navigation if\n                    // it's not\n                    if (destination.startsWith(\"/\") && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false) {\n                        const parsedHref = (0, _parserelativeurl.parseRelativeUrl)(destination);\n                        parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                        const { url: newUrl, as: newAs } = prepareUrlAs(this, destination, destination);\n                        return this.change(method, newUrl, newAs, options);\n                    }\n                    handleHardNavigation({\n                        url: destination,\n                        router: this\n                    });\n                    return new Promise(()=>{});\n                }\n                nextState.isPreview = !!routeInfo.props.__N_PREVIEW;\n                // handle SSG data 404\n                if (routeInfo.props.notFound === SSG_DATA_NOT_FOUND) {\n                    let notFoundRoute;\n                    try {\n                        await this.fetchComponent(\"/404\");\n                        notFoundRoute = \"/404\";\n                    } catch (_) {\n                        notFoundRoute = \"/_error\";\n                    }\n                    routeInfo = await this.getRouteInfo({\n                        route: notFoundRoute,\n                        pathname: notFoundRoute,\n                        query,\n                        as,\n                        resolvedAs,\n                        routeProps: {\n                            shallow: false\n                        },\n                        locale: nextState.locale,\n                        isPreview: nextState.isPreview,\n                        isNotFound: true\n                    });\n                    if (\"type\" in routeInfo) {\n                        throw new Error(\"Unexpected middleware effect on /404\");\n                    }\n                }\n            }\n            if (isQueryUpdating && this.pathname === \"/_error\" && ((_self___NEXT_DATA___props = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps = _self___NEXT_DATA___props.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps.statusCode) === 500 && ((_routeInfo_props = routeInfo.props) == null ? void 0 : _routeInfo_props.pageProps)) {\n                // ensure statusCode is still correct for static 500 page\n                // when updating query information\n                routeInfo.props.pageProps.statusCode = 500;\n            }\n            var _routeInfo_route;\n            // shallow routing is only allowed for same page URL changes.\n            const isValidShallowRoute = options.shallow && nextState.route === ((_routeInfo_route = routeInfo.route) != null ? _routeInfo_route : route);\n            var _options_scroll;\n            const shouldScroll = (_options_scroll = options.scroll) != null ? _options_scroll : !isQueryUpdating && !isValidShallowRoute;\n            const resetScroll = shouldScroll ? {\n                x: 0,\n                y: 0\n            } : null;\n            const upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll;\n            // the new state that the router gonna set\n            const upcomingRouterState = {\n                ...nextState,\n                route,\n                pathname,\n                query,\n                asPath: cleanedAs,\n                isFallback: false\n            };\n            // When the page being rendered is the 404 page, we should only update the\n            // query parameters. Route changes here might add the basePath when it\n            // wasn't originally present. This is also why this block is before the\n            // below `changeState` call which updates the browser's history (changing\n            // the URL).\n            if (isQueryUpdating && isErrorRoute) {\n                var _self___NEXT_DATA___props1, _self___NEXT_DATA___props_pageProps1, _routeInfo_props1;\n                routeInfo = await this.getRouteInfo({\n                    route: this.pathname,\n                    pathname: this.pathname,\n                    query,\n                    as,\n                    resolvedAs,\n                    routeProps: {\n                        shallow: false\n                    },\n                    locale: nextState.locale,\n                    isPreview: nextState.isPreview,\n                    isQueryUpdating: isQueryUpdating && !this.isFallback\n                });\n                if (\"type\" in routeInfo) {\n                    throw new Error(\"Unexpected middleware effect on \" + this.pathname);\n                }\n                if (this.pathname === \"/_error\" && ((_self___NEXT_DATA___props1 = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps1 = _self___NEXT_DATA___props1.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps1.statusCode) === 500 && ((_routeInfo_props1 = routeInfo.props) == null ? void 0 : _routeInfo_props1.pageProps)) {\n                    // ensure statusCode is still correct for static 500 page\n                    // when updating query information\n                    routeInfo.props.pageProps.statusCode = 500;\n                }\n                try {\n                    await this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n                } catch (err) {\n                    if ((0, _iserror.default)(err) && err.cancelled) {\n                        Router.events.emit(\"routeChangeError\", err, cleanedAs, routeProps);\n                    }\n                    throw err;\n                }\n                return true;\n            }\n            Router.events.emit(\"beforeHistoryChange\", as, routeProps);\n            this.changeState(method, url, as, options);\n            // for query updates we can skip it if the state is unchanged and we don't\n            // need to scroll\n            // https://github.com/vercel/next.js/issues/37139\n            const canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _comparestates.compareRouterStates)(upcomingRouterState, this.state);\n            if (!canSkipUpdating) {\n                try {\n                    await this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n                } catch (e) {\n                    if (e.cancelled) routeInfo.error = routeInfo.error || e;\n                    else throw e;\n                }\n                if (routeInfo.error) {\n                    if (!isQueryUpdating) {\n                        Router.events.emit(\"routeChangeError\", routeInfo.error, cleanedAs, routeProps);\n                    }\n                    throw routeInfo.error;\n                }\n                if (false) {}\n                if (!isQueryUpdating) {\n                    Router.events.emit(\"routeChangeComplete\", as, routeProps);\n                }\n                // A hash mark # is the optional last part of a URL\n                const hashRegex = /#.+$/;\n                if (shouldScroll && hashRegex.test(as)) {\n                    this.scrollToHash(as);\n                }\n            }\n            return true;\n        } catch (err) {\n            if ((0, _iserror.default)(err) && err.cancelled) {\n                return false;\n            }\n            throw err;\n        }\n    }\n    changeState(method, url, as, options) {\n        if (options === void 0) options = {};\n        if (true) {\n            if (typeof window.history === \"undefined\") {\n                console.error(\"Warning: window.history is not available.\");\n                return;\n            }\n            if (typeof window.history[method] === \"undefined\") {\n                console.error(\"Warning: window.history.\" + method + \" is not available\");\n                return;\n            }\n        }\n        if (method !== \"pushState\" || (0, _utils.getURL)() !== as) {\n            this._shallow = options.shallow;\n            window.history[method]({\n                url,\n                as,\n                options,\n                __N: true,\n                key: this._key = method !== \"pushState\" ? this._key : createKey()\n            }, // Passing the empty string here should be safe against future changes to the method.\n            // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n            \"\", as);\n        }\n    }\n    async handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n        console.error(err);\n        if (err.cancelled) {\n            // bubble up cancellation errors\n            throw err;\n        }\n        if ((0, _routeloader.isAssetError)(err) || loadErrorFail) {\n            Router.events.emit(\"routeChangeError\", err, as, routeProps);\n            // If we can't load the page it could be one of following reasons\n            //  1. Page doesn't exists\n            //  2. Page does exist in a different zone\n            //  3. Internal error while loading the page\n            // So, doing a hard reload is the proper way to deal with this.\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            // Changing the URL doesn't block executing the current code path.\n            // So let's throw a cancellation error stop the routing logic.\n            throw buildCancellationError();\n        }\n        try {\n            let props;\n            const { page: Component, styleSheets } = await this.fetchComponent(\"/_error\");\n            const routeInfo = {\n                props,\n                Component,\n                styleSheets,\n                err,\n                error: err\n            };\n            if (!routeInfo.props) {\n                try {\n                    routeInfo.props = await this.getInitialProps(Component, {\n                        err,\n                        pathname,\n                        query\n                    });\n                } catch (gipErr) {\n                    console.error(\"Error in error page `getInitialProps`: \", gipErr);\n                    routeInfo.props = {};\n                }\n            }\n            return routeInfo;\n        } catch (routeInfoErr) {\n            return this.handleRouteInfoError((0, _iserror.default)(routeInfoErr) ? routeInfoErr : new Error(routeInfoErr + \"\"), pathname, query, as, routeProps, true);\n        }\n    }\n    async getRouteInfo(param) {\n        let { route: requestedRoute, pathname, query, as, resolvedAs, routeProps, locale, hasMiddleware, isPreview, unstable_skipClientCache, isQueryUpdating, isMiddlewareRewrite, isNotFound } = param;\n        /**\n     * This `route` binding can change if there's a rewrite\n     * so we keep a reference to the original requested route\n     * so we can store the cache for it and avoid re-requesting every time\n     * for shallow routing purposes.\n     */ let route = requestedRoute;\n        try {\n            var _data_effect, _data_effect1, _data_effect2, _data_response;\n            const handleCancelled = getCancelledHandler({\n                route,\n                router: this\n            });\n            let existingInfo = this.components[route];\n            if (routeProps.shallow && existingInfo && this.route === route) {\n                return existingInfo;\n            }\n            if (hasMiddleware) {\n                existingInfo = undefined;\n            }\n            let cachedRouteInfo = existingInfo && !(\"initial\" in existingInfo) && \"development\" !== \"development\" ? 0 : undefined;\n            const isBackground = isQueryUpdating;\n            const fetchNextDataParams = {\n                dataHref: this.pageLoader.getDataHref({\n                    href: (0, _formaturl.formatWithValidation)({\n                        pathname,\n                        query\n                    }),\n                    skipInterpolation: true,\n                    asPath: isNotFound ? \"/404\" : resolvedAs,\n                    locale\n                }),\n                hasMiddleware: true,\n                isServerRender: this.isSsr,\n                parseJSON: true,\n                inflightCache: isBackground ? this.sbc : this.sdc,\n                persistCache: !isPreview,\n                isPrefetch: false,\n                unstable_skipClientCache,\n                isBackground\n            };\n            let data = isQueryUpdating && !isMiddlewareRewrite ? null : await withMiddlewareEffects({\n                fetchData: ()=>fetchNextData(fetchNextDataParams),\n                asPath: isNotFound ? \"/404\" : resolvedAs,\n                locale: locale,\n                router: this\n            }).catch((err)=>{\n                // we don't hard error during query updating\n                // as it's un-necessary and doesn't need to be fatal\n                // unless it is a fallback route and the props can't\n                // be loaded\n                if (isQueryUpdating) {\n                    return null;\n                }\n                throw err;\n            });\n            // when rendering error routes we don't apply middleware\n            // effects\n            if (data && (pathname === \"/_error\" || pathname === \"/404\")) {\n                data.effect = undefined;\n            }\n            if (isQueryUpdating) {\n                if (!data) {\n                    data = {\n                        json: self.__NEXT_DATA__.props\n                    };\n                } else {\n                    data.json = self.__NEXT_DATA__.props;\n                }\n            }\n            handleCancelled();\n            if ((data == null ? void 0 : (_data_effect = data.effect) == null ? void 0 : _data_effect.type) === \"redirect-internal\" || (data == null ? void 0 : (_data_effect1 = data.effect) == null ? void 0 : _data_effect1.type) === \"redirect-external\") {\n                return data.effect;\n            }\n            if ((data == null ? void 0 : (_data_effect2 = data.effect) == null ? void 0 : _data_effect2.type) === \"rewrite\") {\n                const resolvedRoute = (0, _removetrailingslash.removeTrailingSlash)(data.effect.resolvedHref);\n                const pages = await this.pageLoader.getPageList();\n                // during query updating the page must match although during\n                // client-transition a redirect that doesn't match a page\n                // can be returned and this should trigger a hard navigation\n                // which is valid for incremental migration\n                if (!isQueryUpdating || pages.includes(resolvedRoute)) {\n                    route = resolvedRoute;\n                    pathname = data.effect.resolvedHref;\n                    query = {\n                        ...query,\n                        ...data.effect.parsedAs.query\n                    };\n                    resolvedAs = (0, _removebasepath.removeBasePath)((0, _normalizelocalepath.normalizeLocalePath)(data.effect.parsedAs.pathname, this.locales).pathname);\n                    // Check again the cache with the new destination.\n                    existingInfo = this.components[route];\n                    if (routeProps.shallow && existingInfo && this.route === route && !hasMiddleware) {\n                        // If we have a match with the current route due to rewrite,\n                        // we can copy the existing information to the rewritten one.\n                        // Then, we return the information along with the matched route.\n                        return {\n                            ...existingInfo,\n                            route\n                        };\n                    }\n                }\n            }\n            if ((0, _isapiroute.isAPIRoute)(route)) {\n                handleHardNavigation({\n                    url: as,\n                    router: this\n                });\n                return new Promise(()=>{});\n            }\n            const routeInfo = cachedRouteInfo || await this.fetchComponent(route).then((res)=>({\n                    Component: res.page,\n                    styleSheets: res.styleSheets,\n                    __N_SSG: res.mod.__N_SSG,\n                    __N_SSP: res.mod.__N_SSP\n                }));\n            if (true) {\n                const { isValidElementType } = __webpack_require__(/*! next/dist/compiled/react-is */ \"./node_modules/next/dist/compiled/react-is/index.js\");\n                if (!isValidElementType(routeInfo.Component)) {\n                    throw new Error('The default export is not a React Component in page: \"' + pathname + '\"');\n                }\n            }\n            const wasBailedPrefetch = data == null ? void 0 : (_data_response = data.response) == null ? void 0 : _data_response.headers.get(\"x-middleware-skip\");\n            const shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP;\n            // For non-SSG prefetches that bailed before sending data\n            // we clear the cache to fetch full response\n            if (wasBailedPrefetch && (data == null ? void 0 : data.dataHref)) {\n                delete this.sdc[data.dataHref];\n            }\n            const { props, cacheKey } = await this._getData(async ()=>{\n                if (shouldFetchData) {\n                    if ((data == null ? void 0 : data.json) && !wasBailedPrefetch) {\n                        return {\n                            cacheKey: data.cacheKey,\n                            props: data.json\n                        };\n                    }\n                    const dataHref = (data == null ? void 0 : data.dataHref) ? data.dataHref : this.pageLoader.getDataHref({\n                        href: (0, _formaturl.formatWithValidation)({\n                            pathname,\n                            query\n                        }),\n                        asPath: resolvedAs,\n                        locale\n                    });\n                    const fetched = await fetchNextData({\n                        dataHref,\n                        isServerRender: this.isSsr,\n                        parseJSON: true,\n                        inflightCache: wasBailedPrefetch ? {} : this.sdc,\n                        persistCache: !isPreview,\n                        isPrefetch: false,\n                        unstable_skipClientCache\n                    });\n                    return {\n                        cacheKey: fetched.cacheKey,\n                        props: fetched.json || {}\n                    };\n                }\n                return {\n                    headers: {},\n                    props: await this.getInitialProps(routeInfo.Component, {\n                        pathname,\n                        query,\n                        asPath: as,\n                        locale,\n                        locales: this.locales,\n                        defaultLocale: this.defaultLocale\n                    })\n                };\n            });\n            // Only bust the data cache for SSP routes although\n            // middleware can skip cache per request with\n            // x-middleware-cache: no-cache as well\n            if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {\n                delete this.sdc[cacheKey];\n            }\n            // we kick off a HEAD request in the background\n            // when a non-prefetch request is made to signal revalidation\n            if (!this.isPreview && routeInfo.__N_SSG && \"development\" !== \"development\" && 0) {}\n            props.pageProps = Object.assign({}, props.pageProps);\n            routeInfo.props = props;\n            routeInfo.route = route;\n            routeInfo.query = query;\n            routeInfo.resolvedAs = resolvedAs;\n            this.components[route] = routeInfo;\n            return routeInfo;\n        } catch (err) {\n            return this.handleRouteInfoError((0, _iserror.getProperError)(err), pathname, query, as, routeProps);\n        }\n    }\n    set(state, data, resetScroll) {\n        this.state = state;\n        return this.sub(data, this.components[\"/_app\"].Component, resetScroll);\n    }\n    /**\n   * Callback to execute before replacing router state\n   * @param cb callback to be executed\n   */ beforePopState(cb) {\n        this._bps = cb;\n    }\n    onlyAHashChange(as) {\n        if (!this.asPath) return false;\n        const [oldUrlNoHash, oldHash] = this.asPath.split(\"#\");\n        const [newUrlNoHash, newHash] = as.split(\"#\");\n        // Makes sure we scroll to the provided hash if the url/hash are the same\n        if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n            return true;\n        }\n        // If the urls are change, there's more than a hash change\n        if (oldUrlNoHash !== newUrlNoHash) {\n            return false;\n        }\n        // If the hash has changed, then it's a hash only change.\n        // This check is necessary to handle both the enter and\n        // leave hash === '' cases. The identity case falls through\n        // and is treated as a next reload.\n        return oldHash !== newHash;\n    }\n    scrollToHash(as) {\n        const [, hash = \"\"] = as.split(\"#\");\n        (0, _handlesmoothscroll.handleSmoothScroll)(()=>{\n            // Scroll to top if the hash is just `#` with no value or `#top`\n            // To mirror browsers\n            if (hash === \"\" || hash === \"top\") {\n                window.scrollTo(0, 0);\n                return;\n            }\n            // Decode hash to make non-latin anchor works.\n            const rawHash = decodeURIComponent(hash);\n            // First we check if the element by id is found\n            const idEl = document.getElementById(rawHash);\n            if (idEl) {\n                idEl.scrollIntoView();\n                return;\n            }\n            // If there's no element with the id, we check the `name` property\n            // To mirror browsers\n            const nameEl = document.getElementsByName(rawHash)[0];\n            if (nameEl) {\n                nameEl.scrollIntoView();\n            }\n        }, {\n            onlyHashChange: this.onlyAHashChange(as)\n        });\n    }\n    urlIsNew(asPath) {\n        return this.asPath !== asPath;\n    }\n    /**\n   * Prefetch page code, you may wait for the data during page rendering.\n   * This feature only works in production!\n   * @param url the href of prefetched page\n   * @param asPath the as path of the prefetched page\n   */ async prefetch(url, asPath, options) {\n        if (asPath === void 0) asPath = url;\n        if (options === void 0) options = {};\n        // Prefetch is not supported in development mode because it would trigger on-demand-entries\n        if (true) {\n            return;\n        }\n        if ( true && (0, _isbot.isBot)(window.navigator.userAgent)) {\n            // No prefetches for bots that render the link since they are typically navigating\n            // links via the equivalent of a hard navigation and hence never utilize these\n            // prefetches.\n            return;\n        }\n        let parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n        const urlPathname = parsed.pathname;\n        let { pathname, query } = parsed;\n        const originalPathname = pathname;\n        if (false) {}\n        const pages = await this.pageLoader.getPageList();\n        let resolvedAs = asPath;\n        const locale = typeof options.locale !== \"undefined\" ? options.locale || undefined : this.locale;\n        const isMiddlewareMatch = await matchesMiddleware({\n            asPath: asPath,\n            locale: locale,\n            router: this\n        });\n        if (false) {}\n        parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n        if ((0, _isdynamic.isDynamicRoute)(parsed.pathname)) {\n            pathname = parsed.pathname;\n            parsed.pathname = pathname;\n            Object.assign(query, (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(parsed.pathname))((0, _parsepath.parsePath)(asPath).pathname) || {});\n            if (!isMiddlewareMatch) {\n                url = (0, _formaturl.formatWithValidation)(parsed);\n            }\n        }\n        const data =  false ? 0 : await withMiddlewareEffects({\n            fetchData: ()=>fetchNextData({\n                    dataHref: this.pageLoader.getDataHref({\n                        href: (0, _formaturl.formatWithValidation)({\n                            pathname: originalPathname,\n                            query\n                        }),\n                        skipInterpolation: true,\n                        asPath: resolvedAs,\n                        locale\n                    }),\n                    hasMiddleware: true,\n                    isServerRender: this.isSsr,\n                    parseJSON: true,\n                    inflightCache: this.sdc,\n                    persistCache: !this.isPreview,\n                    isPrefetch: true\n                }),\n            asPath: asPath,\n            locale: locale,\n            router: this\n        });\n        /**\n     * If there was a rewrite we apply the effects of the rewrite on the\n     * current parameters for the prefetch.\n     */ if ((data == null ? void 0 : data.effect.type) === \"rewrite\") {\n            parsed.pathname = data.effect.resolvedHref;\n            pathname = data.effect.resolvedHref;\n            query = {\n                ...query,\n                ...data.effect.parsedAs.query\n            };\n            resolvedAs = data.effect.parsedAs.pathname;\n            url = (0, _formaturl.formatWithValidation)(parsed);\n        }\n        /**\n     * If there is a redirect to an external destination then we don't have\n     * to prefetch content as it will be unused.\n     */ if ((data == null ? void 0 : data.effect.type) === \"redirect-external\") {\n            return;\n        }\n        const route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        if (await this._bfl(asPath, resolvedAs, options.locale, true)) {\n            this.components[urlPathname] = {\n                __appRouter: true\n            };\n        }\n        await Promise.all([\n            this.pageLoader._isSsg(route).then((isSsg)=>{\n                return isSsg ? fetchNextData({\n                    dataHref: (data == null ? void 0 : data.json) ? data == null ? void 0 : data.dataHref : this.pageLoader.getDataHref({\n                        href: url,\n                        asPath: resolvedAs,\n                        locale: locale\n                    }),\n                    isServerRender: false,\n                    parseJSON: true,\n                    inflightCache: this.sdc,\n                    persistCache: !this.isPreview,\n                    isPrefetch: true,\n                    unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!true\n                }).then(()=>false).catch(()=>false) : false;\n            }),\n            this.pageLoader[options.priority ? \"loadPage\" : \"prefetch\"](route)\n        ]);\n    }\n    async fetchComponent(route) {\n        const handleCancelled = getCancelledHandler({\n            route,\n            router: this\n        });\n        try {\n            const componentResult = await this.pageLoader.loadPage(route);\n            handleCancelled();\n            return componentResult;\n        } catch (err) {\n            handleCancelled();\n            throw err;\n        }\n    }\n    _getData(fn) {\n        let cancelled = false;\n        const cancel = ()=>{\n            cancelled = true;\n        };\n        this.clc = cancel;\n        return fn().then((data)=>{\n            if (cancel === this.clc) {\n                this.clc = null;\n            }\n            if (cancelled) {\n                const err = new Error(\"Loading initial props cancelled\");\n                err.cancelled = true;\n                throw err;\n            }\n            return data;\n        });\n    }\n    _getFlightData(dataHref) {\n        // Do not cache RSC flight response since it's not a static resource\n        return fetchNextData({\n            dataHref,\n            isServerRender: true,\n            parseJSON: false,\n            inflightCache: this.sdc,\n            persistCache: false,\n            isPrefetch: false\n        }).then((param)=>{\n            let { text } = param;\n            return {\n                data: text\n            };\n        });\n    }\n    getInitialProps(Component, ctx) {\n        const { Component: App } = this.components[\"/_app\"];\n        const AppTree = this._wrapApp(App);\n        ctx.AppTree = AppTree;\n        return (0, _utils.loadGetInitialProps)(App, {\n            AppTree,\n            Component,\n            router: this,\n            ctx\n        });\n    }\n    get route() {\n        return this.state.route;\n    }\n    get pathname() {\n        return this.state.pathname;\n    }\n    get query() {\n        return this.state.query;\n    }\n    get asPath() {\n        return this.state.asPath;\n    }\n    get locale() {\n        return this.state.locale;\n    }\n    get isFallback() {\n        return this.state.isFallback;\n    }\n    get isPreview() {\n        return this.state.isPreview;\n    }\n    constructor(pathname, query, as, { initialProps, pageLoader, App, wrapApp, Component, err, subscription, isFallback, locale, locales, defaultLocale, domainLocales, isPreview }){\n        // Server Data Cache (full data requests)\n        this.sdc = {};\n        // Server Background Cache (HEAD requests)\n        this.sbc = {};\n        this.isFirstPopStateEvent = true;\n        this._key = createKey();\n        this.onPopState = (e)=>{\n            const { isFirstPopStateEvent } = this;\n            this.isFirstPopStateEvent = false;\n            const state = e.state;\n            if (!state) {\n                // We get state as undefined for two reasons.\n                //  1. With older safari (< 8) and older chrome (< 34)\n                //  2. When the URL changed with #\n                //\n                // In the both cases, we don't need to proceed and change the route.\n                // (as it's already changed)\n                // But we can simply replace the state with the new changes.\n                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n                // So, doing the following for (1) does no harm.\n                const { pathname, query } = this;\n                this.changeState(\"replaceState\", (0, _formaturl.formatWithValidation)({\n                    pathname: (0, _addbasepath.addBasePath)(pathname),\n                    query\n                }), (0, _utils.getURL)());\n                return;\n            }\n            // __NA is used to identify if the history entry can be handled by the app-router.\n            if (state.__NA) {\n                window.location.reload();\n                return;\n            }\n            if (!state.__N) {\n                return;\n            }\n            // Safari fires popstateevent when reopening the browser.\n            if (isFirstPopStateEvent && this.locale === state.options.locale && state.as === this.asPath) {\n                return;\n            }\n            let forcedScroll;\n            const { url, as, options, key } = state;\n            if (false) {}\n            this._key = key;\n            const { pathname } = (0, _parserelativeurl.parseRelativeUrl)(url);\n            // Make sure we don't re-render on initial load,\n            // can be caused by navigating back from an external site\n            if (this.isSsr && as === (0, _addbasepath.addBasePath)(this.asPath) && pathname === (0, _addbasepath.addBasePath)(this.pathname)) {\n                return;\n            }\n            // If the downstream application returns falsy, return.\n            // They will then be responsible for handling the event.\n            if (this._bps && !this._bps(state)) {\n                return;\n            }\n            this.change(\"replaceState\", url, as, Object.assign({}, options, {\n                shallow: options.shallow && this._shallow,\n                locale: options.locale || this.defaultLocale,\n                // @ts-ignore internal value not exposed on types\n                _h: 0\n            }), forcedScroll);\n        };\n        // represents the current component key\n        const route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        // set up the component cache (by route keys)\n        this.components = {};\n        // We should not keep the cache, if there's an error\n        // Otherwise, this cause issues when when going back and\n        // come again to the errored page.\n        if (pathname !== \"/_error\") {\n            this.components[route] = {\n                Component,\n                initial: true,\n                props: initialProps,\n                err,\n                __N_SSG: initialProps && initialProps.__N_SSG,\n                __N_SSP: initialProps && initialProps.__N_SSP\n            };\n        }\n        this.components[\"/_app\"] = {\n            Component: App,\n            styleSheets: []\n        };\n        if (true) {\n            const { BloomFilter } = __webpack_require__(/*! ../../lib/bloom-filter */ \"./node_modules/next/dist/shared/lib/bloom-filter.js\");\n            const staticFilterData = {\"numItems\":3,\"errorRate\":0.01,\"numBits\":29,\"numHashes\":7,\"bitArray\":[0,1,0,0,1,1,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,0,1]};\n            const dynamicFilterData = {\"numItems\":0,\"errorRate\":0.01,\"numBits\":0,\"numHashes\":null,\"bitArray\":[]};\n            if (staticFilterData == null ? void 0 : staticFilterData.numHashes) {\n                this._bfl_s = new BloomFilter(staticFilterData.numItems, staticFilterData.errorRate);\n                this._bfl_s.import(staticFilterData);\n            }\n            if (dynamicFilterData == null ? void 0 : dynamicFilterData.numHashes) {\n                this._bfl_d = new BloomFilter(dynamicFilterData.numItems, dynamicFilterData.errorRate);\n                this._bfl_d.import(dynamicFilterData);\n            }\n        }\n        // Backwards compat for Router.router.events\n        // TODO: Should be remove the following major version as it was never documented\n        this.events = Router.events;\n        this.pageLoader = pageLoader;\n        // if auto prerendered and dynamic route wait to update asPath\n        // until after mount to prevent hydration mismatch\n        const autoExportDynamic = (0, _isdynamic.isDynamicRoute)(pathname) && self.__NEXT_DATA__.autoExport;\n        this.basePath =  false || \"\";\n        this.sub = subscription;\n        this.clc = null;\n        this._wrapApp = wrapApp;\n        // make sure to ignore extra popState in safari on navigating\n        // back from external site\n        this.isSsr = true;\n        this.isLocaleDomain = false;\n        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !false);\n        if (false) {}\n        this.state = {\n            route,\n            pathname,\n            query,\n            asPath: autoExportDynamic ? pathname : as,\n            isPreview: !!isPreview,\n            locale:  false ? 0 : undefined,\n            isFallback\n        };\n        this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n        if (true) {\n            // make sure \"as\" doesn't start with double slashes or else it can\n            // throw an error as it's considered invalid\n            if (!as.startsWith(\"//\")) {\n                // in order for `e.state` to work on the `onpopstate` event\n                // we have to register the initial route upon initialization\n                const options = {\n                    locale\n                };\n                const asPath = (0, _utils.getURL)();\n                this._initialMatchesMiddlewarePromise = matchesMiddleware({\n                    router: this,\n                    locale,\n                    asPath\n                }).then((matches)=>{\n                    options._shouldResolveHref = as !== pathname;\n                    this.changeState(\"replaceState\", matches ? asPath : (0, _formaturl.formatWithValidation)({\n                        pathname: (0, _addbasepath.addBasePath)(pathname),\n                        query\n                    }), asPath, options);\n                    return matches;\n                });\n            }\n            window.addEventListener(\"popstate\", this.onPopState);\n            // enable custom scroll restoration handling when available\n            // otherwise fallback to browser's default handling\n            if (false) {}\n        }\n    }\n}\n(()=>{\n    Router.events = (0, _mitt.default)();\n})(); //# sourceMappingURL=router.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSw0QkFBNEI7QUFDZjtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUlOO0FBQ0EsU0FBU0ksUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVYsT0FBT0MsY0FBYyxDQUFDUSxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFOLFNBQVM7SUFDYkcsU0FBUztRQUNMLE9BQU9TO0lBQ1g7SUFDQVIsbUJBQW1CO1FBQ2YsT0FBT0E7SUFDWDtJQUNBQyxXQUFXO1FBQ1AsT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTVEsMkJBQTJCQyxtQkFBT0EsQ0FBQyw0R0FBeUM7QUFDbEYsTUFBTUMsNEJBQTRCRCxtQkFBT0EsQ0FBQyw4R0FBMEM7QUFDcEYsTUFBTUUsdUJBQXVCRixtQkFBT0EsQ0FBQyxnSEFBK0I7QUFDcEUsTUFBTUcsZUFBZUgsbUJBQU9BLENBQUMscUZBQThCO0FBQzNELE1BQU1JLFVBQVVKLG1CQUFPQSxDQUFDLHlFQUF3QjtBQUNoRCxNQUFNSyxXQUFXLFdBQVcsR0FBR0osMEJBQTBCSyxDQUFDLENBQUNOLG1CQUFPQSxDQUFDLHVFQUF1QjtBQUMxRixNQUFNTyx1QkFBdUJQLG1CQUFPQSxDQUFDLGtIQUFvQztBQUN6RSxNQUFNUSx1QkFBdUJSLG1CQUFPQSxDQUFDLHdHQUErQjtBQUNwRSxNQUFNUyxRQUFRLFdBQVcsR0FBR1YseUJBQXlCTyxDQUFDLENBQUNOLG1CQUFPQSxDQUFDLDREQUFTO0FBQ3hFLE1BQU1VLFNBQVNWLG1CQUFPQSxDQUFDLDhEQUFVO0FBQ2pDLE1BQU1XLGFBQWFYLG1CQUFPQSxDQUFDLDBGQUFvQjtBQUMvQyxNQUFNWSxvQkFB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QyxHQUFHdFosUUFBUUMsT0FBTyxDQUFDO1FBQ3hELElBQUksSUFBNkIsRUFBRTtZQUMvQixrRUFBa0U7WUFDbEUsNENBQTRDO1lBQzVDLElBQUksQ0FBQzRCLEdBQUdKLFVBQVUsQ0FBQyxPQUFPO2dCQUN0QiwyREFBMkQ7Z0JBQzNELDREQUE0RDtnQkFDNUQsTUFBTTNCLFVBQVU7b0JBQ1ppQjtnQkFDSjtnQkFDQSxNQUFNUCxTQUFTLENBQUMsR0FBR3RDLE9BQU9vVixNQUFNO2dCQUNoQyxJQUFJLENBQUNnRyxnQ0FBZ0MsR0FBR3hjLGtCQUFrQjtvQkFDdERvRCxRQUFRLElBQUk7b0JBQ1phO29CQUNBUDtnQkFDSixHQUFHZ0UsSUFBSSxDQUFDLENBQUNjO29CQUNMeEYsUUFBUTJNLGtCQUFrQixHQUFHNUssT0FBT3hCO29CQUNwQyxJQUFJLENBQUNvTyxXQUFXLENBQUMsZ0JBQWdCbkosVUFBVTlFLFNBQVMsQ0FBQyxHQUFHaEMsV0FBVzJPLG9CQUFvQixFQUFFO3dCQUNyRjlNLFVBQVUsQ0FBQyxHQUFHdkIsYUFBYStCLFdBQVcsRUFBRVI7d0JBQ3hDNEU7b0JBQ0osSUFBSXpFLFFBQVFWO29CQUNaLE9BQU93RjtnQkFDWDtZQUNKO1lBQ0F1QixPQUFPMFMsZ0JBQWdCLENBQUMsWUFBWSxJQUFJLENBQUN0QixVQUFVO1lBQ25ELDJEQUEyRDtZQUMzRCxtREFBbUQ7WUFDbkQsSUFBSXpVLEtBQXFDLEVBQUUsRUFJMUM7UUFDTDtJQUNKO0FBQ0o7QUFDQztJQUNHbEcsT0FBTzhRLE1BQU0sR0FBRyxDQUFDLEdBQUduUSxNQUFNcEIsT0FBTztBQUNyQyxNQUVBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcz84Njg0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGVcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZGVmYXVsdDogbnVsbCxcbiAgICBtYXRjaGVzTWlkZGxld2FyZTogbnVsbCxcbiAgICBjcmVhdGVLZXk6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgZGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSb3V0ZXI7XG4gICAgfSxcbiAgICBtYXRjaGVzTWlkZGxld2FyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzTWlkZGxld2FyZTtcbiAgICB9LFxuICAgIGNyZWF0ZUtleTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVLZXk7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkXCIpO1xuY29uc3QgX3JlbW92ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlKFwiLi91dGlscy9yZW1vdmUtdHJhaWxpbmctc2xhc2hcIik7XG5jb25zdCBfcm91dGVsb2FkZXIgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3JvdXRlLWxvYWRlclwiKTtcbmNvbnN0IF9zY3JpcHQgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3NjcmlwdFwiKTtcbmNvbnN0IF9pc2Vycm9yID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcIi4uLy4uLy4uL2xpYi9pcy1lcnJvclwiKSk7XG5jb25zdCBfZGVub3JtYWxpemVwYWdlcGF0aCA9IHJlcXVpcmUoXCIuLi9wYWdlLXBhdGgvZGVub3JtYWxpemUtcGFnZS1wYXRoXCIpO1xuY29uc3QgX25vcm1hbGl6ZWxvY2FsZXBhdGggPSByZXF1aXJlKFwiLi4vaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGhcIik7XG5jb25zdCBfbWl0dCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4uL21pdHRcIikpO1xuY29uc3QgX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgX2lzZHluYW1pYyA9IHJlcXVpcmUoXCIuL3V0aWxzL2lzLWR5bmFtaWNcIik7XG5jb25zdCBfcGFyc2VyZWxhdGl2ZXVybCA9IHJlcXVpcmUoXCIuL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybFwiKTtcbmNvbnN0IF9yZXNvbHZlcmV3cml0ZXMgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCIuL3V0aWxzL3Jlc29sdmUtcmV3cml0ZXNcIikpO1xuY29uc3QgX3JvdXRlbWF0Y2hlciA9IHJlcXVpcmUoXCIuL3V0aWxzL3JvdXRlLW1hdGNoZXJcIik7XG5jb25zdCBfcm91dGVyZWdleCA9IHJlcXVpcmUoXCIuL3V0aWxzL3JvdXRlLXJlZ2V4XCIpO1xuY29uc3QgX2Zvcm1hdHVybCA9IHJlcXVpcmUoXCIuL3V0aWxzL2Zvcm1hdC11cmxcIik7XG5jb25zdCBfZGV0ZWN0ZG9tYWlubG9jYWxlID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9kZXRlY3QtZG9tYWluLWxvY2FsZVwiKTtcbmNvbnN0IF9wYXJzZXBhdGggPSByZXF1aXJlKFwiLi91dGlscy9wYXJzZS1wYXRoXCIpO1xuY29uc3QgX2FkZGxvY2FsZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvYWRkLWxvY2FsZVwiKTtcbmNvbnN0IF9yZW1vdmVsb2NhbGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3JlbW92ZS1sb2NhbGVcIik7XG5jb25zdCBfcmVtb3ZlYmFzZXBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3JlbW92ZS1iYXNlLXBhdGhcIik7XG5jb25zdCBfYWRkYmFzZXBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2FkZC1iYXNlLXBhdGhcIik7XG5jb25zdCBfaGFzYmFzZXBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2hhcy1iYXNlLXBhdGhcIik7XG5jb25zdCBfaXNhcGlyb3V0ZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvaXMtYXBpLXJvdXRlXCIpO1xuY29uc3QgX2dldG5leHRwYXRobmFtZWluZm8gPSByZXF1aXJlKFwiLi91dGlscy9nZXQtbmV4dC1wYXRobmFtZS1pbmZvXCIpO1xuY29uc3QgX2Zvcm1hdG5leHRwYXRobmFtZWluZm8gPSByZXF1aXJlKFwiLi91dGlscy9mb3JtYXQtbmV4dC1wYXRobmFtZS1pbmZvXCIpO1xuY29uc3QgX2NvbXBhcmVzdGF0ZXMgPSByZXF1aXJlKFwiLi91dGlscy9jb21wYXJlLXN0YXRlc1wiKTtcbmNvbnN0IF9pc2xvY2FsdXJsID0gcmVxdWlyZShcIi4vdXRpbHMvaXMtbG9jYWwtdXJsXCIpO1xuY29uc3QgX2lzYm90ID0gcmVxdWlyZShcIi4vdXRpbHMvaXMtYm90XCIpO1xuY29uc3QgX29taXQgPSByZXF1aXJlKFwiLi91dGlscy9vbWl0XCIpO1xuY29uc3QgX3Jlc29sdmVocmVmID0gcmVxdWlyZShcIi4vdXRpbHMvcmVzb2x2ZS1ocmVmXCIpO1xuY29uc3QgX2ludGVycG9sYXRlYXMgPSByZXF1aXJlKFwiLi91dGlscy9pbnRlcnBvbGF0ZS1hc1wiKTtcbmNvbnN0IF9oYW5kbGVzbW9vdGhzY3JvbGwgPSByZXF1aXJlKFwiLi91dGlscy9oYW5kbGUtc21vb3RoLXNjcm9sbFwiKTtcbmZ1bmN0aW9uIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IEVycm9yKFwiUm91dGUgQ2FuY2VsbGVkXCIpLCB7XG4gICAgICAgIGNhbmNlbGxlZDogdHJ1ZVxuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gbWF0Y2hlc01pZGRsZXdhcmUob3B0aW9ucykge1xuICAgIGNvbnN0IG1hdGNoZXJzID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKG9wdGlvbnMucm91dGVyLnBhZ2VMb2FkZXIuZ2V0TWlkZGxld2FyZSgpKTtcbiAgICBpZiAoIW1hdGNoZXJzKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgeyBwYXRobmFtZTogYXNQYXRobmFtZSAgfSA9ICgwLCBfcGFyc2VwYXRoLnBhcnNlUGF0aCkob3B0aW9ucy5hc1BhdGgpO1xuICAgIC8vIHJlbW92ZSBiYXNlUGF0aCBmaXJzdCBzaW5jZSBwYXRoIHByZWZpeCBoYXMgdG8gYmUgaW4gdGhlIG9yZGVyIG9mIGAvJHtiYXNlUGF0aH0vJHtsb2NhbGV9YFxuICAgIGNvbnN0IGNsZWFuZWRBcyA9ICgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKGFzUGF0aG5hbWUpID8gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoYXNQYXRobmFtZSkgOiBhc1BhdGhuYW1lO1xuICAgIGNvbnN0IGFzV2l0aEJhc2VQYXRoQW5kTG9jYWxlID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShjbGVhbmVkQXMsIG9wdGlvbnMubG9jYWxlKSk7XG4gICAgLy8gQ2hlY2sgb25seSBwYXRoIG1hdGNoIG9uIGNsaWVudC4gTWF0Y2hpbmcgXCJoYXNcIiBzaG91bGQgYmUgZG9uZSBvbiBzZXJ2ZXJcbiAgICAvLyB3aGVyZSB3ZSBjYW4gYWNjZXNzIG1vcmUgaW5mbyBzdWNoIGFzIGhlYWRlcnMsIEh0dHBPbmx5IGNvb2tpZSwgZXRjLlxuICAgIHJldHVybiBtYXRjaGVycy5zb21lKChtKT0+bmV3IFJlZ0V4cChtLnJlZ2V4cCkudGVzdChhc1dpdGhCYXNlUGF0aEFuZExvY2FsZSkpO1xufVxuZnVuY3Rpb24gc3RyaXBPcmlnaW4odXJsKSB7XG4gICAgY29uc3Qgb3JpZ2luID0gKDAsIF91dGlscy5nZXRMb2NhdGlvbk9yaWdpbikoKTtcbiAgICByZXR1cm4gdXJsLnN0YXJ0c1dpdGgob3JpZ2luKSA/IHVybC5zdWJzdHJpbmcob3JpZ2luLmxlbmd0aCkgOiB1cmw7XG59XG5mdW5jdGlvbiBwcmVwYXJlVXJsQXMocm91dGVyLCB1cmwsIGFzKSB7XG4gICAgLy8gSWYgdXJsIGFuZCBhcyBwcm92aWRlZCBhcyBhbiBvYmplY3QgcmVwcmVzZW50YXRpb24sXG4gICAgLy8gd2UnbGwgZm9ybWF0IHRoZW0gaW50byB0aGUgc3RyaW5nIHZlcnNpb24gaGVyZS5cbiAgICBsZXQgW3Jlc29sdmVkSHJlZiwgcmVzb2x2ZWRBc10gPSAoMCwgX3Jlc29sdmVocmVmLnJlc29sdmVIcmVmKShyb3V0ZXIsIHVybCwgdHJ1ZSk7XG4gICAgY29uc3Qgb3JpZ2luID0gKDAsIF91dGlscy5nZXRMb2NhdGlvbk9yaWdpbikoKTtcbiAgICBjb25zdCBocmVmV2FzQWJzb2x1dGUgPSByZXNvbHZlZEhyZWYuc3RhcnRzV2l0aChvcmlnaW4pO1xuICAgIGNvbnN0IGFzV2FzQWJzb2x1dGUgPSByZXNvbHZlZEFzICYmIHJlc29sdmVkQXMuc3RhcnRzV2l0aChvcmlnaW4pO1xuICAgIHJlc29sdmVkSHJlZiA9IHN0cmlwT3JpZ2luKHJlc29sdmVkSHJlZik7XG4gICAgcmVzb2x2ZWRBcyA9IHJlc29sdmVkQXMgPyBzdHJpcE9yaWdpbihyZXNvbHZlZEFzKSA6IHJlc29sdmVkQXM7XG4gICAgY29uc3QgcHJlcGFyZWRVcmwgPSBocmVmV2FzQWJzb2x1dGUgPyByZXNvbHZlZEhyZWYgOiAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShyZXNvbHZlZEhyZWYpO1xuICAgIGNvbnN0IHByZXBhcmVkQXMgPSBhcyA/IHN0cmlwT3JpZ2luKCgwLCBfcmVzb2x2ZWhyZWYucmVzb2x2ZUhyZWYpKHJvdXRlciwgYXMpKSA6IHJlc29sdmVkQXMgfHwgcmVzb2x2ZWRIcmVmO1xuICAgIHJldHVybiB7XG4gICAgICAgIHVybDogcHJlcGFyZWRVcmwsXG4gICAgICAgIGFzOiBhc1dhc0Fic29sdXRlID8gcHJlcGFyZWRBcyA6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHByZXBhcmVkQXMpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVEeW5hbWljUm91dGUocGF0aG5hbWUsIHBhZ2VzKSB7XG4gICAgY29uc3QgY2xlYW5QYXRobmFtZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKSgoMCwgX2Rlbm9ybWFsaXplcGFnZXBhdGguZGVub3JtYWxpemVQYWdlUGF0aCkocGF0aG5hbWUpKTtcbiAgICBpZiAoY2xlYW5QYXRobmFtZSA9PT0gXCIvNDA0XCIgfHwgY2xlYW5QYXRobmFtZSA9PT0gXCIvX2Vycm9yXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhuYW1lO1xuICAgIH1cbiAgICAvLyBoYW5kbGUgcmVzb2x2aW5nIGhyZWYgZm9yIGR5bmFtaWMgcm91dGVzXG4gICAgaWYgKCFwYWdlcy5pbmNsdWRlcyhjbGVhblBhdGhuYW1lKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyYXktY2FsbGJhY2stcmV0dXJuXG4gICAgICAgIHBhZ2VzLnNvbWUoKHBhZ2UpPT57XG4gICAgICAgICAgICBpZiAoKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKHBhZ2UpICYmICgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShwYWdlKS5yZS50ZXN0KGNsZWFuUGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBwYWdlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShwYXRobmFtZSk7XG59XG5mdW5jdGlvbiBnZXRNaWRkbGV3YXJlRGF0YShzb3VyY2UsIHJlc3BvbnNlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbmV4dENvbmZpZyA9IHtcbiAgICAgICAgYmFzZVBhdGg6IG9wdGlvbnMucm91dGVyLmJhc2VQYXRoLFxuICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICBsb2NhbGVzOiBvcHRpb25zLnJvdXRlci5sb2NhbGVzXG4gICAgICAgIH0sXG4gICAgICAgIHRyYWlsaW5nU2xhc2g6IEJvb2xlYW4ocHJvY2Vzcy5lbnYuX19ORVhUX1RSQUlMSU5HX1NMQVNIKVxuICAgIH07XG4gICAgY29uc3QgcmV3cml0ZUhlYWRlciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC1uZXh0anMtcmV3cml0ZVwiKTtcbiAgICBsZXQgcmV3cml0ZVRhcmdldCA9IHJld3JpdGVIZWFkZXIgfHwgcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LW5leHRqcy1tYXRjaGVkLXBhdGhcIik7XG4gICAgY29uc3QgbWF0Y2hlZFBhdGggPSByZXNwb25zZS5oZWFkZXJzLmdldChcIngtbWF0Y2hlZC1wYXRoXCIpO1xuICAgIGlmIChtYXRjaGVkUGF0aCAmJiAhcmV3cml0ZVRhcmdldCAmJiAhbWF0Y2hlZFBhdGguaW5jbHVkZXMoXCJfX25leHRfZGF0YV9jYXRjaGFsbFwiKSAmJiAhbWF0Y2hlZFBhdGguaW5jbHVkZXMoXCIvX2Vycm9yXCIpICYmICFtYXRjaGVkUGF0aC5pbmNsdWRlcyhcIi80MDRcIikpIHtcbiAgICAgICAgLy8gbGV2ZXJhZ2UgeC1tYXRjaGVkLXBhdGggdG8gZGV0ZWN0IG5leHQuY29uZmlnLmpzIHJld3JpdGVzXG4gICAgICAgIHJld3JpdGVUYXJnZXQgPSBtYXRjaGVkUGF0aDtcbiAgICB9XG4gICAgaWYgKHJld3JpdGVUYXJnZXQpIHtcbiAgICAgICAgaWYgKHJld3JpdGVUYXJnZXQuc3RhcnRzV2l0aChcIi9cIikgfHwgcHJvY2Vzcy5lbnYuX19ORVhUX0VYVEVSTkFMX01JRERMRVdBUkVfUkVXUklURV9SRVNPTFZFKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRSZXdyaXRlVGFyZ2V0ID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKHJld3JpdGVUYXJnZXQpO1xuICAgICAgICAgICAgY29uc3QgcGF0aG5hbWVJbmZvID0gKDAsIF9nZXRuZXh0cGF0aG5hbWVpbmZvLmdldE5leHRQYXRobmFtZUluZm8pKHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUsIHtcbiAgICAgICAgICAgICAgICBuZXh0Q29uZmlnLFxuICAgICAgICAgICAgICAgIHBhcnNlRGF0YTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgZnNQYXRobmFtZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShwYXRobmFtZUluZm8ucGF0aG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnJvdXRlci5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCksXG4gICAgICAgICAgICAgICAgKDAsIF9yb3V0ZWxvYWRlci5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KSgpXG4gICAgICAgICAgICBdKS50aGVuKChwYXJhbSk9PntcbiAgICAgICAgICAgICAgICBsZXQgW3BhZ2VzLCB7IF9fcmV3cml0ZXM6IHJld3JpdGVzICB9XSA9IHBhcmFtO1xuICAgICAgICAgICAgICAgIGxldCBhcyA9ICgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkocGF0aG5hbWVJbmZvLnBhdGhuYW1lLCBwYXRobmFtZUluZm8ubG9jYWxlKTtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKGFzKSB8fCAhcmV3cml0ZUhlYWRlciAmJiBwYWdlcy5pbmNsdWRlcygoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkoKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoYXMpLCBvcHRpb25zLnJvdXRlci5sb2NhbGVzKS5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkU291cmNlID0gKDAsIF9nZXRuZXh0cGF0aG5hbWVpbmZvLmdldE5leHRQYXRobmFtZUluZm8pKCgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShzb3VyY2UpLnBhdGhuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Q29uZmlnOiBwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTID8gdW5kZWZpbmVkIDogbmV4dENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRGF0YTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXMgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwYXJzZWRTb3VyY2UucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lID0gYXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9ICgwLCBfcmVzb2x2ZXJld3JpdGVzLmRlZmF1bHQpKGFzLCBwYWdlcywgcmV3cml0ZXMsIHBhcnNlZFJld3JpdGVUYXJnZXQucXVlcnksIChwYXRoKT0+cmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXRoLCBwYWdlcyksIG9wdGlvbnMucm91dGVyLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lm1hdGNoZWRQYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lID0gcmVzdWx0LnBhcnNlZEFzLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXMgPSBwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihwYXJzZWRSZXdyaXRlVGFyZ2V0LnF1ZXJ5LCByZXN1bHQucGFyc2VkQXMucXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghcGFnZXMuaW5jbHVkZXMoZnNQYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRQYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUoZnNQYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWRQYXRobmFtZSAhPT0gZnNQYXRobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnNQYXRobmFtZSA9IHJlc29sdmVkUGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRIcmVmID0gIXBhZ2VzLmluY2x1ZGVzKGZzUGF0aG5hbWUpID8gcmVzb2x2ZUR5bmFtaWNSb3V0ZSgoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkoKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZSksIG9wdGlvbnMucm91dGVyLmxvY2FsZXMpLnBhdGhuYW1lLCBwYWdlcykgOiBmc1BhdGhuYW1lO1xuICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocmVzb2x2ZWRIcmVmKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKSgoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocmVzb2x2ZWRIcmVmKSkoYXMpO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHBhcnNlZFJld3JpdGVUYXJnZXQucXVlcnksIG1hdGNoZXMgfHwge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJld3JpdGVcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkQXM6IHBhcnNlZFJld3JpdGVUYXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkSHJlZlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcmMgPSAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKHNvdXJjZSk7XG4gICAgICAgIGNvbnN0IHBhdGhuYW1lID0gKDAsIF9mb3JtYXRuZXh0cGF0aG5hbWVpbmZvLmZvcm1hdE5leHRQYXRobmFtZUluZm8pKHtcbiAgICAgICAgICAgIC4uLigwLCBfZ2V0bmV4dHBhdGhuYW1laW5mby5nZXROZXh0UGF0aG5hbWVJbmZvKShzcmMucGF0aG5hbWUsIHtcbiAgICAgICAgICAgICAgICBuZXh0Q29uZmlnLFxuICAgICAgICAgICAgICAgIHBhcnNlRGF0YTogdHJ1ZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlOiBvcHRpb25zLnJvdXRlci5kZWZhdWx0TG9jYWxlLFxuICAgICAgICAgICAgYnVpbGRJZDogXCJcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICB0eXBlOiBcInJlZGlyZWN0LWV4dGVybmFsXCIsXG4gICAgICAgICAgICBkZXN0aW5hdGlvbjogXCJcIiArIHBhdGhuYW1lICsgc3JjLnF1ZXJ5ICsgc3JjLmhhc2hcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHJlZGlyZWN0VGFyZ2V0ID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LW5leHRqcy1yZWRpcmVjdFwiKTtcbiAgICBpZiAocmVkaXJlY3RUYXJnZXQpIHtcbiAgICAgICAgaWYgKHJlZGlyZWN0VGFyZ2V0LnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICBjb25zdCBzcmMgPSAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKHJlZGlyZWN0VGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhuYW1lID0gKDAsIF9mb3JtYXRuZXh0cGF0aG5hbWVpbmZvLmZvcm1hdE5leHRQYXRobmFtZUluZm8pKHtcbiAgICAgICAgICAgICAgICAuLi4oMCwgX2dldG5leHRwYXRobmFtZWluZm8uZ2V0TmV4dFBhdGhuYW1lSW5mbykoc3JjLnBhdGhuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRDb25maWcsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRGF0YTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRMb2NhbGU6IG9wdGlvbnMucm91dGVyLmRlZmF1bHRMb2NhbGUsXG4gICAgICAgICAgICAgICAgYnVpbGRJZDogXCJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInJlZGlyZWN0LWludGVybmFsXCIsXG4gICAgICAgICAgICAgICAgbmV3QXM6IFwiXCIgKyBwYXRobmFtZSArIHNyYy5xdWVyeSArIHNyYy5oYXNoLFxuICAgICAgICAgICAgICAgIG5ld1VybDogXCJcIiArIHBhdGhuYW1lICsgc3JjLnF1ZXJ5ICsgc3JjLmhhc2hcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgdHlwZTogXCJyZWRpcmVjdC1leHRlcm5hbFwiLFxuICAgICAgICAgICAgZGVzdGluYXRpb246IHJlZGlyZWN0VGFyZ2V0XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgdHlwZTogXCJuZXh0XCJcbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHdpdGhNaWRkbGV3YXJlRWZmZWN0cyhvcHRpb25zKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IGF3YWl0IG1hdGNoZXNNaWRkbGV3YXJlKG9wdGlvbnMpO1xuICAgIGlmICghbWF0Y2hlcyB8fCAhb3B0aW9ucy5mZXRjaERhdGEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBvcHRpb25zLmZldGNoRGF0YSgpO1xuICAgICAgICBjb25zdCBlZmZlY3QgPSBhd2FpdCBnZXRNaWRkbGV3YXJlRGF0YShkYXRhLmRhdGFIcmVmLCBkYXRhLnJlc3BvbnNlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGFIcmVmOiBkYXRhLmRhdGFIcmVmLFxuICAgICAgICAgICAganNvbjogZGF0YS5qc29uLFxuICAgICAgICAgICAgcmVzcG9uc2U6IGRhdGEucmVzcG9uc2UsXG4gICAgICAgICAgICB0ZXh0OiBkYXRhLnRleHQsXG4gICAgICAgICAgICBjYWNoZUtleTogZGF0YS5jYWNoZUtleSxcbiAgICAgICAgICAgIGVmZmVjdFxuICAgICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyoqXG4gICAgICogVE9ETzogUmV2aXNpdCB0aGlzIGluIHRoZSBmdXR1cmUuXG4gICAgICogRm9yIG5vdyB3ZSB3aWxsIG5vdCBjb25zaWRlciBtaWRkbGV3YXJlIGRhdGEgZXJyb3JzIHRvIGJlIGZhdGFsLlxuICAgICAqIG1heWJlIHdlIHNob3VsZCByZXZpc2l0IGluIHRoZSBmdXR1cmUuXG4gICAgICovIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmNvbnN0IG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uID0gcHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTiAmJiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIFwic2Nyb2xsUmVzdG9yYXRpb25cIiBpbiB3aW5kb3cuaGlzdG9yeSAmJiAhIWZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCB2ID0gXCJfX25leHRcIjtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlcXVlbmNlc1xuICAgICAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSh2LCB2KSwgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSh2KSwgdHJ1ZTtcbiAgICB9IGNhdGNoIChuKSB7fVxufSgpO1xuY29uc3QgU1NHX0RBVEFfTk9UX0ZPVU5EID0gU3ltYm9sKFwiU1NHX0RBVEFfTk9UX0ZPVU5EXCIpO1xuZnVuY3Rpb24gZmV0Y2hSZXRyeSh1cmwsIGF0dGVtcHRzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZldGNoKHVybCwge1xuICAgICAgICAvLyBDb29raWVzIGFyZSByZXF1aXJlZCB0byBiZSBwcmVzZW50IGZvciBOZXh0LmpzJyBTU0cgXCJQcmV2aWV3IE1vZGVcIi5cbiAgICAgICAgLy8gQ29va2llcyBtYXkgYWxzbyBiZSByZXF1aXJlZCBmb3IgYGdldFNlcnZlclNpZGVQcm9wc2AuXG4gICAgICAgIC8vXG4gICAgICAgIC8vID4gYGZldGNoYCB3b27igJl0IHNlbmQgY29va2llcywgdW5sZXNzIHlvdSBzZXQgdGhlIGNyZWRlbnRpYWxzIGluaXRcbiAgICAgICAgLy8gPiBvcHRpb24uXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GZXRjaF9BUEkvVXNpbmdfRmV0Y2hcbiAgICAgICAgLy9cbiAgICAgICAgLy8gPiBGb3IgbWF4aW11bSBicm93c2VyIGNvbXBhdGliaWxpdHkgd2hlbiBpdCBjb21lcyB0byBzZW5kaW5nICZcbiAgICAgICAgLy8gPiByZWNlaXZpbmcgY29va2llcywgYWx3YXlzIHN1cHBseSB0aGUgYGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nYFxuICAgICAgICAvLyA+IG9wdGlvbiBpbnN0ZWFkIG9mIHJlbHlpbmcgb24gdGhlIGRlZmF1bHQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gjY2F2ZWF0c1xuICAgICAgICBjcmVkZW50aWFsczogXCJzYW1lLW9yaWdpblwiLFxuICAgICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuaGVhZGVycywge1xuICAgICAgICAgICAgXCJ4LW5leHRqcy1kYXRhXCI6IFwiMVwiXG4gICAgICAgIH0pXG4gICAgfSkudGhlbigocmVzcG9uc2UpPT57XG4gICAgICAgIHJldHVybiAhcmVzcG9uc2Uub2sgJiYgYXR0ZW1wdHMgPiAxICYmIHJlc3BvbnNlLnN0YXR1cyA+PSA1MDAgPyBmZXRjaFJldHJ5KHVybCwgYXR0ZW1wdHMgLSAxLCBvcHRpb25zKSA6IHJlc3BvbnNlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gdHJ5VG9QYXJzZUFzSlNPTih0ZXh0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGV4dCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gZmV0Y2hOZXh0RGF0YShwYXJhbSkge1xuICAgIGxldCB7IGRhdGFIcmVmICwgaW5mbGlnaHRDYWNoZSAsIGlzUHJlZmV0Y2ggLCBoYXNNaWRkbGV3YXJlICwgaXNTZXJ2ZXJSZW5kZXIgLCBwYXJzZUpTT04gLCBwZXJzaXN0Q2FjaGUgLCBpc0JhY2tncm91bmQgLCB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUgIH0gPSBwYXJhbTtcbiAgICBjb25zdCB7IGhyZWY6IGNhY2hlS2V5ICB9ID0gbmV3IFVSTChkYXRhSHJlZiwgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgIHZhciBfcGFyYW1zX21ldGhvZDtcbiAgICBjb25zdCBnZXREYXRhID0gKHBhcmFtcyk9PntcbiAgICAgICAgcmV0dXJuIGZldGNoUmV0cnkoZGF0YUhyZWYsIGlzU2VydmVyUmVuZGVyID8gMyA6IDEsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIGlzUHJlZmV0Y2ggPyB7XG4gICAgICAgICAgICAgICAgcHVycG9zZTogXCJwcmVmZXRjaFwiXG4gICAgICAgICAgICB9IDoge30sIGlzUHJlZmV0Y2ggJiYgaGFzTWlkZGxld2FyZSA/IHtcbiAgICAgICAgICAgICAgICBcIngtbWlkZGxld2FyZS1wcmVmZXRjaFwiOiBcIjFcIlxuICAgICAgICAgICAgfSA6IHt9KSxcbiAgICAgICAgICAgIG1ldGhvZDogKF9wYXJhbXNfbWV0aG9kID0gcGFyYW1zID09IG51bGwgPyB2b2lkIDAgOiBwYXJhbXMubWV0aG9kKSAhPSBudWxsID8gX3BhcmFtc19tZXRob2QgOiBcIkdFVFwiXG4gICAgICAgIH0pLnRoZW4oKHJlc3BvbnNlKT0+e1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rICYmIChwYXJhbXMgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmFtcy5tZXRob2QpID09PSBcIkhFQURcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAganNvbjoge30sXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCkudGhlbigodGV4dCk9PntcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hlbiB0aGUgZGF0YSByZXNwb25zZSBpcyBhIHJlZGlyZWN0IGJlY2F1c2Ugb2YgYSBtaWRkbGV3YXJlXG4gICAgICAgICAgICAgKiB3ZSBkbyBub3QgY29uc2lkZXIgaXQgYW4gZXJyb3IuIFRoZSBoZWFkZXJzIG11c3QgYnJpbmcgdGhlXG4gICAgICAgICAgICAgKiBtYXBwZWQgbG9jYXRpb24uXG4gICAgICAgICAgICAgKiBUT0RPOiBDaGFuZ2UgdGhlIHN0YXR1cyBjb2RlIGluIHRoZSBoYW5kbGVyLlxuICAgICAgICAgICAgICovIGlmIChoYXNNaWRkbGV3YXJlICYmIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwMixcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwNyxcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwOFxuICAgICAgICAgICAgICAgICAgICBdLmluY2x1ZGVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdHJ5VG9QYXJzZUFzSlNPTjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX3RyeVRvUGFyc2VBc0pTT04gPSB0cnlUb1BhcnNlQXNKU09OKHRleHQpKSA9PSBudWxsID8gdm9pZCAwIDogX3RyeVRvUGFyc2VBc0pTT04ubm90Rm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90Rm91bmQ6IFNTR19EQVRBX05PVF9GT1VORFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwiRmFpbGVkIHRvIGxvYWQgc3RhdGljIHByb3BzXCIpO1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdlIHNob3VsZCBvbmx5IHRyaWdnZXIgYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uIGlmIHRoaXMgd2FzXG4gICAgICAgICAgICAgKiBjYXVzZWQgb24gYSBjbGllbnQtc2lkZSB0cmFuc2l0aW9uLiBPdGhlcndpc2UsIHdlJ2QgZ2V0IGludG9cbiAgICAgICAgICAgICAqIGFuIGluZmluaXRlIGxvb3AuXG4gICAgICAgICAgICAgKi8gaWYgKCFpc1NlcnZlclJlbmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9yb3V0ZWxvYWRlci5tYXJrQXNzZXRFcnJvcikoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgICAgICAgICAganNvbjogcGFyc2VKU09OID8gdHJ5VG9QYXJzZUFzSlNPTih0ZXh0KSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICBjYWNoZUtleVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkudGhlbigoZGF0YSk9PntcbiAgICAgICAgICAgIGlmICghcGVyc2lzdENhY2hlIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiB8fCBkYXRhLnJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC1taWRkbGV3YXJlLWNhY2hlXCIpID09PSBcIm5vLWNhY2hlXCIpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaW5mbGlnaHRDYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgIGlmICghdW5zdGFibGVfc2tpcENsaWVudENhY2hlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKC8vIGNocm9tZVxuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPT09IFwiRmFpbGVkIHRvIGZldGNoXCIgfHwgLy8gZmlyZWZveFxuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPT09IFwiTmV0d29ya0Vycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBmZXRjaCByZXNvdXJjZS5cIiB8fCAvLyBzYWZhcmlcbiAgICAgICAgICAgIGVyci5tZXNzYWdlID09PSBcIkxvYWQgZmFpbGVkXCIpIHtcbiAgICAgICAgICAgICAgICAoMCwgX3JvdXRlbG9hZGVyLm1hcmtBc3NldEVycm9yKShlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIHdoZW4gc2tpcHBpbmcgY2xpZW50IGNhY2hlIHdlIHdhaXQgdG8gdXBkYXRlXG4gICAgLy8gaW5mbGlnaHQgY2FjaGUgdW50aWwgc3VjY2Vzc2Z1bCBkYXRhIHJlc3BvbnNlXG4gICAgLy8gdGhpcyBhbGxvd3MgcmFjaW5nIGNsaWNrIGV2ZW50IHdpdGggZmV0Y2hpbmcgbmV3ZXIgZGF0YVxuICAgIC8vIHdpdGhvdXQgYmxvY2tpbmcgbmF2aWdhdGlvbiB3aGVuIHN0YWxlIGRhdGEgaXMgYXZhaWxhYmxlXG4gICAgaWYgKHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSAmJiBwZXJzaXN0Q2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIGdldERhdGEoe30pLnRoZW4oKGRhdGEpPT57XG4gICAgICAgICAgICBpbmZsaWdodENhY2hlW2NhY2hlS2V5XSA9IFByb21pc2UucmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldO1xuICAgIH1cbiAgICByZXR1cm4gaW5mbGlnaHRDYWNoZVtjYWNoZUtleV0gPSBnZXREYXRhKGlzQmFja2dyb3VuZCA/IHtcbiAgICAgICAgbWV0aG9kOiBcIkhFQURcIlxuICAgIH0gOiB7fSk7XG59XG5mdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIsIDEwKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHBhcmFtKSB7XG4gICAgbGV0IHsgdXJsICwgcm91dGVyICB9ID0gcGFyYW07XG4gICAgLy8gZW5zdXJlIHdlIGRvbid0IHRyaWdnZXIgYSBoYXJkIG5hdmlnYXRpb24gdG8gdGhlIHNhbWVcbiAgICAvLyBVUkwgYXMgdGhpcyBjYW4gZW5kIHVwIHdpdGggYW4gaW5maW5pdGUgcmVmcmVzaFxuICAgIGlmICh1cmwgPT09ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkocm91dGVyLmFzUGF0aCwgcm91dGVyLmxvY2FsZSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFyaWFudDogYXR0ZW1wdGVkIHRvIGhhcmQgbmF2aWdhdGUgdG8gdGhlIHNhbWUgVVJMIFwiICsgdXJsICsgXCIgXCIgKyBsb2NhdGlvbi5ocmVmKTtcbiAgICB9XG4gICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG59XG5jb25zdCBnZXRDYW5jZWxsZWRIYW5kbGVyID0gKHBhcmFtKT0+e1xuICAgIGxldCB7IHJvdXRlICwgcm91dGVyICB9ID0gcGFyYW07XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGNhbmNlbCA9IHJvdXRlci5jbGMgPSAoKT0+e1xuICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlQ2FuY2VsbGVkID0gKCk9PntcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0Fib3J0IGZldGNoaW5nIGNvbXBvbmVudCBmb3Igcm91dGU6IFwiJyArIHJvdXRlICsgJ1wiJyk7XG4gICAgICAgICAgICBlcnJvci5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbmNlbCA9PT0gcm91dGVyLmNsYykge1xuICAgICAgICAgICAgcm91dGVyLmNsYyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBoYW5kbGVDYW5jZWxsZWQ7XG59O1xuY2xhc3MgUm91dGVyIHtcbiAgICByZWxvYWQoKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEdvIGJhY2sgaW4gaGlzdG9yeVxuICAgKi8gYmFjaygpIHtcbiAgICAgICAgd2luZG93Lmhpc3RvcnkuYmFjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICogR28gZm9yd2FyZCBpbiBoaXN0b3J5XG4gICAqLyBmb3J3YXJkKCkge1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5mb3J3YXJkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQZXJmb3JtcyBhIGBwdXNoU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi8gcHVzaCh1cmwsIGFzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSBpbiB0aGUgZnV0dXJlIHdoZW4gd2UgdXBkYXRlIGhpc3RvcnkgYmVmb3JlIHJvdXRlIGNoYW5nZVxuICAgICAgICAgICAgLy8gaXMgY29tcGxldGUsIGFzIHRoZSBwb3BzdGF0ZSBldmVudCBzaG91bGQgaGFuZGxlIHRoaXMgY2FwdHVyZS5cbiAgICAgICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNuYXBzaG90IHNjcm9sbCBwb3NpdGlvbiByaWdodCBiZWZvcmUgbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlOlxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFwiX19uZXh0X3Njcm9sbF9cIiArIHRoaXMuX2tleSwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogc2VsZi5wYWdlWE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHNlbGYucGFnZVlPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKHsgdXJsICwgYXMgIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UoXCJwdXNoU3RhdGVcIiwgdXJsLCBhcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQZXJmb3JtcyBhIGByZXBsYWNlU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi8gcmVwbGFjZSh1cmwsIGFzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgKHsgdXJsICwgYXMgIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UoXCJyZXBsYWNlU3RhdGVcIiwgdXJsLCBhcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIF9iZmwoYXMsIHJlc29sdmVkQXMsIGxvY2FsZSwgc2tpcE5hdmlnYXRlKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1JPVVRFUl9GSUxURVJfRU5BQkxFRCkge1xuICAgICAgICAgICAgbGV0IG1hdGNoZXNCZmxTdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBtYXRjaGVzQmZsRHluYW1pYyA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjdXJBcyBvZiBbXG4gICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRBc1xuICAgICAgICAgICAgXSl7XG4gICAgICAgICAgICAgICAgaWYgKGN1ckFzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzTm9TbGFzaCA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShuZXcgVVJMKGN1ckFzLCBcImh0dHA6Ly9uXCIpLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNOb1NsYXNoTG9jYWxlID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShhc05vU2xhc2gsIGxvY2FsZSB8fCB0aGlzLmxvY2FsZSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXNOb1NsYXNoICE9PSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkobmV3IFVSTCh0aGlzLmFzUGF0aCwgXCJodHRwOi8vblwiKS5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdGhpc19fYmZsX3MsIF90aGlzX19iZmxfczE7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzQmZsU3RhdGljID0gbWF0Y2hlc0JmbFN0YXRpYyB8fCAhISgoX3RoaXNfX2JmbF9zID0gdGhpcy5fYmZsX3MpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpc19fYmZsX3MuY29udGFpbnMoYXNOb1NsYXNoKSkgfHwgISEoKF90aGlzX19iZmxfczEgPSB0aGlzLl9iZmxfcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX19iZmxfczEuY29udGFpbnMoYXNOb1NsYXNoTG9jYWxlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5vcm1hbGl6ZWRBUyBvZiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNOb1NsYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzTm9TbGFzaExvY2FsZVxuICAgICAgICAgICAgICAgICAgICAgICAgXSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgYW55IHN1Yi1wYXRoIG9mIGFzIG1hdGNoZXMgYSBkeW5hbWljIGZpbHRlciBwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgc2hvdWxkIGJlIGhhcmQgbmF2aWdhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VyQXNQYXJ0cyA9IG5vcm1hbGl6ZWRBUy5zcGxpdChcIi9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgIW1hdGNoZXNCZmxEeW5hbWljICYmIGkgPCBjdXJBc1BhcnRzLmxlbmd0aCArIDE7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdGhpc19fYmZsX2Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQYXJ0ID0gY3VyQXNQYXJ0cy5zbGljZSgwLCBpKS5qb2luKFwiL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQYXJ0ICYmICgoX3RoaXNfX2JmbF9kID0gdGhpcy5fYmZsX2QpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpc19fYmZsX2QuY29udGFpbnMoY3VycmVudFBhcnQpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlc0JmbER5bmFtaWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY2xpZW50IHJvdXRlciBmaWx0ZXIgaXMgbWF0Y2hlZCB0aGVuIHdlIHRyaWdnZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgaGFyZCBuYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlc0JmbFN0YXRpYyB8fCBtYXRjaGVzQmZsRHluYW1pYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChza2lwTmF2aWdhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGFzLCBsb2NhbGUgfHwgdGhpcy5sb2NhbGUsIHRoaXMuZGVmYXVsdExvY2FsZSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGFzeW5jIGNoYW5nZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMsIGZvcmNlZFNjcm9sbCkge1xuICAgICAgICB2YXIgX3RoaXNfY29tcG9uZW50c19wYXRobmFtZTtcbiAgICAgICAgaWYgKCEoMCwgX2lzbG9jYWx1cmwuaXNMb2NhbFVSTCkodXJsKSkge1xuICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdBUk5JTkc6IGBfaGAgaXMgYW4gaW50ZXJuYWwgb3B0aW9uIGZvciBoYW5kaW5nIE5leHQuanMgY2xpZW50LXNpZGVcbiAgICAgICAgLy8gaHlkcmF0aW9uLiBZb3VyIGFwcCBzaG91bGQgX25ldmVyXyB1c2UgdGhpcyBwcm9wZXJ0eS4gSXQgbWF5IGNoYW5nZSBhdFxuICAgICAgICAvLyBhbnkgdGltZSB3aXRob3V0IG5vdGljZS5cbiAgICAgICAgY29uc3QgaXNRdWVyeVVwZGF0aW5nID0gb3B0aW9ucy5faCA9PT0gMTtcbiAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcgJiYgIW9wdGlvbnMuc2hhbGxvdykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fYmZsKGFzLCB1bmRlZmluZWQsIG9wdGlvbnMubG9jYWxlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2hvdWxkUmVzb2x2ZUhyZWYgPSBpc1F1ZXJ5VXBkYXRpbmcgfHwgb3B0aW9ucy5fc2hvdWxkUmVzb2x2ZUhyZWYgfHwgKDAsIF9wYXJzZXBhdGgucGFyc2VQYXRoKSh1cmwpLnBhdGhuYW1lID09PSAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKGFzKS5wYXRobmFtZTtcbiAgICAgICAgY29uc3QgbmV4dFN0YXRlID0ge1xuICAgICAgICAgICAgLi4udGhpcy5zdGF0ZVxuICAgICAgICB9O1xuICAgICAgICAvLyBmb3Igc3RhdGljIHBhZ2VzIHdpdGggcXVlcnkgcGFyYW1zIGluIHRoZSBVUkwgd2UgZGVsYXlcbiAgICAgICAgLy8gbWFya2luZyB0aGUgcm91dGVyIHJlYWR5IHVudGlsIGFmdGVyIHRoZSBxdWVyeSBpcyB1cGRhdGVkXG4gICAgICAgIC8vIG9yIGEgbmF2aWdhdGlvbiBoYXMgb2NjdXJyZWRcbiAgICAgICAgY29uc3QgcmVhZHlTdGF0ZUNoYW5nZSA9IHRoaXMuaXNSZWFkeSAhPT0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgaXNTc3IgPSB0aGlzLmlzU3NyO1xuICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgdGhpcy5pc1NzciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGEgcm91dGUgdHJhbnNpdGlvbiBpcyBhbHJlYWR5IGluIHByb2dyZXNzIGJlZm9yZVxuICAgICAgICAvLyB0aGUgcXVlcnkgdXBkYXRpbmcgaXMgdHJpZ2dlcmVkIGlnbm9yZSBxdWVyeSB1cGRhdGluZ1xuICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nICYmIHRoaXMuY2xjKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldkxvY2FsZSA9IG5leHRTdGF0ZS5sb2NhbGU7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICBuZXh0U3RhdGUubG9jYWxlID0gb3B0aW9ucy5sb2NhbGUgPT09IGZhbHNlID8gdGhpcy5kZWZhdWx0TG9jYWxlIDogb3B0aW9ucy5sb2NhbGUgfHwgbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmxvY2FsZSA9IG5leHRTdGF0ZS5sb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRBcyA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKSgoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShhcykgPyAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShhcykgOiBhcyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKHBhcnNlZEFzLnBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgaWYgKGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUpIHtcbiAgICAgICAgICAgICAgICBuZXh0U3RhdGUubG9jYWxlID0gbG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZTtcbiAgICAgICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHBhcnNlZEFzLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICBhcyA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWRBcyk7XG4gICAgICAgICAgICAgICAgdXJsID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKCgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKHVybCkgPyAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKSh1cmwpIDogdXJsLCB0aGlzLmxvY2FsZXMpLnBhdGhuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkaWROYXZpZ2F0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gdGhlIGVudiBjaGVjayBhZ2FpbiBzaW5jZSByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAvLyBtb3ZlcyB0aGlzIG9uIGl0cyBvd24gZHVlIHRvIHRoZSByZXR1cm5cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzX2xvY2FsZXM7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGxvY2FsZSBpc24ndCBjb25maWd1cmVkIGhhcmQgbmF2aWdhdGUgdG8gc2hvdyA0MDQgcGFnZVxuICAgICAgICAgICAgICAgIGlmICghKChfdGhpc19sb2NhbGVzID0gdGhpcy5sb2NhbGVzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXNfbG9jYWxlcy5pbmNsdWRlcyhuZXh0U3RhdGUubG9jYWxlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSAoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKHBhcnNlZEFzLnBhdGhuYW1lLCBuZXh0U3RhdGUubG9jYWxlKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkQXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdhcyBwcmV2aW91c2x5IGEgcmV0dXJuIGJ1dCB3YXMgcmVtb3ZlZCBpbiBmYXZvclxuICAgICAgICAgICAgICAgICAgICAvLyBvZiBiZXR0ZXIgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdpdGggcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgICAgICAgICAgICBkaWROYXZpZ2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGV0ZWN0ZWREb21haW4gPSAoMCwgX2RldGVjdGRvbWFpbmxvY2FsZS5kZXRlY3REb21haW5Mb2NhbGUpKHRoaXMuZG9tYWluTG9jYWxlcywgdW5kZWZpbmVkLCBuZXh0U3RhdGUubG9jYWxlKTtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gd3JhcCB0aGlzIGluIHRoZSBlbnYgY2hlY2sgYWdhaW4gc2luY2UgcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgICAgLy8gbW92ZXMgdGhpcyBvbiBpdHMgb3duIGR1ZSB0byB0aGUgcmV0dXJuXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBuYXZpZ2F0aW5nIHRvIGEgZG9tYWluIGxvY2FsZSBlbnN1cmUgd2UgcmVkaXJlY3QgdG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gY29ycmVjdCBkb21haW5cbiAgICAgICAgICAgICAgICBpZiAoIWRpZE5hdmlnYXRlICYmIGRldGVjdGVkRG9tYWluICYmIHRoaXMuaXNMb2NhbGVEb21haW4gJiYgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZSAhPT0gZGV0ZWN0ZWREb21haW4uZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzTm9CYXNlUGF0aCA9ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBcImh0dHBcIiArIChkZXRlY3RlZERvbWFpbi5odHRwID8gXCJcIiA6IFwic1wiKSArIFwiOi8vXCIgKyBkZXRlY3RlZERvbWFpbi5kb21haW4gKyAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShcIlwiICsgKG5leHRTdGF0ZS5sb2NhbGUgPT09IGRldGVjdGVkRG9tYWluLmRlZmF1bHRMb2NhbGUgPyBcIlwiIDogXCIvXCIgKyBuZXh0U3RhdGUubG9jYWxlKSArIChhc05vQmFzZVBhdGggPT09IFwiL1wiID8gXCJcIiA6IGFzTm9CYXNlUGF0aCkgfHwgXCIvXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdhcyBwcmV2aW91c2x5IGEgcmV0dXJuIGJ1dCB3YXMgcmVtb3ZlZCBpbiBmYXZvclxuICAgICAgICAgICAgICAgICAgICAvLyBvZiBiZXR0ZXIgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdpdGggcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgICAgICAgICAgICBkaWROYXZpZ2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpZE5hdmlnYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFya2luZyByb3V0ZSBjaGFuZ2VzIGFzIGEgbmF2aWdhdGlvbiBzdGFydCBlbnRyeVxuICAgICAgICBpZiAoX3V0aWxzLlNUKSB7XG4gICAgICAgICAgICBwZXJmb3JtYW5jZS5tYXJrKFwicm91dGVDaGFuZ2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzaGFsbG93ID1mYWxzZSAsIHNjcm9sbCA9dHJ1ZSAgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHJvdXRlUHJvcHMgPSB7XG4gICAgICAgICAgICBzaGFsbG93XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLl9pbkZsaWdodFJvdXRlICYmIHRoaXMuY2xjKSB7XG4gICAgICAgICAgICBpZiAoIWlzU3NyKSB7XG4gICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VFcnJvclwiLCBidWlsZENhbmNlbGxhdGlvbkVycm9yKCksIHRoaXMuX2luRmxpZ2h0Um91dGUsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbGMoKTtcbiAgICAgICAgICAgIHRoaXMuY2xjID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBhcyA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkoKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkoYXMpID8gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoYXMpIDogYXMsIG9wdGlvbnMubG9jYWxlLCB0aGlzLmRlZmF1bHRMb2NhbGUpKTtcbiAgICAgICAgY29uc3QgY2xlYW5lZEFzID0gKDAsIF9yZW1vdmVsb2NhbGUucmVtb3ZlTG9jYWxlKSgoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShhcykgPyAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShhcykgOiBhcywgbmV4dFN0YXRlLmxvY2FsZSk7XG4gICAgICAgIHRoaXMuX2luRmxpZ2h0Um91dGUgPSBhcztcbiAgICAgICAgY29uc3QgbG9jYWxlQ2hhbmdlID0gcHJldkxvY2FsZSAhPT0gbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgLy8gSWYgdGhlIHVybCBjaGFuZ2UgaXMgb25seSByZWxhdGVkIHRvIGEgaGFzaCBjaGFuZ2VcbiAgICAgICAgLy8gV2Ugc2hvdWxkIG5vdCBwcm9jZWVkLiBXZSBzaG91bGQgb25seSBjaGFuZ2UgdGhlIHN0YXRlLlxuICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZyAmJiB0aGlzLm9ubHlBSGFzaENoYW5nZShjbGVhbmVkQXMpICYmICFsb2NhbGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIG5leHRTdGF0ZS5hc1BhdGggPSBjbGVhbmVkQXM7XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJoYXNoQ2hhbmdlU3RhcnRcIiwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgLy8gVE9ETzogZG8gd2UgbmVlZCB0aGUgcmVzb2x2ZWQgaHJlZiB3aGVuIG9ubHkgYSBoYXNoIGNoYW5nZT9cbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCB7XG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBzY3JvbGw6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzY3JvbGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFRvSGFzaChjbGVhbmVkQXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldChuZXh0U3RhdGUsIHRoaXMuY29tcG9uZW50c1tuZXh0U3RhdGUucm91dGVdLCBudWxsKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzZXJyb3IuZGVmYXVsdCkoZXJyKSAmJiBlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcInJvdXRlQ2hhbmdlRXJyb3JcIiwgZXJyLCBjbGVhbmVkQXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJoYXNoQ2hhbmdlQ29tcGxldGVcIiwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcnNlZCA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKSh1cmwpO1xuICAgICAgICBsZXQgeyBwYXRobmFtZSAsIHF1ZXJ5ICB9ID0gcGFyc2VkO1xuICAgICAgICAvLyBpZiB3ZSBkZXRlY3RlZCB0aGUgcGF0aCBhcyBhcHAgcm91dGUgZHVyaW5nIHByZWZldGNoaW5nXG4gICAgICAgIC8vIHRyaWdnZXIgaGFyZCBuYXZpZ2F0aW9uXG4gICAgICAgIGlmICgoX3RoaXNfY29tcG9uZW50c19wYXRobmFtZSA9IHRoaXMuY29tcG9uZW50c1twYXRobmFtZV0pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpc19jb21wb25lbnRzX3BhdGhuYW1lLl9fYXBwUm91dGVyKSB7XG4gICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGJ1aWxkIG1hbmlmZXN0IG5lZWRzIHRvIGJlIGxvYWRlZCBiZWZvcmUgYXV0by1zdGF0aWMgZHluYW1pYyBwYWdlc1xuICAgICAgICAvLyBnZXQgdGhlaXIgcXVlcnkgcGFyYW1ldGVycyB0byBhbGxvdyBlbnN1cmluZyB0aGV5IGNhbiBiZSBwYXJzZWQgcHJvcGVybHlcbiAgICAgICAgLy8gd2hlbiByZXdyaXR0ZW4gdG9cbiAgICAgICAgbGV0IHBhZ2VzLCByZXdyaXRlcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFtwYWdlcywgeyBfX3Jld3JpdGVzOiByZXdyaXRlcyAgfV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCksXG4gICAgICAgICAgICAgICAgKDAsIF9yb3V0ZWxvYWRlci5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KSgpLFxuICAgICAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlci5nZXRNaWRkbGV3YXJlKClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGZhaWwgdG8gcmVzb2x2ZSB0aGUgcGFnZSBsaXN0IG9yIGNsaWVudC1idWlsZCBtYW5pZmVzdCwgd2UgbXVzdFxuICAgICAgICAgICAgLy8gZG8gYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uOlxuICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhc2tlZCB0byBjaGFuZ2UgdGhlIGN1cnJlbnQgVVJMIHdlIHNob3VsZCByZWxvYWQgdGhlIGN1cnJlbnQgcGFnZVxuICAgICAgICAvLyAobm90IGxvY2F0aW9uLnJlbG9hZCgpIGJ1dCByZWxvYWQgZ2V0SW5pdGlhbFByb3BzIGFuZCBvdGhlciBOZXh0LmpzIHN0dWZmcylcbiAgICAgICAgLy8gV2UgYWxzbyBuZWVkIHRvIHNldCB0aGUgbWV0aG9kID0gcmVwbGFjZVN0YXRlIGFsd2F5c1xuICAgICAgICAvLyBhcyB0aGlzIHNob3VsZCBub3QgZ28gaW50byB0aGUgaGlzdG9yeSAoVGhhdCdzIGhvdyBicm93c2VycyB3b3JrKVxuICAgICAgICAvLyBXZSBzaG91bGQgY29tcGFyZSB0aGUgbmV3IGFzUGF0aCB0byB0aGUgY3VycmVudCBhc1BhdGgsIG5vdCB0aGUgdXJsXG4gICAgICAgIGlmICghdGhpcy51cmxJc05ldyhjbGVhbmVkQXMpICYmICFsb2NhbGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IFwicmVwbGFjZVN0YXRlXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgbmVlZCB0byByZXNvbHZlIHRoZSBhcyB2YWx1ZSB1c2luZyByZXdyaXRlcyBmb3IgZHluYW1pYyBTU0dcbiAgICAgICAgLy8gcGFnZXMgdG8gYWxsb3cgYnVpbGRpbmcgdGhlIGRhdGEgVVJMIGNvcnJlY3RseVxuICAgICAgICBsZXQgcmVzb2x2ZWRBcyA9IGFzO1xuICAgICAgICAvLyB1cmwgYW5kIGFzIHNob3VsZCBhbHdheXMgYmUgcHJlZml4ZWQgd2l0aCBiYXNlUGF0aCBieSB0aGlzXG4gICAgICAgIC8vIHBvaW50IGJ5IGVpdGhlciBuZXh0L2xpbmsgb3Igcm91dGVyLnB1c2gvcmVwbGFjZSBzbyBzdHJpcCB0aGVcbiAgICAgICAgLy8gYmFzZVBhdGggZnJvbSB0aGUgcGF0aG5hbWUgdG8gbWF0Y2ggdGhlIHBhZ2VzIGRpciAxLXRvLTFcbiAgICAgICAgcGF0aG5hbWUgPSBwYXRobmFtZSA/ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKSgoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShwYXRobmFtZSkpIDogcGF0aG5hbWU7XG4gICAgICAgIGxldCByb3V0ZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShwYXRobmFtZSk7XG4gICAgICAgIGNvbnN0IHBhcnNlZEFzUGF0aG5hbWUgPSBhcy5zdGFydHNXaXRoKFwiL1wiKSAmJiAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkoYXMpLnBhdGhuYW1lO1xuICAgICAgICBjb25zdCBpc01pZGRsZXdhcmVSZXdyaXRlID0gISEocGFyc2VkQXNQYXRobmFtZSAmJiByb3V0ZSAhPT0gcGFyc2VkQXNQYXRobmFtZSAmJiAoISgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShyb3V0ZSkgfHwgISgwLCBfcm91dGVtYXRjaGVyLmdldFJvdXRlTWF0Y2hlcikoKDAsIF9yb3V0ZXJlZ2V4LmdldFJvdXRlUmVnZXgpKHJvdXRlKSkocGFyc2VkQXNQYXRobmFtZSkpKTtcbiAgICAgICAgLy8gd2UgZG9uJ3QgYXR0ZW1wdCByZXNvbHZlIGFzUGF0aCB3aGVuIHdlIG5lZWQgdG8gZXhlY3V0ZVxuICAgICAgICAvLyBtaWRkbGV3YXJlIGFzIHRoZSByZXNvbHZpbmcgd2lsbCBvY2N1ciBzZXJ2ZXItc2lkZVxuICAgICAgICBjb25zdCBpc01pZGRsZXdhcmVNYXRjaCA9ICFvcHRpb25zLnNoYWxsb3cgJiYgYXdhaXQgbWF0Y2hlc01pZGRsZXdhcmUoe1xuICAgICAgICAgICAgYXNQYXRoOiBhcyxcbiAgICAgICAgICAgIGxvY2FsZTogbmV4dFN0YXRlLmxvY2FsZSxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiBpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgc2hvdWxkUmVzb2x2ZUhyZWYgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkUmVzb2x2ZUhyZWYgJiYgcGF0aG5hbWUgIT09IFwiL19lcnJvclwiKSB7XG4gICAgICAgICAgICBvcHRpb25zLl9zaG91bGRSZXNvbHZlSHJlZiA9IHRydWU7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyAmJiBhcy5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJld3JpdGVzUmVzdWx0ID0gKDAsIF9yZXNvbHZlcmV3cml0ZXMuZGVmYXVsdCkoKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShjbGVhbmVkQXMsIG5leHRTdGF0ZS5sb2NhbGUpLCB0cnVlKSwgcGFnZXMsIHJld3JpdGVzLCBxdWVyeSwgKHApPT5yZXNvbHZlRHluYW1pY1JvdXRlKHAsIHBhZ2VzKSwgdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgICAgICBpZiAocmV3cml0ZXNSZXN1bHQuZXh0ZXJuYWxEZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkQXMgPSByZXdyaXRlc1Jlc3VsdC5hc1BhdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5tYXRjaGVkUGFnZSAmJiByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBkaXJlY3RseSBtYXRjaGVzIGEgcGFnZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaHJlZiB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBhbGxvdyB0aGUgY29ycmVjdCBwYWdlIGNodW5rIHRvIGJlIGxvYWRlZFxuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQucGF0aG5hbWUgIT09IHBhdGhuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghKDAsIF9pc2xvY2FsdXJsLmlzTG9jYWxVUkwpKGFzKSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBocmVmOiBcIicgKyB1cmwgKyAnXCIgYW5kIGFzOiBcIicgKyBhcyArICdcIiwgcmVjZWl2ZWQgcmVsYXRpdmUgaHJlZiBhbmQgZXh0ZXJuYWwgYXMnICsgXCJcXG5TZWUgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9pbnZhbGlkLXJlbGF0aXZlLXVybC1leHRlcm5hbC1hc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICB1cmw6IGFzLFxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZWRBcyA9ICgwLCBfcmVtb3ZlbG9jYWxlLnJlbW92ZUxvY2FsZSkoKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocmVzb2x2ZWRBcyksIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICByb3V0ZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShwYXRobmFtZSk7XG4gICAgICAgIGxldCByb3V0ZU1hdGNoID0gZmFsc2U7XG4gICAgICAgIGlmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocm91dGUpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRBcyA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShyZXNvbHZlZEFzKTtcbiAgICAgICAgICAgIGNvbnN0IGFzUGF0aG5hbWUgPSBwYXJzZWRBcy5wYXRobmFtZTtcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlUmVnZXggPSAoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocm91dGUpO1xuICAgICAgICAgICAgcm91dGVNYXRjaCA9ICgwLCBfcm91dGVtYXRjaGVyLmdldFJvdXRlTWF0Y2hlcikocm91dGVSZWdleCkoYXNQYXRobmFtZSk7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRJbnRlcnBvbGF0ZSA9IHJvdXRlID09PSBhc1BhdGhuYW1lO1xuICAgICAgICAgICAgY29uc3QgaW50ZXJwb2xhdGVkQXMgPSBzaG91bGRJbnRlcnBvbGF0ZSA/ICgwLCBfaW50ZXJwb2xhdGVhcy5pbnRlcnBvbGF0ZUFzKShyb3V0ZSwgYXNQYXRobmFtZSwgcXVlcnkpIDoge307XG4gICAgICAgICAgICBpZiAoIXJvdXRlTWF0Y2ggfHwgc2hvdWxkSW50ZXJwb2xhdGUgJiYgIWludGVycG9sYXRlZEFzLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pc3NpbmdQYXJhbXMgPSBPYmplY3Qua2V5cyhyb3V0ZVJlZ2V4Lmdyb3VwcykuZmlsdGVyKChwYXJhbSk9PiFxdWVyeVtwYXJhbV0gJiYgIXJvdXRlUmVnZXguZ3JvdXBzW3BhcmFtXS5vcHRpb25hbCk7XG4gICAgICAgICAgICAgICAgaWYgKG1pc3NpbmdQYXJhbXMubGVuZ3RoID4gMCAmJiAhaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiXCIgKyAoc2hvdWxkSW50ZXJwb2xhdGUgPyBcIkludGVycG9sYXRpbmcgaHJlZlwiIDogXCJNaXNtYXRjaGluZyBgYXNgIGFuZCBgaHJlZmBcIikgKyBcIiBmYWlsZWQgdG8gbWFudWFsbHkgcHJvdmlkZSBcIiArIChcInRoZSBwYXJhbXM6IFwiICsgbWlzc2luZ1BhcmFtcy5qb2luKFwiLCBcIikgKyBcIiBpbiB0aGUgYGhyZWZgJ3MgYHF1ZXJ5YFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChzaG91bGRJbnRlcnBvbGF0ZSA/IFwiVGhlIHByb3ZpZGVkIGBocmVmYCAoXCIgKyB1cmwgKyBcIikgdmFsdWUgaXMgbWlzc2luZyBxdWVyeSB2YWx1ZXMgKFwiICsgbWlzc2luZ1BhcmFtcy5qb2luKFwiLCBcIikgKyBcIikgdG8gYmUgaW50ZXJwb2xhdGVkIHByb3Blcmx5LiBcIiA6IFwiVGhlIHByb3ZpZGVkIGBhc2AgdmFsdWUgKFwiICsgYXNQYXRobmFtZSArIFwiKSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgYGhyZWZgIHZhbHVlIChcIiArIHJvdXRlICsgXCIpLiBcIikgKyAoXCJSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL1wiICsgKHNob3VsZEludGVycG9sYXRlID8gXCJocmVmLWludGVycG9sYXRpb24tZmFpbGVkXCIgOiBcImluY29tcGF0aWJsZS1ocmVmLWFzXCIpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaG91bGRJbnRlcnBvbGF0ZSkge1xuICAgICAgICAgICAgICAgIGFzID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKE9iamVjdC5hc3NpZ24oe30sIHBhcnNlZEFzLCB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBpbnRlcnBvbGF0ZWRBcy5yZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiAoMCwgX29taXQub21pdCkocXVlcnksIGludGVycG9sYXRlZEFzLnBhcmFtcylcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE1lcmdlIHBhcmFtcyBpbnRvIGBxdWVyeWAsIG92ZXJ3cml0aW5nIGFueSBzcGVjaWZpZWQgaW4gc2VhcmNoXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgcm91dGVNYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcInJvdXRlQ2hhbmdlU3RhcnRcIiwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzRXJyb3JSb3V0ZSA9IHRoaXMucGF0aG5hbWUgPT09IFwiLzQwNFwiIHx8IHRoaXMucGF0aG5hbWUgPT09IFwiL19lcnJvclwiO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMsIF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzLCBfcm91dGVJbmZvX3Byb3BzO1xuICAgICAgICAgICAgbGV0IHJvdXRlSW5mbyA9IGF3YWl0IHRoaXMuZ2V0Um91dGVJbmZvKHtcbiAgICAgICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgIHJvdXRlUHJvcHMsXG4gICAgICAgICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICAgICAgICAgIGlzUHJldmlldzogbmV4dFN0YXRlLmlzUHJldmlldyxcbiAgICAgICAgICAgICAgICBoYXNNaWRkbGV3YXJlOiBpc01pZGRsZXdhcmVNYXRjaCxcbiAgICAgICAgICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGU6IG9wdGlvbnMudW5zdGFibGVfc2tpcENsaWVudENhY2hlLFxuICAgICAgICAgICAgICAgIGlzUXVlcnlVcGRhdGluZzogaXNRdWVyeVVwZGF0aW5nICYmICF0aGlzLmlzRmFsbGJhY2ssXG4gICAgICAgICAgICAgICAgaXNNaWRkbGV3YXJlUmV3cml0ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZyAmJiAhb3B0aW9ucy5zaGFsbG93KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fYmZsKGFzLCBcInJlc29sdmVkQXNcIiBpbiByb3V0ZUluZm8gPyByb3V0ZUluZm8ucmVzb2x2ZWRBcyA6IHVuZGVmaW5lZCwgbmV4dFN0YXRlLmxvY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJyb3V0ZVwiIGluIHJvdXRlSW5mbyAmJiBpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcm91dGVJbmZvLnJvdXRlIHx8IHJvdXRlO1xuICAgICAgICAgICAgICAgIHJvdXRlID0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCFyb3V0ZVByb3BzLnNoYWxsb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnkgPSBPYmplY3QuYXNzaWduKHt9LCByb3V0ZUluZm8ucXVlcnkgfHwge30sIHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2xlYW5lZFBhcnNlZFBhdGhuYW1lID0gKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkocGFyc2VkLnBhdGhuYW1lKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHBhcnNlZC5wYXRobmFtZSkgOiBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlTWF0Y2ggJiYgcGF0aG5hbWUgIT09IGNsZWFuZWRQYXJzZWRQYXRobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhyb3V0ZU1hdGNoKS5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocm91dGVNYXRjaCAmJiBxdWVyeVtrZXldID09PSByb3V0ZU1hdGNoW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcXVlcnlba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZWZpeGVkQXMgPSAhcm91dGVQcm9wcy5zaGFsbG93ICYmIHJvdXRlSW5mby5yZXNvbHZlZEFzID8gcm91dGVJbmZvLnJlc29sdmVkQXMgOiAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKG5ldyBVUkwoYXMsIGxvY2F0aW9uLmhyZWYpLnBhdGhuYW1lLCBuZXh0U3RhdGUubG9jYWxlKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXdyaXRlQXMgPSBwcmVmaXhlZEFzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkocmV3cml0ZUFzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV3cml0ZUFzID0gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocmV3cml0ZUFzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxlUmVzdWx0ID0gKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKHJld3JpdGVBcywgdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5sb2NhbGUgPSBsb2NhbGVSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUgfHwgbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJld3JpdGVBcyA9IGxvY2FsZVJlc3VsdC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByb3V0ZVJlZ2V4ID0gKDAsIF9yb3V0ZXJlZ2V4LmdldFJvdXRlUmVnZXgpKHBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VyUm91dGVNYXRjaCA9ICgwLCBfcm91dGVtYXRjaGVyLmdldFJvdXRlTWF0Y2hlcikocm91dGVSZWdleCkobmV3IFVSTChyZXdyaXRlQXMsIGxvY2F0aW9uLmhyZWYpLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1clJvdXRlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksIGN1clJvdXRlTWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIHJvdXRlSW5mbyBicmluZ3MgYSByZWRpcmVjdCB3ZSBzaW1wbHkgYXBwbHkgaXQuXG4gICAgICAgICAgICBpZiAoXCJ0eXBlXCIgaW4gcm91dGVJbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlSW5mby50eXBlID09PSBcInJlZGlyZWN0LWludGVybmFsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKG1ldGhvZCwgcm91dGVJbmZvLm5ld1VybCwgcm91dGVJbmZvLm5ld0FzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHJvdXRlSW5mby5kZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gcm91dGVJbmZvLkNvbXBvbmVudDtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQgJiYgY29tcG9uZW50LnVuc3RhYmxlX3NjcmlwdExvYWRlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjcmlwdHMgPSBbXS5jb25jYXQoY29tcG9uZW50LnVuc3RhYmxlX3NjcmlwdExvYWRlcigpKTtcbiAgICAgICAgICAgICAgICBzY3JpcHRzLmZvckVhY2goKHNjcmlwdCk9PntcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9zY3JpcHQuaGFuZGxlQ2xpZW50U2NyaXB0TG9hZCkoc2NyaXB0LnByb3BzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhhbmRsZSByZWRpcmVjdCBvbiBjbGllbnQtdHJhbnNpdGlvblxuICAgICAgICAgICAgaWYgKChyb3V0ZUluZm8uX19OX1NTRyB8fCByb3V0ZUluZm8uX19OX1NTUCkgJiYgcm91dGVJbmZvLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMgJiYgcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBkZXN0aW5hdGlvbiBmcm9tIHJlZGlyZWN0IHdpdGhvdXQgYWRkaW5nIGxvY2FsZVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmxvY2FsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXN0aW5hdGlvbiA9IHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUO1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBkZXN0aW5hdGlvbiBpcyBpbnRlcm5hbCAocmVzb2x2ZXMgdG8gYSBwYWdlKSBhbmQgYXR0ZW1wdFxuICAgICAgICAgICAgICAgICAgICAvLyBjbGllbnQtbmF2aWdhdGlvbiBpZiBpdCBpcyBmYWxsaW5nIGJhY2sgdG8gaGFyZCBuYXZpZ2F0aW9uIGlmXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0J3Mgbm90XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbi5zdGFydHNXaXRoKFwiL1wiKSAmJiByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVF9CQVNFX1BBVEggIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRIcmVmID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZEhyZWYucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhcnNlZEhyZWYucGF0aG5hbWUsIHBhZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdXJsOiBuZXdVcmwgLCBhczogbmV3QXMgIH0gPSBwcmVwYXJlVXJsQXModGhpcywgZGVzdGluYXRpb24sIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShtZXRob2QsIG5ld1VybCwgbmV3QXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0U3RhdGUuaXNQcmV2aWV3ID0gISFyb3V0ZUluZm8ucHJvcHMuX19OX1BSRVZJRVc7XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIFNTRyBkYXRhIDQwNFxuICAgICAgICAgICAgICAgIGlmIChyb3V0ZUluZm8ucHJvcHMubm90Rm91bmQgPT09IFNTR19EQVRBX05PVF9GT1VORCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbm90Rm91bmRSb3V0ZTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoXCIvNDA0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90Rm91bmRSb3V0ZSA9IFwiLzQwNFwiO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZFJvdXRlID0gXCIvX2Vycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oe1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGU6IG5vdEZvdW5kUm91dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogbm90Rm91bmRSb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVQcm9wczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWxsb3c6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmV2aWV3OiBuZXh0U3RhdGUuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNOb3RGb3VuZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwidHlwZVwiIGluIHJvdXRlSW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBtaWRkbGV3YXJlIGVmZmVjdCBvbiAvNDA0XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiB0aGlzLnBhdGhuYW1lID09PSBcIi9fZXJyb3JcIiAmJiAoKF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMgPSBzZWxmLl9fTkVYVF9EQVRBX18ucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiAoX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMgPSBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzLnBhZ2VQcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzLnN0YXR1c0NvZGUpID09PSA1MDAgJiYgKChfcm91dGVJbmZvX3Byb3BzID0gcm91dGVJbmZvLnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdXRlSW5mb19wcm9wcy5wYWdlUHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIHN0YXR1c0NvZGUgaXMgc3RpbGwgY29ycmVjdCBmb3Igc3RhdGljIDUwMCBwYWdlXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB1cGRhdGluZyBxdWVyeSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuc3RhdHVzQ29kZSA9IDUwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfcm91dGVJbmZvX3JvdXRlO1xuICAgICAgICAgICAgLy8gc2hhbGxvdyByb3V0aW5nIGlzIG9ubHkgYWxsb3dlZCBmb3Igc2FtZSBwYWdlIFVSTCBjaGFuZ2VzLlxuICAgICAgICAgICAgY29uc3QgaXNWYWxpZFNoYWxsb3dSb3V0ZSA9IG9wdGlvbnMuc2hhbGxvdyAmJiBuZXh0U3RhdGUucm91dGUgPT09ICgoX3JvdXRlSW5mb19yb3V0ZSA9IHJvdXRlSW5mby5yb3V0ZSkgIT0gbnVsbCA/IF9yb3V0ZUluZm9fcm91dGUgOiByb3V0ZSk7XG4gICAgICAgICAgICB2YXIgX29wdGlvbnNfc2Nyb2xsO1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkU2Nyb2xsID0gKF9vcHRpb25zX3Njcm9sbCA9IG9wdGlvbnMuc2Nyb2xsKSAhPSBudWxsID8gX29wdGlvbnNfc2Nyb2xsIDogIWlzUXVlcnlVcGRhdGluZyAmJiAhaXNWYWxpZFNoYWxsb3dSb3V0ZTtcbiAgICAgICAgICAgIGNvbnN0IHJlc2V0U2Nyb2xsID0gc2hvdWxkU2Nyb2xsID8ge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgfSA6IG51bGw7XG4gICAgICAgICAgICBjb25zdCB1cGNvbWluZ1Njcm9sbFN0YXRlID0gZm9yY2VkU2Nyb2xsICE9IG51bGwgPyBmb3JjZWRTY3JvbGwgOiByZXNldFNjcm9sbDtcbiAgICAgICAgICAgIC8vIHRoZSBuZXcgc3RhdGUgdGhhdCB0aGUgcm91dGVyIGdvbm5hIHNldFxuICAgICAgICAgICAgY29uc3QgdXBjb21pbmdSb3V0ZXJTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAuLi5uZXh0U3RhdGUsXG4gICAgICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgYXNQYXRoOiBjbGVhbmVkQXMsXG4gICAgICAgICAgICAgICAgaXNGYWxsYmFjazogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBXaGVuIHRoZSBwYWdlIGJlaW5nIHJlbmRlcmVkIGlzIHRoZSA0MDQgcGFnZSwgd2Ugc2hvdWxkIG9ubHkgdXBkYXRlIHRoZVxuICAgICAgICAgICAgLy8gcXVlcnkgcGFyYW1ldGVycy4gUm91dGUgY2hhbmdlcyBoZXJlIG1pZ2h0IGFkZCB0aGUgYmFzZVBhdGggd2hlbiBpdFxuICAgICAgICAgICAgLy8gd2Fzbid0IG9yaWdpbmFsbHkgcHJlc2VudC4gVGhpcyBpcyBhbHNvIHdoeSB0aGlzIGJsb2NrIGlzIGJlZm9yZSB0aGVcbiAgICAgICAgICAgIC8vIGJlbG93IGBjaGFuZ2VTdGF0ZWAgY2FsbCB3aGljaCB1cGRhdGVzIHRoZSBicm93c2VyJ3MgaGlzdG9yeSAoY2hhbmdpbmdcbiAgICAgICAgICAgIC8vIHRoZSBVUkwpLlxuICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiBpc0Vycm9yUm91dGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wczEsIF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzMSwgX3JvdXRlSW5mb19wcm9wczE7XG4gICAgICAgICAgICAgICAgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oe1xuICAgICAgICAgICAgICAgICAgICByb3V0ZTogdGhpcy5wYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IHRoaXMucGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgcm91dGVQcm9wczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhbGxvdzogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgICAgIGlzUXVlcnlVcGRhdGluZzogaXNRdWVyeVVwZGF0aW5nICYmICF0aGlzLmlzRmFsbGJhY2tcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoXCJ0eXBlXCIgaW4gcm91dGVJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgbWlkZGxld2FyZSBlZmZlY3Qgb24gXCIgKyB0aGlzLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGF0aG5hbWUgPT09IFwiL19lcnJvclwiICYmICgoX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wczEgPSBzZWxmLl9fTkVYVF9EQVRBX18ucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiAoX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMxID0gX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wczEucGFnZVByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMxLnN0YXR1c0NvZGUpID09PSA1MDAgJiYgKChfcm91dGVJbmZvX3Byb3BzMSA9IHJvdXRlSW5mby5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3V0ZUluZm9fcHJvcHMxLnBhZ2VQcm9wcykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIHN0YXR1c0NvZGUgaXMgc3RpbGwgY29ycmVjdCBmb3Igc3RhdGljIDUwMCBwYWdlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdXBkYXRpbmcgcXVlcnkgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5zdGF0dXNDb2RlID0gNTAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldCh1cGNvbWluZ1JvdXRlclN0YXRlLCByb3V0ZUluZm8sIHVwY29taW5nU2Nyb2xsU3RhdGUpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc2Vycm9yLmRlZmF1bHQpKGVycikgJiYgZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VFcnJvclwiLCBlcnIsIGNsZWFuZWRBcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcImJlZm9yZUhpc3RvcnlDaGFuZ2VcIiwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gZm9yIHF1ZXJ5IHVwZGF0ZXMgd2UgY2FuIHNraXAgaXQgaWYgdGhlIHN0YXRlIGlzIHVuY2hhbmdlZCBhbmQgd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gc2Nyb2xsXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvaXNzdWVzLzM3MTM5XG4gICAgICAgICAgICBjb25zdCBjYW5Ta2lwVXBkYXRpbmcgPSBpc1F1ZXJ5VXBkYXRpbmcgJiYgIXVwY29taW5nU2Nyb2xsU3RhdGUgJiYgIXJlYWR5U3RhdGVDaGFuZ2UgJiYgIWxvY2FsZUNoYW5nZSAmJiAoMCwgX2NvbXBhcmVzdGF0ZXMuY29tcGFyZVJvdXRlclN0YXRlcykodXBjb21pbmdSb3V0ZXJTdGF0ZSwgdGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICBpZiAoIWNhblNraXBVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0KHVwY29taW5nUm91dGVyU3RhdGUsIHJvdXRlSW5mbywgdXBjb21pbmdTY3JvbGxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5jYW5jZWxsZWQpIHJvdXRlSW5mby5lcnJvciA9IHJvdXRlSW5mby5lcnJvciB8fCBlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyb3V0ZUluZm8uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcInJvdXRlQ2hhbmdlRXJyb3JcIiwgcm91dGVJbmZvLmVycm9yLCBjbGVhbmVkQXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHJvdXRlSW5mby5lcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRTdGF0ZS5sb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nID0gbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJyb3V0ZUNoYW5nZUNvbXBsZXRlXCIsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQSBoYXNoIG1hcmsgIyBpcyB0aGUgb3B0aW9uYWwgbGFzdCBwYXJ0IG9mIGEgVVJMXG4gICAgICAgICAgICAgICAgY29uc3QgaGFzaFJlZ2V4ID0gLyMuKyQvO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTY3JvbGwgJiYgaGFzaFJlZ2V4LnRlc3QoYXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKGFzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoKDAsIF9pc2Vycm9yLmRlZmF1bHQpKGVycikgJiYgZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIldhcm5pbmc6IHdpbmRvdy5oaXN0b3J5IGlzIG5vdCBhdmFpbGFibGUuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnlbbWV0aG9kXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeS5cIiArIG1ldGhvZCArIFwiIGlzIG5vdCBhdmFpbGFibGVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgIT09IFwicHVzaFN0YXRlXCIgfHwgKDAsIF91dGlscy5nZXRVUkwpKCkgIT09IGFzKSB7XG4gICAgICAgICAgICB0aGlzLl9zaGFsbG93ID0gb3B0aW9ucy5zaGFsbG93O1xuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnlbbWV0aG9kXSh7XG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgX19OOiB0cnVlLFxuICAgICAgICAgICAgICAgIGtleTogdGhpcy5fa2V5ID0gbWV0aG9kICE9PSBcInB1c2hTdGF0ZVwiID8gdGhpcy5fa2V5IDogY3JlYXRlS2V5KClcbiAgICAgICAgICAgIH0sIC8vIE1vc3QgYnJvd3NlcnMgY3VycmVudGx5IGlnbm9yZXMgdGhpcyBwYXJhbWV0ZXIsIGFsdGhvdWdoIHRoZXkgbWF5IHVzZSBpdCBpbiB0aGUgZnV0dXJlLlxuICAgICAgICAgICAgLy8gUGFzc2luZyB0aGUgZW1wdHkgc3RyaW5nIGhlcmUgc2hvdWxkIGJlIHNhZmUgYWdhaW5zdCBmdXR1cmUgY2hhbmdlcyB0byB0aGUgbWV0aG9kLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hpc3RvcnkvcmVwbGFjZVN0YXRlXG4gICAgICAgICAgICBcIlwiLCBhcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlUm91dGVJbmZvRXJyb3IoZXJyLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzLCBsb2FkRXJyb3JGYWlsKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgaWYgKGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIC8vIGJ1YmJsZSB1cCBjYW5jZWxsYXRpb24gZXJyb3JzXG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBfcm91dGVsb2FkZXIuaXNBc3NldEVycm9yKShlcnIpIHx8IGxvYWRFcnJvckZhaWwpIHtcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcInJvdXRlQ2hhbmdlRXJyb3JcIiwgZXJyLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAvLyBJZiB3ZSBjYW4ndCBsb2FkIHRoZSBwYWdlIGl0IGNvdWxkIGJlIG9uZSBvZiBmb2xsb3dpbmcgcmVhc29uc1xuICAgICAgICAgICAgLy8gIDEuIFBhZ2UgZG9lc24ndCBleGlzdHNcbiAgICAgICAgICAgIC8vICAyLiBQYWdlIGRvZXMgZXhpc3QgaW4gYSBkaWZmZXJlbnQgem9uZVxuICAgICAgICAgICAgLy8gIDMuIEludGVybmFsIGVycm9yIHdoaWxlIGxvYWRpbmcgdGhlIHBhZ2VcbiAgICAgICAgICAgIC8vIFNvLCBkb2luZyBhIGhhcmQgcmVsb2FkIGlzIHRoZSBwcm9wZXIgd2F5IHRvIGRlYWwgd2l0aCB0aGlzLlxuICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIENoYW5naW5nIHRoZSBVUkwgZG9lc24ndCBibG9jayBleGVjdXRpbmcgdGhlIGN1cnJlbnQgY29kZSBwYXRoLlxuICAgICAgICAgICAgLy8gU28gbGV0J3MgdGhyb3cgYSBjYW5jZWxsYXRpb24gZXJyb3Igc3RvcCB0aGUgcm91dGluZyBsb2dpYy5cbiAgICAgICAgICAgIHRocm93IGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHByb3BzO1xuICAgICAgICAgICAgY29uc3QgeyBwYWdlOiBDb21wb25lbnQgLCBzdHlsZVNoZWV0cyAgfSA9IGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoXCIvX2Vycm9yXCIpO1xuICAgICAgICAgICAgY29uc3Qgcm91dGVJbmZvID0ge1xuICAgICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0cyxcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghcm91dGVJbmZvLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzID0gYXdhaXQgdGhpcy5nZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGdpcEVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gZXJyb3IgcGFnZSBgZ2V0SW5pdGlhbFByb3BzYDogXCIsIGdpcEVycik7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByb3V0ZUluZm87XG4gICAgICAgIH0gY2F0Y2ggKHJvdXRlSW5mb0Vycikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoKDAsIF9pc2Vycm9yLmRlZmF1bHQpKHJvdXRlSW5mb0VycikgPyByb3V0ZUluZm9FcnIgOiBuZXcgRXJyb3Iocm91dGVJbmZvRXJyICsgXCJcIiksIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJvdXRlUHJvcHMsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFJvdXRlSW5mbyhwYXJhbSkge1xuICAgICAgICBsZXQgeyByb3V0ZTogcmVxdWVzdGVkUm91dGUgLCBwYXRobmFtZSAsIHF1ZXJ5ICwgYXMgLCByZXNvbHZlZEFzICwgcm91dGVQcm9wcyAsIGxvY2FsZSAsIGhhc01pZGRsZXdhcmUgLCBpc1ByZXZpZXcgLCB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUgLCBpc1F1ZXJ5VXBkYXRpbmcgLCBpc01pZGRsZXdhcmVSZXdyaXRlICwgaXNOb3RGb3VuZCAgfSA9IHBhcmFtO1xuICAgICAgICAvKipcbiAgICAgKiBUaGlzIGByb3V0ZWAgYmluZGluZyBjYW4gY2hhbmdlIGlmIHRoZXJlJ3MgYSByZXdyaXRlXG4gICAgICogc28gd2Uga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgcmVxdWVzdGVkIHJvdXRlXG4gICAgICogc28gd2UgY2FuIHN0b3JlIHRoZSBjYWNoZSBmb3IgaXQgYW5kIGF2b2lkIHJlLXJlcXVlc3RpbmcgZXZlcnkgdGltZVxuICAgICAqIGZvciBzaGFsbG93IHJvdXRpbmcgcHVycG9zZXMuXG4gICAgICovIGxldCByb3V0ZSA9IHJlcXVlc3RlZFJvdXRlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIF9kYXRhX2VmZmVjdCwgX2RhdGFfZWZmZWN0MSwgX2RhdGFfZWZmZWN0MiwgX2RhdGFfcmVzcG9uc2U7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSBnZXRDYW5jZWxsZWRIYW5kbGVyKHtcbiAgICAgICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IGV4aXN0aW5nSW5mbyA9IHRoaXMuY29tcG9uZW50c1tyb3V0ZV07XG4gICAgICAgICAgICBpZiAocm91dGVQcm9wcy5zaGFsbG93ICYmIGV4aXN0aW5nSW5mbyAmJiB0aGlzLnJvdXRlID09PSByb3V0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0luZm87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzTWlkZGxld2FyZSkge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nSW5mbyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjYWNoZWRSb3V0ZUluZm8gPSBleGlzdGluZ0luZm8gJiYgIShcImluaXRpYWxcIiBpbiBleGlzdGluZ0luZm8pICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcImRldmVsb3BtZW50XCIgPyBleGlzdGluZ0luZm8gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBpc0JhY2tncm91bmQgPSBpc1F1ZXJ5VXBkYXRpbmc7XG4gICAgICAgICAgICBjb25zdCBmZXRjaE5leHREYXRhUGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGRhdGFIcmVmOiB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe1xuICAgICAgICAgICAgICAgICAgICBocmVmOiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgc2tpcEludGVycG9sYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFzUGF0aDogaXNOb3RGb3VuZCA/IFwiLzQwNFwiIDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgaGFzTWlkZGxld2FyZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogdGhpcy5pc1NzcixcbiAgICAgICAgICAgICAgICBwYXJzZUpTT046IHRydWUsXG4gICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogaXNCYWNrZ3JvdW5kID8gdGhpcy5zYmMgOiB0aGlzLnNkYyxcbiAgICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6ICFpc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlLFxuICAgICAgICAgICAgICAgIGlzQmFja2dyb3VuZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBkYXRhID0gaXNRdWVyeVVwZGF0aW5nICYmICFpc01pZGRsZXdhcmVSZXdyaXRlID8gbnVsbCA6IGF3YWl0IHdpdGhNaWRkbGV3YXJlRWZmZWN0cyh7XG4gICAgICAgICAgICAgICAgZmV0Y2hEYXRhOiAoKT0+ZmV0Y2hOZXh0RGF0YShmZXRjaE5leHREYXRhUGFyYW1zKSxcbiAgICAgICAgICAgICAgICBhc1BhdGg6IGlzTm90Rm91bmQgPyBcIi80MDRcIiA6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IGhhcmQgZXJyb3IgZHVyaW5nIHF1ZXJ5IHVwZGF0aW5nXG4gICAgICAgICAgICAgICAgLy8gYXMgaXQncyB1bi1uZWNlc3NhcnkgYW5kIGRvZXNuJ3QgbmVlZCB0byBiZSBmYXRhbFxuICAgICAgICAgICAgICAgIC8vIHVubGVzcyBpdCBpcyBhIGZhbGxiYWNrIHJvdXRlIGFuZCB0aGUgcHJvcHMgY2FuJ3RcbiAgICAgICAgICAgICAgICAvLyBiZSBsb2FkZWRcbiAgICAgICAgICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHdoZW4gcmVuZGVyaW5nIGVycm9yIHJvdXRlcyB3ZSBkb24ndCBhcHBseSBtaWRkbGV3YXJlXG4gICAgICAgICAgICAvLyBlZmZlY3RzXG4gICAgICAgICAgICBpZiAoZGF0YSAmJiAocGF0aG5hbWUgPT09IFwiL19lcnJvclwiIHx8IHBhdGhuYW1lID09PSBcIi80MDRcIikpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmVmZmVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb246IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wc1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuanNvbiA9IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgIGlmICgoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKF9kYXRhX2VmZmVjdCA9IGRhdGEuZWZmZWN0KSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGFfZWZmZWN0LnR5cGUpID09PSBcInJlZGlyZWN0LWludGVybmFsXCIgfHwgKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IChfZGF0YV9lZmZlY3QxID0gZGF0YS5lZmZlY3QpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YV9lZmZlY3QxLnR5cGUpID09PSBcInJlZGlyZWN0LWV4dGVybmFsXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5lZmZlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IChfZGF0YV9lZmZlY3QyID0gZGF0YS5lZmZlY3QpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YV9lZmZlY3QyLnR5cGUpID09PSBcInJld3JpdGVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkUm91dGUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkoZGF0YS5lZmZlY3QucmVzb2x2ZWRIcmVmKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlcyA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpO1xuICAgICAgICAgICAgICAgIC8vIGR1cmluZyBxdWVyeSB1cGRhdGluZyB0aGUgcGFnZSBtdXN0IG1hdGNoIGFsdGhvdWdoIGR1cmluZ1xuICAgICAgICAgICAgICAgIC8vIGNsaWVudC10cmFuc2l0aW9uIGEgcmVkaXJlY3QgdGhhdCBkb2Vzbid0IG1hdGNoIGEgcGFnZVxuICAgICAgICAgICAgICAgIC8vIGNhbiBiZSByZXR1cm5lZCBhbmQgdGhpcyBzaG91bGQgdHJpZ2dlciBhIGhhcmQgbmF2aWdhdGlvblxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIGlzIHZhbGlkIGZvciBpbmNyZW1lbnRhbCBtaWdyYXRpb25cbiAgICAgICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZyB8fCBwYWdlcy5pbmNsdWRlcyhyZXNvbHZlZFJvdXRlKSkge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZSA9IHJlc29sdmVkUm91dGU7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gZGF0YS5lZmZlY3QucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZGF0YS5lZmZlY3QucGFyc2VkQXMucXVlcnlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyA9ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKCgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKShkYXRhLmVmZmVjdC5wYXJzZWRBcy5wYXRobmFtZSwgdGhpcy5sb2NhbGVzKS5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGFnYWluIHRoZSBjYWNoZSB3aXRoIHRoZSBuZXcgZGVzdGluYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nSW5mbyA9IHRoaXMuY29tcG9uZW50c1tyb3V0ZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3V0ZVByb3BzLnNoYWxsb3cgJiYgZXhpc3RpbmdJbmZvICYmIHRoaXMucm91dGUgPT09IHJvdXRlICYmICFoYXNNaWRkbGV3YXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgbWF0Y2ggd2l0aCB0aGUgY3VycmVudCByb3V0ZSBkdWUgdG8gcmV3cml0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBjb3B5IHRoZSBleGlzdGluZyBpbmZvcm1hdGlvbiB0byB0aGUgcmV3cml0dGVuIG9uZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZW4sIHdlIHJldHVybiB0aGUgaW5mb3JtYXRpb24gYWxvbmcgd2l0aCB0aGUgbWF0Y2hlZCByb3V0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZXhpc3RpbmdJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCgwLCBfaXNhcGlyb3V0ZS5pc0FQSVJvdXRlKShyb3V0ZSkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgcm91dGVJbmZvID0gY2FjaGVkUm91dGVJbmZvIHx8IGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQocm91dGUpLnRoZW4oKHJlcyk9Pih7XG4gICAgICAgICAgICAgICAgICAgIENvbXBvbmVudDogcmVzLnBhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzOiByZXMuc3R5bGVTaGVldHMsXG4gICAgICAgICAgICAgICAgICAgIF9fTl9TU0c6IHJlcy5tb2QuX19OX1NTRyxcbiAgICAgICAgICAgICAgICAgICAgX19OX1NTUDogcmVzLm1vZC5fX05fU1NQXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlICB9ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdC1pc1wiKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZShyb3V0ZUluZm8uQ29tcG9uZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBkZWZhdWx0IGV4cG9ydCBpcyBub3QgYSBSZWFjdCBDb21wb25lbnQgaW4gcGFnZTogXCInICsgcGF0aG5hbWUgKyAnXCInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB3YXNCYWlsZWRQcmVmZXRjaCA9IGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IChfZGF0YV9yZXNwb25zZSA9IGRhdGEucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YV9yZXNwb25zZS5oZWFkZXJzLmdldChcIngtbWlkZGxld2FyZS1za2lwXCIpO1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkRmV0Y2hEYXRhID0gcm91dGVJbmZvLl9fTl9TU0cgfHwgcm91dGVJbmZvLl9fTl9TU1A7XG4gICAgICAgICAgICAvLyBGb3Igbm9uLVNTRyBwcmVmZXRjaGVzIHRoYXQgYmFpbGVkIGJlZm9yZSBzZW5kaW5nIGRhdGFcbiAgICAgICAgICAgIC8vIHdlIGNsZWFyIHRoZSBjYWNoZSB0byBmZXRjaCBmdWxsIHJlc3BvbnNlXG4gICAgICAgICAgICBpZiAod2FzQmFpbGVkUHJlZmV0Y2ggJiYgKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZGF0YUhyZWYpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2RjW2RhdGEuZGF0YUhyZWZdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBwcm9wcyAsIGNhY2hlS2V5ICB9ID0gYXdhaXQgdGhpcy5fZ2V0RGF0YShhc3luYyAoKT0+e1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRGZXRjaERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmpzb24pICYmICF3YXNCYWlsZWRQcmVmZXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleTogZGF0YS5jYWNoZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogZGF0YS5qc29uXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFIcmVmID0gKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZGF0YUhyZWYpID8gZGF0YS5kYXRhSHJlZiA6IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmV0Y2hlZCA9IGF3YWl0IGZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogdGhpcy5pc1NzcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHdhc0JhaWxlZFByZWZldGNoID8ge30gOiB0aGlzLnNkYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIWlzUHJldmlldyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJlZmV0Y2g6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXk6IGZldGNoZWQuY2FjaGVLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogZmV0Y2hlZC5qc29uIHx8IHt9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBwcm9wczogYXdhaXQgdGhpcy5nZXRJbml0aWFsUHJvcHMocm91dGVJbmZvLkNvbXBvbmVudCwgLy8gd2UgcHJvdmlkZSBBcHBUcmVlIGxhdGVyIHNvIHRoaXMgbmVlZHMgdG8gYmUgYGFueWBcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVzOiB0aGlzLmxvY2FsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TG9jYWxlOiB0aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBPbmx5IGJ1c3QgdGhlIGRhdGEgY2FjaGUgZm9yIFNTUCByb3V0ZXMgYWx0aG91Z2hcbiAgICAgICAgICAgIC8vIG1pZGRsZXdhcmUgY2FuIHNraXAgY2FjaGUgcGVyIHJlcXVlc3Qgd2l0aFxuICAgICAgICAgICAgLy8geC1taWRkbGV3YXJlLWNhY2hlOiBuby1jYWNoZSBhcyB3ZWxsXG4gICAgICAgICAgICBpZiAocm91dGVJbmZvLl9fTl9TU1AgJiYgZmV0Y2hOZXh0RGF0YVBhcmFtcy5kYXRhSHJlZiAmJiBjYWNoZUtleSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNkY1tjYWNoZUtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3ZSBraWNrIG9mZiBhIEhFQUQgcmVxdWVzdCBpbiB0aGUgYmFja2dyb3VuZFxuICAgICAgICAgICAgLy8gd2hlbiBhIG5vbi1wcmVmZXRjaCByZXF1ZXN0IGlzIG1hZGUgdG8gc2lnbmFsIHJldmFsaWRhdGlvblxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzUHJldmlldyAmJiByb3V0ZUluZm8uX19OX1NTRyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJkZXZlbG9wbWVudFwiICYmICFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBmZXRjaE5leHREYXRhKE9iamVjdC5hc3NpZ24oe30sIGZldGNoTmV4dERhdGFQYXJhbXMsIHtcbiAgICAgICAgICAgICAgICAgICAgaXNCYWNrZ3JvdW5kOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiB0aGlzLnNiY1xuICAgICAgICAgICAgICAgIH0pKS5jYXRjaCgoKT0+e30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcHMucGFnZVByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMucGFnZVByb3BzKTtcbiAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHByb3BzO1xuICAgICAgICAgICAgcm91dGVJbmZvLnJvdXRlID0gcm91dGU7XG4gICAgICAgICAgICByb3V0ZUluZm8ucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgICAgIHJvdXRlSW5mby5yZXNvbHZlZEFzID0gcmVzb2x2ZWRBcztcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1tyb3V0ZV0gPSByb3V0ZUluZm87XG4gICAgICAgICAgICByZXR1cm4gcm91dGVJbmZvO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKCgwLCBfaXNlcnJvci5nZXRQcm9wZXJFcnJvcikoZXJyKSwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0KHN0YXRlLCBkYXRhLCByZXNldFNjcm9sbCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YihkYXRhLCB0aGlzLmNvbXBvbmVudHNbXCIvX2FwcFwiXS5Db21wb25lbnQsIHJlc2V0U2Nyb2xsKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIENhbGxiYWNrIHRvIGV4ZWN1dGUgYmVmb3JlIHJlcGxhY2luZyByb3V0ZXIgc3RhdGVcbiAgICogQHBhcmFtIGNiIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkXG4gICAqLyBiZWZvcmVQb3BTdGF0ZShjYikge1xuICAgICAgICB0aGlzLl9icHMgPSBjYjtcbiAgICB9XG4gICAgb25seUFIYXNoQ2hhbmdlKGFzKSB7XG4gICAgICAgIGlmICghdGhpcy5hc1BhdGgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgW29sZFVybE5vSGFzaCwgb2xkSGFzaF0gPSB0aGlzLmFzUGF0aC5zcGxpdChcIiNcIik7XG4gICAgICAgIGNvbnN0IFtuZXdVcmxOb0hhc2gsIG5ld0hhc2hdID0gYXMuc3BsaXQoXCIjXCIpO1xuICAgICAgICAvLyBNYWtlcyBzdXJlIHdlIHNjcm9sbCB0byB0aGUgcHJvdmlkZWQgaGFzaCBpZiB0aGUgdXJsL2hhc2ggYXJlIHRoZSBzYW1lXG4gICAgICAgIGlmIChuZXdIYXNoICYmIG9sZFVybE5vSGFzaCA9PT0gbmV3VXJsTm9IYXNoICYmIG9sZEhhc2ggPT09IG5ld0hhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSB1cmxzIGFyZSBjaGFuZ2UsIHRoZXJlJ3MgbW9yZSB0aGFuIGEgaGFzaCBjaGFuZ2VcbiAgICAgICAgaWYgKG9sZFVybE5vSGFzaCAhPT0gbmV3VXJsTm9IYXNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGhhc2ggaGFzIGNoYW5nZWQsIHRoZW4gaXQncyBhIGhhc2ggb25seSBjaGFuZ2UuXG4gICAgICAgIC8vIFRoaXMgY2hlY2sgaXMgbmVjZXNzYXJ5IHRvIGhhbmRsZSBib3RoIHRoZSBlbnRlciBhbmRcbiAgICAgICAgLy8gbGVhdmUgaGFzaCA9PT0gJycgY2FzZXMuIFRoZSBpZGVudGl0eSBjYXNlIGZhbGxzIHRocm91Z2hcbiAgICAgICAgLy8gYW5kIGlzIHRyZWF0ZWQgYXMgYSBuZXh0IHJlbG9hZC5cbiAgICAgICAgcmV0dXJuIG9sZEhhc2ggIT09IG5ld0hhc2g7XG4gICAgfVxuICAgIHNjcm9sbFRvSGFzaChhcykge1xuICAgICAgICBjb25zdCBbLCBoYXNoID0gXCJcIl0gPSBhcy5zcGxpdChcIiNcIik7XG4gICAgICAgICgwLCBfaGFuZGxlc21vb3Roc2Nyb2xsLmhhbmRsZVNtb290aFNjcm9sbCkoKCk9PntcbiAgICAgICAgICAgIC8vIFNjcm9sbCB0byB0b3AgaWYgdGhlIGhhc2ggaXMganVzdCBgI2Agd2l0aCBubyB2YWx1ZSBvciBgI3RvcGBcbiAgICAgICAgICAgIC8vIFRvIG1pcnJvciBicm93c2Vyc1xuICAgICAgICAgICAgaWYgKGhhc2ggPT09IFwiXCIgfHwgaGFzaCA9PT0gXCJ0b3BcIikge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZWNvZGUgaGFzaCB0byBtYWtlIG5vbi1sYXRpbiBhbmNob3Igd29ya3MuXG4gICAgICAgICAgICBjb25zdCByYXdIYXNoID0gZGVjb2RlVVJJQ29tcG9uZW50KGhhc2gpO1xuICAgICAgICAgICAgLy8gRmlyc3Qgd2UgY2hlY2sgaWYgdGhlIGVsZW1lbnQgYnkgaWQgaXMgZm91bmRcbiAgICAgICAgICAgIGNvbnN0IGlkRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChyYXdIYXNoKTtcbiAgICAgICAgICAgIGlmIChpZEVsKSB7XG4gICAgICAgICAgICAgICAgaWRFbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gZWxlbWVudCB3aXRoIHRoZSBpZCwgd2UgY2hlY2sgdGhlIGBuYW1lYCBwcm9wZXJ0eVxuICAgICAgICAgICAgLy8gVG8gbWlycm9yIGJyb3dzZXJzXG4gICAgICAgICAgICBjb25zdCBuYW1lRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShyYXdIYXNoKVswXTtcbiAgICAgICAgICAgIGlmIChuYW1lRWwpIHtcbiAgICAgICAgICAgICAgICBuYW1lRWwuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgb25seUhhc2hDaGFuZ2U6IHRoaXMub25seUFIYXNoQ2hhbmdlKGFzKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXJsSXNOZXcoYXNQYXRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzUGF0aCAhPT0gYXNQYXRoO1xuICAgIH1cbiAgICAvKipcbiAgICogUHJlZmV0Y2ggcGFnZSBjb2RlLCB5b3UgbWF5IHdhaXQgZm9yIHRoZSBkYXRhIGR1cmluZyBwYWdlIHJlbmRlcmluZy5cbiAgICogVGhpcyBmZWF0dXJlIG9ubHkgd29ya3MgaW4gcHJvZHVjdGlvbiFcbiAgICogQHBhcmFtIHVybCB0aGUgaHJlZiBvZiBwcmVmZXRjaGVkIHBhZ2VcbiAgICogQHBhcmFtIGFzUGF0aCB0aGUgYXMgcGF0aCBvZiB0aGUgcHJlZmV0Y2hlZCBwYWdlXG4gICAqLyBhc3luYyBwcmVmZXRjaCh1cmwsIGFzUGF0aCwgb3B0aW9ucykge1xuICAgICAgICBpZiAoYXNQYXRoID09PSB2b2lkIDApIGFzUGF0aCA9IHVybDtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgICAgICAvLyBQcmVmZXRjaCBpcyBub3Qgc3VwcG9ydGVkIGluIGRldmVsb3BtZW50IG1vZGUgYmVjYXVzZSBpdCB3b3VsZCB0cmlnZ2VyIG9uLWRlbWFuZC1lbnRyaWVzXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoMCwgX2lzYm90LmlzQm90KSh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgICAgICAgIC8vIE5vIHByZWZldGNoZXMgZm9yIGJvdHMgdGhhdCByZW5kZXIgdGhlIGxpbmsgc2luY2UgdGhleSBhcmUgdHlwaWNhbGx5IG5hdmlnYXRpbmdcbiAgICAgICAgICAgIC8vIGxpbmtzIHZpYSB0aGUgZXF1aXZhbGVudCBvZiBhIGhhcmQgbmF2aWdhdGlvbiBhbmQgaGVuY2UgbmV2ZXIgdXRpbGl6ZSB0aGVzZVxuICAgICAgICAgICAgLy8gcHJlZmV0Y2hlcy5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyc2VkID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKHVybCk7XG4gICAgICAgIGNvbnN0IHVybFBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lO1xuICAgICAgICBsZXQgeyBwYXRobmFtZSAsIHF1ZXJ5ICB9ID0gcGFyc2VkO1xuICAgICAgICBjb25zdCBvcmlnaW5hbFBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSAoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkocGF0aG5hbWUsIHRoaXMubG9jYWxlcykucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnNlZEFzID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKGFzUGF0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9ICgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKShwYXJzZWRBcy5wYXRobmFtZSwgdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9IGxvY2FsZVBhdGhSZXN1bHQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlIHx8IHRoaXMuZGVmYXVsdExvY2FsZTtcbiAgICAgICAgICAgICAgICBhc1BhdGggPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkQXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhZ2VzID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCk7XG4gICAgICAgIGxldCByZXNvbHZlZEFzID0gYXNQYXRoO1xuICAgICAgICBjb25zdCBsb2NhbGUgPSB0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgIT09IFwidW5kZWZpbmVkXCIgPyBvcHRpb25zLmxvY2FsZSB8fCB1bmRlZmluZWQgOiB0aGlzLmxvY2FsZTtcbiAgICAgICAgY29uc3QgaXNNaWRkbGV3YXJlTWF0Y2ggPSBhd2FpdCBtYXRjaGVzTWlkZGxld2FyZSh7XG4gICAgICAgICAgICBhc1BhdGg6IGFzUGF0aCxcbiAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyAmJiBhc1BhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgICAgIGxldCByZXdyaXRlcztcbiAgICAgICAgICAgICh7IF9fcmV3cml0ZXM6IHJld3JpdGVzICB9ID0gYXdhaXQgKDAsIF9yb3V0ZWxvYWRlci5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KSgpKTtcbiAgICAgICAgICAgIGNvbnN0IHJld3JpdGVzUmVzdWx0ID0gKDAsIF9yZXNvbHZlcmV3cml0ZXMuZGVmYXVsdCkoKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShhc1BhdGgsIHRoaXMubG9jYWxlKSwgdHJ1ZSksIHBhZ2VzLCByZXdyaXRlcywgcGFyc2VkLnF1ZXJ5LCAocCk9PnJlc29sdmVEeW5hbWljUm91dGUocCwgcGFnZXMpLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0LmV4dGVybmFsRGVzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZEFzID0gKDAsIF9yZW1vdmVsb2NhbGUucmVtb3ZlTG9jYWxlKSgoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShyZXdyaXRlc1Jlc3VsdC5hc1BhdGgpLCB0aGlzLmxvY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmV3cml0ZXNSZXN1bHQubWF0Y2hlZFBhZ2UgJiYgcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBkaXJlY3RseSBtYXRjaGVzIGEgcGFnZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaHJlZiB0b1xuICAgICAgICAgICAgICAgIC8vIGFsbG93IHRoZSBjb3JyZWN0IHBhZ2UgY2h1bmsgdG8gYmUgbG9hZGVkXG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXJzZWQucGF0aG5hbWUsIHBhZ2VzKTtcbiAgICAgICAgaWYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShwYXJzZWQucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZTtcbiAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKSgoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocGFyc2VkLnBhdGhuYW1lKSkoKDAsIF9wYXJzZXBhdGgucGFyc2VQYXRoKShhc1BhdGgpLnBhdGhuYW1lKSB8fCB7fSk7XG4gICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHByb2Nlc3MuZW52Ll9fTkVYVF9NSURETEVXQVJFX1BSRUZFVENIID09PSBcInN0cmljdFwiID8gbnVsbCA6IGF3YWl0IHdpdGhNaWRkbGV3YXJlRWZmZWN0cyh7XG4gICAgICAgICAgICBmZXRjaERhdGE6ICgpPT5mZXRjaE5leHREYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWY6IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBvcmlnaW5hbFBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBJbnRlcnBvbGF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBoYXNNaWRkbGV3YXJlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogdGhpcy5pc1NzcixcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VKU09OOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiB0aGlzLnNkYyxcbiAgICAgICAgICAgICAgICAgICAgcGVyc2lzdENhY2hlOiAhdGhpcy5pc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgICAgIGlzUHJlZmV0Y2g6IHRydWVcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGFzUGF0aDogYXNQYXRoLFxuICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAqIElmIHRoZXJlIHdhcyBhIHJld3JpdGUgd2UgYXBwbHkgdGhlIGVmZmVjdHMgb2YgdGhlIHJld3JpdGUgb24gdGhlXG4gICAgICogY3VycmVudCBwYXJhbWV0ZXJzIGZvciB0aGUgcHJlZmV0Y2guXG4gICAgICovIGlmICgoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5lZmZlY3QudHlwZSkgPT09IFwicmV3cml0ZVwiKSB7XG4gICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICBwYXRobmFtZSA9IGRhdGEuZWZmZWN0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgIHF1ZXJ5ID0ge1xuICAgICAgICAgICAgICAgIC4uLnF1ZXJ5LFxuICAgICAgICAgICAgICAgIC4uLmRhdGEuZWZmZWN0LnBhcnNlZEFzLnF1ZXJ5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzb2x2ZWRBcyA9IGRhdGEuZWZmZWN0LnBhcnNlZEFzLnBhdGhuYW1lO1xuICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICogSWYgdGhlcmUgaXMgYSByZWRpcmVjdCB0byBhbiBleHRlcm5hbCBkZXN0aW5hdGlvbiB0aGVuIHdlIGRvbid0IGhhdmVcbiAgICAgKiB0byBwcmVmZXRjaCBjb250ZW50IGFzIGl0IHdpbGwgYmUgdW51c2VkLlxuICAgICAqLyBpZiAoKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZWZmZWN0LnR5cGUpID09PSBcInJlZGlyZWN0LWV4dGVybmFsXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb3V0ZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShwYXRobmFtZSk7XG4gICAgICAgIGlmIChhd2FpdCB0aGlzLl9iZmwoYXNQYXRoLCByZXNvbHZlZEFzLCBvcHRpb25zLmxvY2FsZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1t1cmxQYXRobmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgX19hcHBSb3V0ZXI6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGhpcy5wYWdlTG9hZGVyLl9pc1NzZyhyb3V0ZSkudGhlbigoaXNTc2cpPT57XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzU3NnID8gZmV0Y2hOZXh0RGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmOiAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5qc29uKSA/IGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZGF0YUhyZWYgOiB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VKU09OOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiB0aGlzLnNkYyxcbiAgICAgICAgICAgICAgICAgICAgcGVyc2lzdENhY2hlOiAhdGhpcy5pc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgICAgIGlzUHJlZmV0Y2g6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZTogb3B0aW9ucy51bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUgfHwgb3B0aW9ucy5wcmlvcml0eSAmJiAhIXByb2Nlc3MuZW52Ll9fTkVYVF9PUFRJTUlTVElDX0NMSUVOVF9DQUNIRVxuICAgICAgICAgICAgICAgIH0pLnRoZW4oKCk9PmZhbHNlKS5jYXRjaCgoKT0+ZmFsc2UpIDogZmFsc2U7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlcltvcHRpb25zLnByaW9yaXR5ID8gXCJsb2FkUGFnZVwiIDogXCJwcmVmZXRjaFwiXShyb3V0ZSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoQ29tcG9uZW50KHJvdXRlKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZUNhbmNlbGxlZCA9IGdldENhbmNlbGxlZEhhbmRsZXIoe1xuICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRSZXN1bHQgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIubG9hZFBhZ2Uocm91dGUpO1xuICAgICAgICAgICAgaGFuZGxlQ2FuY2VsbGVkKCk7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50UmVzdWx0O1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGhhbmRsZUNhbmNlbGxlZCgpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9nZXREYXRhKGZuKSB7XG4gICAgICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY2FuY2VsID0gKCk9PntcbiAgICAgICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xjID0gY2FuY2VsO1xuICAgICAgICByZXR1cm4gZm4oKS50aGVuKChkYXRhKT0+e1xuICAgICAgICAgICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsYyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFwiTG9hZGluZyBpbml0aWFsIHByb3BzIGNhbmNlbGxlZFwiKTtcbiAgICAgICAgICAgICAgICBlcnIuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRGbGlnaHREYXRhKGRhdGFIcmVmKSB7XG4gICAgICAgIC8vIERvIG5vdCBjYWNoZSBSU0MgZmxpZ2h0IHJlc3BvbnNlIHNpbmNlIGl0J3Mgbm90IGEgc3RhdGljIHJlc291cmNlXG4gICAgICAgIHJldHVybiBmZXRjaE5leHREYXRhKHtcbiAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IHRydWUsXG4gICAgICAgICAgICBwYXJzZUpTT046IGZhbHNlLFxuICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogdGhpcy5zZGMsXG4gICAgICAgICAgICBwZXJzaXN0Q2FjaGU6IGZhbHNlLFxuICAgICAgICAgICAgaXNQcmVmZXRjaDogZmFsc2VcbiAgICAgICAgfSkudGhlbigocGFyYW0pPT57XG4gICAgICAgICAgICBsZXQgeyB0ZXh0ICB9ID0gcGFyYW07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IHRleHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCBjdHgpIHtcbiAgICAgICAgY29uc3QgeyBDb21wb25lbnQ6IEFwcCAgfSA9IHRoaXMuY29tcG9uZW50c1tcIi9fYXBwXCJdO1xuICAgICAgICBjb25zdCBBcHBUcmVlID0gdGhpcy5fd3JhcEFwcChBcHApO1xuICAgICAgICBjdHguQXBwVHJlZSA9IEFwcFRyZWU7XG4gICAgICAgIHJldHVybiAoMCwgX3V0aWxzLmxvYWRHZXRJbml0aWFsUHJvcHMpKEFwcCwge1xuICAgICAgICAgICAgQXBwVHJlZSxcbiAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgICAgICAgIGN0eFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IHJvdXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5yb3V0ZTtcbiAgICB9XG4gICAgZ2V0IHBhdGhuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgZ2V0IHF1ZXJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5xdWVyeTtcbiAgICB9XG4gICAgZ2V0IGFzUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuYXNQYXRoO1xuICAgIH1cbiAgICBnZXQgbG9jYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5sb2NhbGU7XG4gICAgfVxuICAgIGdldCBpc0ZhbGxiYWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5pc0ZhbGxiYWNrO1xuICAgIH1cbiAgICBnZXQgaXNQcmV2aWV3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5pc1ByZXZpZXc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHBhdGhuYW1lLCBxdWVyeSwgYXMsIHsgaW5pdGlhbFByb3BzICwgcGFnZUxvYWRlciAsIEFwcCAsIHdyYXBBcHAgLCBDb21wb25lbnQgLCBlcnIgLCBzdWJzY3JpcHRpb24gLCBpc0ZhbGxiYWNrICwgbG9jYWxlICwgbG9jYWxlcyAsIGRlZmF1bHRMb2NhbGUgLCBkb21haW5Mb2NhbGVzICwgaXNQcmV2aWV3ICB9KXtcbiAgICAgICAgLy8gU2VydmVyIERhdGEgQ2FjaGUgKGZ1bGwgZGF0YSByZXF1ZXN0cylcbiAgICAgICAgdGhpcy5zZGMgPSB7fTtcbiAgICAgICAgLy8gU2VydmVyIEJhY2tncm91bmQgQ2FjaGUgKEhFQUQgcmVxdWVzdHMpXG4gICAgICAgIHRoaXMuc2JjID0ge307XG4gICAgICAgIHRoaXMuaXNGaXJzdFBvcFN0YXRlRXZlbnQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9rZXkgPSBjcmVhdGVLZXkoKTtcbiAgICAgICAgdGhpcy5vblBvcFN0YXRlID0gKGUpPT57XG4gICAgICAgICAgICBjb25zdCB7IGlzRmlyc3RQb3BTdGF0ZUV2ZW50ICB9ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuaXNGaXJzdFBvcFN0YXRlRXZlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gZS5zdGF0ZTtcbiAgICAgICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBnZXQgc3RhdGUgYXMgdW5kZWZpbmVkIGZvciB0d28gcmVhc29ucy5cbiAgICAgICAgICAgICAgICAvLyAgMS4gV2l0aCBvbGRlciBzYWZhcmkgKDwgOCkgYW5kIG9sZGVyIGNocm9tZSAoPCAzNClcbiAgICAgICAgICAgICAgICAvLyAgMi4gV2hlbiB0aGUgVVJMIGNoYW5nZWQgd2l0aCAjXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBJbiB0aGUgYm90aCBjYXNlcywgd2UgZG9uJ3QgbmVlZCB0byBwcm9jZWVkIGFuZCBjaGFuZ2UgdGhlIHJvdXRlLlxuICAgICAgICAgICAgICAgIC8vIChhcyBpdCdzIGFscmVhZHkgY2hhbmdlZClcbiAgICAgICAgICAgICAgICAvLyBCdXQgd2UgY2FuIHNpbXBseSByZXBsYWNlIHRoZSBzdGF0ZSB3aXRoIHRoZSBuZXcgY2hhbmdlcy5cbiAgICAgICAgICAgICAgICAvLyBBY3R1YWxseSwgZm9yICgxKSB3ZSBkb24ndCBuZWVkIHRvIG5vdGhpbmcuIEJ1dCBpdCdzIGhhcmQgdG8gZGV0ZWN0IHRoYXQgZXZlbnQuXG4gICAgICAgICAgICAgICAgLy8gU28sIGRvaW5nIHRoZSBmb2xsb3dpbmcgZm9yICgxKSBkb2VzIG5vIGhhcm0uXG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYXRobmFtZSAsIHF1ZXJ5ICB9ID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFwicmVwbGFjZVN0YXRlXCIsICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKSh7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwYXRobmFtZSksXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgfSksICgwLCBfdXRpbHMuZ2V0VVJMKSgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBfX05BIGlzIHVzZWQgdG8gaWRlbnRpZnkgaWYgdGhlIGhpc3RvcnkgZW50cnkgY2FuIGJlIGhhbmRsZWQgYnkgdGhlIGFwcC1yb3V0ZXIuXG4gICAgICAgICAgICBpZiAoc3RhdGUuX19OQSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0YXRlLl9fTikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNhZmFyaSBmaXJlcyBwb3BzdGF0ZWV2ZW50IHdoZW4gcmVvcGVuaW5nIHRoZSBicm93c2VyLlxuICAgICAgICAgICAgaWYgKGlzRmlyc3RQb3BTdGF0ZUV2ZW50ICYmIHRoaXMubG9jYWxlID09PSBzdGF0ZS5vcHRpb25zLmxvY2FsZSAmJiBzdGF0ZS5hcyA9PT0gdGhpcy5hc1BhdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZm9yY2VkU2Nyb2xsO1xuICAgICAgICAgICAgY29uc3QgeyB1cmwgLCBhcyAsIG9wdGlvbnMgLCBrZXkgIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9rZXkgIT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU25hcHNob3QgY3VycmVudCBzY3JvbGwgcG9zaXRpb246XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXCJfX25leHRfc2Nyb2xsX1wiICsgdGhpcy5fa2V5LCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHNlbGYucGFnZVhPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHNlbGYucGFnZVlPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBvbGQgc2Nyb2xsIHBvc2l0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShcIl9fbmV4dF9zY3JvbGxfXCIgKyBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlZFNjcm9sbCA9IEpTT04ucGFyc2Uodik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VkU2Nyb2xsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2tleSA9IGtleTtcbiAgICAgICAgICAgIGNvbnN0IHsgcGF0aG5hbWUgIH0gPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkodXJsKTtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCByZS1yZW5kZXIgb24gaW5pdGlhbCBsb2FkLFxuICAgICAgICAgICAgLy8gY2FuIGJlIGNhdXNlZCBieSBuYXZpZ2F0aW5nIGJhY2sgZnJvbSBhbiBleHRlcm5hbCBzaXRlXG4gICAgICAgICAgICBpZiAodGhpcy5pc1NzciAmJiBhcyA9PT0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkodGhpcy5hc1BhdGgpICYmIHBhdGhuYW1lID09PSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSh0aGlzLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBkb3duc3RyZWFtIGFwcGxpY2F0aW9uIHJldHVybnMgZmFsc3ksIHJldHVybi5cbiAgICAgICAgICAgIC8vIFRoZXkgd2lsbCB0aGVuIGJlIHJlc3BvbnNpYmxlIGZvciBoYW5kbGluZyB0aGUgZXZlbnQuXG4gICAgICAgICAgICBpZiAodGhpcy5fYnBzICYmICF0aGlzLl9icHMoc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jaGFuZ2UoXCJyZXBsYWNlU3RhdGVcIiwgdXJsLCBhcywgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICAgIHNoYWxsb3c6IG9wdGlvbnMuc2hhbGxvdyAmJiB0aGlzLl9zaGFsbG93LFxuICAgICAgICAgICAgICAgIGxvY2FsZTogb3B0aW9ucy5sb2NhbGUgfHwgdGhpcy5kZWZhdWx0TG9jYWxlLFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgaW50ZXJuYWwgdmFsdWUgbm90IGV4cG9zZWQgb24gdHlwZXNcbiAgICAgICAgICAgICAgICBfaDogMFxuICAgICAgICAgICAgfSksIGZvcmNlZFNjcm9sbCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgY29tcG9uZW50IGtleVxuICAgICAgICBjb25zdCByb3V0ZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShwYXRobmFtZSk7XG4gICAgICAgIC8vIHNldCB1cCB0aGUgY29tcG9uZW50IGNhY2hlIChieSByb3V0ZSBrZXlzKVxuICAgICAgICB0aGlzLmNvbXBvbmVudHMgPSB7fTtcbiAgICAgICAgLy8gV2Ugc2hvdWxkIG5vdCBrZWVwIHRoZSBjYWNoZSwgaWYgdGhlcmUncyBhbiBlcnJvclxuICAgICAgICAvLyBPdGhlcndpc2UsIHRoaXMgY2F1c2UgaXNzdWVzIHdoZW4gd2hlbiBnb2luZyBiYWNrIGFuZFxuICAgICAgICAvLyBjb21lIGFnYWluIHRvIHRoZSBlcnJvcmVkIHBhZ2UuXG4gICAgICAgIGlmIChwYXRobmFtZSAhPT0gXCIvX2Vycm9yXCIpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1tyb3V0ZV0gPSB7XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgcHJvcHM6IGluaXRpYWxQcm9wcyxcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgX19OX1NTRzogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NHLFxuICAgICAgICAgICAgICAgIF9fTl9TU1A6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTUFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBvbmVudHNbXCIvX2FwcFwiXSA9IHtcbiAgICAgICAgICAgIENvbXBvbmVudDogQXBwLFxuICAgICAgICAgICAgc3R5bGVTaGVldHM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1JPVVRFUl9GSUxURVJfRU5BQkxFRCkge1xuICAgICAgICAgICAgY29uc3QgeyBCbG9vbUZpbHRlciAgfSA9IHJlcXVpcmUoXCIuLi8uLi9saWIvYmxvb20tZmlsdGVyXCIpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGljRmlsdGVyRGF0YSA9IHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX1NfRklMVEVSO1xuICAgICAgICAgICAgY29uc3QgZHluYW1pY0ZpbHRlckRhdGEgPSBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1JPVVRFUl9EX0ZJTFRFUjtcbiAgICAgICAgICAgIGlmIChzdGF0aWNGaWx0ZXJEYXRhID09IG51bGwgPyB2b2lkIDAgOiBzdGF0aWNGaWx0ZXJEYXRhLm51bUhhc2hlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JmbF9zID0gbmV3IEJsb29tRmlsdGVyKHN0YXRpY0ZpbHRlckRhdGEubnVtSXRlbXMsIHN0YXRpY0ZpbHRlckRhdGEuZXJyb3JSYXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZmxfcy5pbXBvcnQoc3RhdGljRmlsdGVyRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHluYW1pY0ZpbHRlckRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGR5bmFtaWNGaWx0ZXJEYXRhLm51bUhhc2hlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JmbF9kID0gbmV3IEJsb29tRmlsdGVyKGR5bmFtaWNGaWx0ZXJEYXRhLm51bUl0ZW1zLCBkeW5hbWljRmlsdGVyRGF0YS5lcnJvclJhdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2JmbF9kLmltcG9ydChkeW5hbWljRmlsdGVyRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdCBmb3IgUm91dGVyLnJvdXRlci5ldmVudHNcbiAgICAgICAgLy8gVE9ETzogU2hvdWxkIGJlIHJlbW92ZSB0aGUgZm9sbG93aW5nIG1ham9yIHZlcnNpb24gYXMgaXQgd2FzIG5ldmVyIGRvY3VtZW50ZWRcbiAgICAgICAgdGhpcy5ldmVudHMgPSBSb3V0ZXIuZXZlbnRzO1xuICAgICAgICB0aGlzLnBhZ2VMb2FkZXIgPSBwYWdlTG9hZGVyO1xuICAgICAgICAvLyBpZiBhdXRvIHByZXJlbmRlcmVkIGFuZCBkeW5hbWljIHJvdXRlIHdhaXQgdG8gdXBkYXRlIGFzUGF0aFxuICAgICAgICAvLyB1bnRpbCBhZnRlciBtb3VudCB0byBwcmV2ZW50IGh5ZHJhdGlvbiBtaXNtYXRjaFxuICAgICAgICBjb25zdCBhdXRvRXhwb3J0RHluYW1pYyA9ICgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShwYXRobmFtZSkgJiYgc2VsZi5fX05FWFRfREFUQV9fLmF1dG9FeHBvcnQ7XG4gICAgICAgIHRoaXMuYmFzZVBhdGggPSBwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8IFwiXCI7XG4gICAgICAgIHRoaXMuc3ViID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICB0aGlzLmNsYyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3dyYXBBcHAgPSB3cmFwQXBwO1xuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gaWdub3JlIGV4dHJhIHBvcFN0YXRlIGluIHNhZmFyaSBvbiBuYXZpZ2F0aW5nXG4gICAgICAgIC8vIGJhY2sgZnJvbSBleHRlcm5hbCBzaXRlXG4gICAgICAgIHRoaXMuaXNTc3IgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzTG9jYWxlRG9tYWluID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNSZWFkeSA9ICEhKHNlbGYuX19ORVhUX0RBVEFfXy5nc3NwIHx8IHNlbGYuX19ORVhUX0RBVEFfXy5naXAgfHwgc2VsZi5fX05FWFRfREFUQV9fLmFwcEdpcCAmJiAhc2VsZi5fX05FWFRfREFUQV9fLmdzcCB8fCAhYXV0b0V4cG9ydER5bmFtaWMgJiYgIXNlbGYubG9jYXRpb24uc2VhcmNoICYmICFwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxlcyA9IGxvY2FsZXM7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRMb2NhbGUgPSBkZWZhdWx0TG9jYWxlO1xuICAgICAgICAgICAgdGhpcy5kb21haW5Mb2NhbGVzID0gZG9tYWluTG9jYWxlcztcbiAgICAgICAgICAgIHRoaXMuaXNMb2NhbGVEb21haW4gPSAhISgwLCBfZGV0ZWN0ZG9tYWlubG9jYWxlLmRldGVjdERvbWFpbkxvY2FsZSkoZG9tYWluTG9jYWxlcywgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgIGFzUGF0aDogYXV0b0V4cG9ydER5bmFtaWMgPyBwYXRobmFtZSA6IGFzLFxuICAgICAgICAgICAgaXNQcmV2aWV3OiAhIWlzUHJldmlldyxcbiAgICAgICAgICAgIGxvY2FsZTogcHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCA/IGxvY2FsZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGlzRmFsbGJhY2tcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5faW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgXCJhc1wiIGRvZXNuJ3Qgc3RhcnQgd2l0aCBkb3VibGUgc2xhc2hlcyBvciBlbHNlIGl0IGNhblxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXJyb3IgYXMgaXQncyBjb25zaWRlcmVkIGludmFsaWRcbiAgICAgICAgICAgIGlmICghYXMuc3RhcnRzV2l0aChcIi8vXCIpKSB7XG4gICAgICAgICAgICAgICAgLy8gaW4gb3JkZXIgZm9yIGBlLnN0YXRlYCB0byB3b3JrIG9uIHRoZSBgb25wb3BzdGF0ZWAgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIHJlZ2lzdGVyIHRoZSBpbml0aWFsIHJvdXRlIHVwb24gaW5pdGlhbGl6YXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGFzUGF0aCA9ICgwLCBfdXRpbHMuZ2V0VVJMKSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2UgPSBtYXRjaGVzTWlkZGxld2FyZSh7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICBhc1BhdGhcbiAgICAgICAgICAgICAgICB9KS50aGVuKChtYXRjaGVzKT0+e1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLl9zaG91bGRSZXNvbHZlSHJlZiA9IGFzICE9PSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcInJlcGxhY2VTdGF0ZVwiLCBtYXRjaGVzID8gYXNQYXRoIDogKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwYXRobmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgICAgICB9KSwgYXNQYXRoLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIHRoaXMub25Qb3BTdGF0ZSk7XG4gICAgICAgICAgICAvLyBlbmFibGUgY3VzdG9tIHNjcm9sbCByZXN0b3JhdGlvbiBoYW5kbGluZyB3aGVuIGF2YWlsYWJsZVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGZhbGxiYWNrIHRvIGJyb3dzZXIncyBkZWZhdWx0IGhhbmRsaW5nXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICAgICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwibWFudWFsXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuKCgpPT57XG4gICAgUm91dGVyLmV2ZW50cyA9ICgwLCBfbWl0dC5kZWZhdWx0KSgpO1xufSkoKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsImRlZmF1bHQiLCJtYXRjaGVzTWlkZGxld2FyZSIsImNyZWF0ZUtleSIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIlJvdXRlciIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwiX3JlbW92ZXRyYWlsaW5nc2xhc2giLCJfcm91dGVsb2FkZXIiLCJfc2NyaXB0IiwiX2lzZXJyb3IiLCJfIiwiX2Rlbm9ybWFsaXplcGFnZXBhdGgiLCJfbm9ybWFsaXplbG9jYWxlcGF0aCIsIl9taXR0IiwiX3V0aWxzIiwiX2lzZHluYW1pYyIsIl9wYXJzZXJlbGF0aXZldXJsIiwiX3Jlc29sdmVyZXdyaXRlcyIsIl9yb3V0ZW1hdGNoZXIiLCJfcm91dGVyZWdleCIsIl9mb3JtYXR1cmwiLCJfZGV0ZWN0ZG9tYWlubG9jYWxlIiwiX3BhcnNlcGF0aCIsIl9hZGRsb2NhbGUiLCJfcmVtb3ZlbG9jYWxlIiwiX3JlbW92ZWJhc2VwYXRoIiwiX2FkZGJhc2VwYXRoIiwiX2hhc2Jhc2VwYXRoIiwiX2lzYXBpcm91dGUiLCJfZ2V0bmV4dHBhdGhuYW1laW5mbyIsIl9mb3JtYXRuZXh0cGF0aG5hbWVpbmZvIiwiX2NvbXBhcmVzdGF0ZXMiLCJfaXNsb2NhbHVybCIsIl9pc2JvdCIsIl9vbWl0IiwiX3Jlc29sdmVocmVmIiwiX2ludGVycG9sYXRlYXMiLCJfaGFuZGxlc21vb3Roc2Nyb2xsIiwiYnVpbGRDYW5jZWxsYXRpb25FcnJvciIsImFzc2lnbiIsIkVycm9yIiwiY2FuY2VsbGVkIiwib3B0aW9ucyIsIm1hdGNoZXJzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyb3V0ZXIiLCJwYWdlTG9hZGVyIiwiZ2V0TWlkZGxld2FyZSIsInBhdGhuYW1lIiwiYXNQYXRobmFtZSIsInBhcnNlUGF0aCIsImFzUGF0aCIsImNsZWFuZWRBcyIsImhhc0Jhc2VQYXRoIiwicmVtb3ZlQmFzZVBhdGgiLCJhc1dpdGhCYXNlUGF0aEFuZExvY2FsZSIsImFkZEJhc2VQYXRoIiwiYWRkTG9jYWxlIiwibG9jYWxlIiwic29tZSIsIm0iLCJSZWdFeHAiLCJyZWdleHAiLCJ0ZXN0Iiwic3RyaXBPcmlnaW4iLCJ1cmwiLCJvcmlnaW4iLCJnZXRMb2NhdGlvbk9yaWdpbiIsInN0YXJ0c1dpdGgiLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJwcmVwYXJlVXJsQXMiLCJhcyIsInJlc29sdmVkSHJlZiIsInJlc29sdmVkQXMiLCJyZXNvbHZlSHJlZiIsImhyZWZXYXNBYnNvbHV0ZSIsImFzV2FzQWJzb2x1dGUiLCJwcmVwYXJlZFVybCIsInByZXBhcmVkQXMiLCJyZXNvbHZlRHluYW1pY1JvdXRlIiwicGFnZXMiLCJjbGVhblBhdGhuYW1lIiwicmVtb3ZlVHJhaWxpbmdTbGFzaCIsImRlbm9ybWFsaXplUGFnZVBhdGgiLCJpbmNsdWRlcyIsInBhZ2UiLCJpc0R5bmFtaWNSb3V0ZSIsImdldFJvdXRlUmVnZXgiLCJyZSIsImdldE1pZGRsZXdhcmVEYXRhIiwic291cmNlIiwicmVzcG9uc2UiLCJuZXh0Q29uZmlnIiwiYmFzZVBhdGgiLCJpMThuIiwibG9jYWxlcyIsInRyYWlsaW5nU2xhc2giLCJCb29sZWFuIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9UUkFJTElOR19TTEFTSCIsInJld3JpdGVIZWFkZXIiLCJoZWFkZXJzIiwicmV3cml0ZVRhcmdldCIsIm1hdGNoZWRQYXRoIiwiX19ORVhUX0VYVEVSTkFMX01JRERMRVdBUkVfUkVXUklURV9SRVNPTFZFIiwicGFyc2VkUmV3cml0ZVRhcmdldCIsInBhcnNlUmVsYXRpdmVVcmwiLCJwYXRobmFtZUluZm8iLCJnZXROZXh0UGF0aG5hbWVJbmZvIiwicGFyc2VEYXRhIiwiZnNQYXRobmFtZSIsImdldFBhZ2VMaXN0IiwiZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCIsInRoZW4iLCJwYXJhbSIsIl9fcmV3cml0ZXMiLCJyZXdyaXRlcyIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJwYXJzZWRTb3VyY2UiLCJfX05FWFRfSEFTX1JFV1JJVEVTIiwidW5kZWZpbmVkIiwicmVzdWx0IiwicXVlcnkiLCJwYXRoIiwibWF0Y2hlZFBhZ2UiLCJwYXJzZWRBcyIsInJlc29sdmVkUGF0aG5hbWUiLCJtYXRjaGVzIiwiZ2V0Um91dGVNYXRjaGVyIiwidHlwZSIsInNyYyIsImZvcm1hdE5leHRQYXRobmFtZUluZm8iLCJkZWZhdWx0TG9jYWxlIiwiYnVpbGRJZCIsImRlc3RpbmF0aW9uIiwiaGFzaCIsInJlZGlyZWN0VGFyZ2V0IiwibmV3QXMiLCJuZXdVcmwiLCJ3aXRoTWlkZGxld2FyZUVmZmVjdHMiLCJmZXRjaERhdGEiLCJkYXRhIiwiZWZmZWN0IiwiZGF0YUhyZWYiLCJqc29uIiwidGV4dCIsImNhY2hlS2V5IiwiZSIsIm1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uIiwiX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTiIsIndpbmRvdyIsImhpc3RvcnkiLCJ2Iiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsIm4iLCJTU0dfREFUQV9OT1RfRk9VTkQiLCJTeW1ib2wiLCJmZXRjaFJldHJ5IiwiYXR0ZW1wdHMiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwibWV0aG9kIiwib2siLCJzdGF0dXMiLCJ0cnlUb1BhcnNlQXNKU09OIiwiSlNPTiIsInBhcnNlIiwiZXJyb3IiLCJmZXRjaE5leHREYXRhIiwiaW5mbGlnaHRDYWNoZSIsImlzUHJlZmV0Y2giLCJoYXNNaWRkbGV3YXJlIiwiaXNTZXJ2ZXJSZW5kZXIiLCJwYXJzZUpTT04iLCJwZXJzaXN0Q2FjaGUiLCJpc0JhY2tncm91bmQiLCJ1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUiLCJocmVmIiwiVVJMIiwibG9jYXRpb24iLCJfcGFyYW1zX21ldGhvZCIsImdldERhdGEiLCJwYXJhbXMiLCJwdXJwb3NlIiwiX3RyeVRvUGFyc2VBc0pTT04iLCJub3RGb3VuZCIsIm1hcmtBc3NldEVycm9yIiwiY2F0Y2giLCJlcnIiLCJtZXNzYWdlIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic2xpY2UiLCJoYW5kbGVIYXJkTmF2aWdhdGlvbiIsImdldENhbmNlbGxlZEhhbmRsZXIiLCJyb3V0ZSIsImNhbmNlbCIsImNsYyIsImhhbmRsZUNhbmNlbGxlZCIsInJlbG9hZCIsImJhY2siLCJmb3J3YXJkIiwicHVzaCIsIl9rZXkiLCJzdHJpbmdpZnkiLCJ4Iiwic2VsZiIsInBhZ2VYT2Zmc2V0IiwieSIsInBhZ2VZT2Zmc2V0IiwiY2hhbmdlIiwicmVwbGFjZSIsIl9iZmwiLCJza2lwTmF2aWdhdGUiLCJfX05FWFRfQ0xJRU5UX1JPVVRFUl9GSUxURVJfRU5BQkxFRCIsIm1hdGNoZXNCZmxTdGF0aWMiLCJtYXRjaGVzQmZsRHluYW1pYyIsImN1ckFzIiwiYXNOb1NsYXNoIiwiYXNOb1NsYXNoTG9jYWxlIiwiX3RoaXNfX2JmbF9zIiwiX3RoaXNfX2JmbF9zMSIsIl9iZmxfcyIsImNvbnRhaW5zIiwibm9ybWFsaXplZEFTIiwiY3VyQXNQYXJ0cyIsInNwbGl0IiwiaSIsIl90aGlzX19iZmxfZCIsImN1cnJlbnRQYXJ0Iiwiam9pbiIsIl9iZmxfZCIsImZvcmNlZFNjcm9sbCIsIl90aGlzX2NvbXBvbmVudHNfcGF0aG5hbWUiLCJpc0xvY2FsVVJMIiwiaXNRdWVyeVVwZGF0aW5nIiwiX2giLCJzaGFsbG93Iiwic2hvdWxkUmVzb2x2ZUhyZWYiLCJfc2hvdWxkUmVzb2x2ZUhyZWYiLCJuZXh0U3RhdGUiLCJzdGF0ZSIsInJlYWR5U3RhdGVDaGFuZ2UiLCJpc1JlYWR5IiwiaXNTc3IiLCJwcmV2TG9jYWxlIiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsImxvY2FsZVBhdGhSZXN1bHQiLCJkZXRlY3RlZExvY2FsZSIsImZvcm1hdFdpdGhWYWxpZGF0aW9uIiwiZGlkTmF2aWdhdGUiLCJfdGhpc19sb2NhbGVzIiwiZGV0ZWN0ZWREb21haW4iLCJkZXRlY3REb21haW5Mb2NhbGUiLCJkb21haW5Mb2NhbGVzIiwiaXNMb2NhbGVEb21haW4iLCJob3N0bmFtZSIsImRvbWFpbiIsImFzTm9CYXNlUGF0aCIsImh0dHAiLCJTVCIsInBlcmZvcm1hbmNlIiwibWFyayIsInNjcm9sbCIsInJvdXRlUHJvcHMiLCJfaW5GbGlnaHRSb3V0ZSIsImV2ZW50cyIsImVtaXQiLCJyZW1vdmVMb2NhbGUiLCJsb2NhbGVDaGFuZ2UiLCJvbmx5QUhhc2hDaGFuZ2UiLCJjaGFuZ2VTdGF0ZSIsInNjcm9sbFRvSGFzaCIsInNldCIsImNvbXBvbmVudHMiLCJwYXJzZWQiLCJfX2FwcFJvdXRlciIsInVybElzTmV3IiwicGFyc2VkQXNQYXRobmFtZSIsImlzTWlkZGxld2FyZVJld3JpdGUiLCJpc01pZGRsZXdhcmVNYXRjaCIsInJld3JpdGVzUmVzdWx0IiwicCIsImV4dGVybmFsRGVzdCIsInJvdXRlTWF0Y2giLCJyb3V0ZVJlZ2V4Iiwic2hvdWxkSW50ZXJwb2xhdGUiLCJpbnRlcnBvbGF0ZWRBcyIsImludGVycG9sYXRlQXMiLCJtaXNzaW5nUGFyYW1zIiwia2V5cyIsImdyb3VwcyIsImZpbHRlciIsIm9wdGlvbmFsIiwiY29uc29sZSIsIndhcm4iLCJvbWl0IiwiaXNFcnJvclJvdXRlIiwiX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wcyIsIl9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzIiwiX3JvdXRlSW5mb19wcm9wcyIsInJvdXRlSW5mbyIsImdldFJvdXRlSW5mbyIsImlzUHJldmlldyIsImlzRmFsbGJhY2siLCJjbGVhbmVkUGFyc2VkUGF0aG5hbWUiLCJmb3JFYWNoIiwia2V5IiwicHJlZml4ZWRBcyIsInJld3JpdGVBcyIsImxvY2FsZVJlc3VsdCIsImN1clJvdXRlTWF0Y2giLCJjb21wb25lbnQiLCJDb21wb25lbnQiLCJ1bnN0YWJsZV9zY3JpcHRMb2FkZXIiLCJzY3JpcHRzIiwiY29uY2F0Iiwic2NyaXB0IiwiaGFuZGxlQ2xpZW50U2NyaXB0TG9hZCIsInByb3BzIiwiX19OX1NTRyIsIl9fTl9TU1AiLCJwYWdlUHJvcHMiLCJfX05fUkVESVJFQ1QiLCJfX05fUkVESVJFQ1RfQkFTRV9QQVRIIiwicGFyc2VkSHJlZiIsIl9fTl9QUkVWSUVXIiwibm90Rm91bmRSb3V0ZSIsImZldGNoQ29tcG9uZW50IiwiaXNOb3RGb3VuZCIsIl9fTkVYVF9EQVRBX18iLCJzdGF0dXNDb2RlIiwiX3JvdXRlSW5mb19yb3V0ZSIsImlzVmFsaWRTaGFsbG93Um91dGUiLCJfb3B0aW9uc19zY3JvbGwiLCJzaG91bGRTY3JvbGwiLCJyZXNldFNjcm9sbCIsInVwY29taW5nU2Nyb2xsU3RhdGUiLCJ1cGNvbWluZ1JvdXRlclN0YXRlIiwiX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wczEiLCJfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wczEiLCJfcm91dGVJbmZvX3Byb3BzMSIsImNhblNraXBVcGRhdGluZyIsImNvbXBhcmVSb3V0ZXJTdGF0ZXMiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImxhbmciLCJoYXNoUmVnZXgiLCJnZXRVUkwiLCJfc2hhbGxvdyIsIl9fTiIsImhhbmRsZVJvdXRlSW5mb0Vycm9yIiwibG9hZEVycm9yRmFpbCIsImlzQXNzZXRFcnJvciIsInN0eWxlU2hlZXRzIiwiZ2V0SW5pdGlhbFByb3BzIiwiZ2lwRXJyIiwicm91dGVJbmZvRXJyIiwicmVxdWVzdGVkUm91dGUiLCJfZGF0YV9lZmZlY3QiLCJfZGF0YV9lZmZlY3QxIiwiX2RhdGFfZWZmZWN0MiIsIl9kYXRhX3Jlc3BvbnNlIiwiZXhpc3RpbmdJbmZvIiwiY2FjaGVkUm91dGVJbmZvIiwiZmV0Y2hOZXh0RGF0YVBhcmFtcyIsImdldERhdGFIcmVmIiwic2tpcEludGVycG9sYXRpb24iLCJzYmMiLCJzZGMiLCJyZXNvbHZlZFJvdXRlIiwiaXNBUElSb3V0ZSIsInJlcyIsIm1vZCIsImlzVmFsaWRFbGVtZW50VHlwZSIsIndhc0JhaWxlZFByZWZldGNoIiwic2hvdWxkRmV0Y2hEYXRhIiwiX2dldERhdGEiLCJmZXRjaGVkIiwiZ2V0UHJvcGVyRXJyb3IiLCJzdWIiLCJiZWZvcmVQb3BTdGF0ZSIsImNiIiwiX2JwcyIsIm9sZFVybE5vSGFzaCIsIm9sZEhhc2giLCJuZXdVcmxOb0hhc2giLCJuZXdIYXNoIiwiaGFuZGxlU21vb3RoU2Nyb2xsIiwic2Nyb2xsVG8iLCJyYXdIYXNoIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiaWRFbCIsImdldEVsZW1lbnRCeUlkIiwic2Nyb2xsSW50b1ZpZXciLCJuYW1lRWwiLCJnZXRFbGVtZW50c0J5TmFtZSIsIm9ubHlIYXNoQ2hhbmdlIiwicHJlZmV0Y2giLCJpc0JvdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInVybFBhdGhuYW1lIiwib3JpZ2luYWxQYXRobmFtZSIsIl9fTkVYVF9NSURETEVXQVJFX1BSRUZFVENIIiwiX2lzU3NnIiwiaXNTc2ciLCJwcmlvcml0eSIsIl9fTkVYVF9PUFRJTUlTVElDX0NMSUVOVF9DQUNIRSIsImNvbXBvbmVudFJlc3VsdCIsImxvYWRQYWdlIiwiZm4iLCJfZ2V0RmxpZ2h0RGF0YSIsImN0eCIsIkFwcCIsIkFwcFRyZWUiLCJfd3JhcEFwcCIsImxvYWRHZXRJbml0aWFsUHJvcHMiLCJjb25zdHJ1Y3RvciIsImluaXRpYWxQcm9wcyIsIndyYXBBcHAiLCJzdWJzY3JpcHRpb24iLCJpc0ZpcnN0UG9wU3RhdGVFdmVudCIsIm9uUG9wU3RhdGUiLCJfX05BIiwiZ2V0SXRlbSIsImluaXRpYWwiLCJCbG9vbUZpbHRlciIsInN0YXRpY0ZpbHRlckRhdGEiLCJfX05FWFRfQ0xJRU5UX1JPVVRFUl9TX0ZJTFRFUiIsImR5bmFtaWNGaWx0ZXJEYXRhIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfRF9GSUxURVIiLCJudW1IYXNoZXMiLCJudW1JdGVtcyIsImVycm9yUmF0ZSIsImltcG9ydCIsImF1dG9FeHBvcnREeW5hbWljIiwiYXV0b0V4cG9ydCIsIl9fTkVYVF9ST1VURVJfQkFTRVBBVEgiLCJnc3NwIiwiZ2lwIiwiYXBwR2lwIiwiZ3NwIiwic2VhcmNoIiwiX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2UiLCJhZGRFdmVudExpc3RlbmVyIiwic2Nyb2xsUmVzdG9yYXRpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/router.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js":
/*!********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js ***!
  \********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Run function with `scroll-behavior: auto` applied to `<html/>`.\n * This css change will be reverted after the function finishes.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"handleSmoothScroll\", ({\n    enumerable: true,\n    get: function() {\n        return handleSmoothScroll;\n    }\n}));\nfunction handleSmoothScroll(fn, options) {\n    if (options === void 0) options = {};\n    // if only the hash is changed, we don't need to disable smooth scrolling\n    // we only care to prevent smooth scrolling when navigating to a new page to avoid jarring UX\n    if (options.onlyHashChange) {\n        fn();\n        return;\n    }\n    const htmlElement = document.documentElement;\n    const existing = htmlElement.style.scrollBehavior;\n    htmlElement.style.scrollBehavior = \"auto\";\n    if (!options.dontForceLayout) {\n        // In Chrome-based browsers we need to force reflow before calling `scrollTo`.\n        // Otherwise it will not pickup the change in scrollBehavior\n        // More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042\n        htmlElement.getClientRects();\n    }\n    fn();\n    htmlElement.style.scrollBehavior = existing;\n} //# sourceMappingURL=handle-smooth-scroll.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2hhbmRsZS1zbW9vdGgtc2Nyb2xsLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Q0FHQyxHQUFnQjtBQUNqQkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILHNEQUFxRDtJQUNqREksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLFNBQVNBLG1CQUFtQkMsRUFBRSxFQUFFQyxPQUFPO0lBQ25DLElBQUlBLFlBQVksS0FBSyxHQUFHQSxVQUFVLENBQUM7SUFDbkMseUVBQXlFO0lBQ3pFLDZGQUE2RjtJQUM3RixJQUFJQSxRQUFRQyxjQUFjLEVBQUU7UUFDeEJGO1FBQ0E7SUFDSjtJQUNBLE1BQU1HLGNBQWNDLFNBQVNDLGVBQWU7SUFDNUMsTUFBTUMsV0FBV0gsWUFBWUksS0FBSyxDQUFDQyxjQUFjO0lBQ2pETCxZQUFZSSxLQUFLLENBQUNDLGNBQWMsR0FBRztJQUNuQyxJQUFJLENBQUNQLFFBQVFRLGVBQWUsRUFBRTtRQUMxQiw4RUFBOEU7UUFDOUUsNERBQTREO1FBQzVELHlGQUF5RjtRQUN6Rk4sWUFBWU8sY0FBYztJQUM5QjtJQUNBVjtJQUNBRyxZQUFZSSxLQUFLLENBQUNDLGNBQWMsR0FBR0Y7QUFDdkMsRUFFQSxnREFBZ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9oYW5kbGUtc21vb3RoLXNjcm9sbC5qcz82NTYzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUnVuIGZ1bmN0aW9uIHdpdGggYHNjcm9sbC1iZWhhdmlvcjogYXV0b2AgYXBwbGllZCB0byBgPGh0bWwvPmAuXG4gKiBUaGlzIGNzcyBjaGFuZ2Ugd2lsbCBiZSByZXZlcnRlZCBhZnRlciB0aGUgZnVuY3Rpb24gZmluaXNoZXMuXG4gKi8gXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoYW5kbGVTbW9vdGhTY3JvbGxcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVNtb290aFNjcm9sbDtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGhhbmRsZVNtb290aFNjcm9sbChmbiwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIG9wdGlvbnMgPSB7fTtcbiAgICAvLyBpZiBvbmx5IHRoZSBoYXNoIGlzIGNoYW5nZWQsIHdlIGRvbid0IG5lZWQgdG8gZGlzYWJsZSBzbW9vdGggc2Nyb2xsaW5nXG4gICAgLy8gd2Ugb25seSBjYXJlIHRvIHByZXZlbnQgc21vb3RoIHNjcm9sbGluZyB3aGVuIG5hdmlnYXRpbmcgdG8gYSBuZXcgcGFnZSB0byBhdm9pZCBqYXJyaW5nIFVYXG4gICAgaWYgKG9wdGlvbnMub25seUhhc2hDaGFuZ2UpIHtcbiAgICAgICAgZm4oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBodG1sRWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICBjb25zdCBleGlzdGluZyA9IGh0bWxFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yO1xuICAgIGh0bWxFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gXCJhdXRvXCI7XG4gICAgaWYgKCFvcHRpb25zLmRvbnRGb3JjZUxheW91dCkge1xuICAgICAgICAvLyBJbiBDaHJvbWUtYmFzZWQgYnJvd3NlcnMgd2UgbmVlZCB0byBmb3JjZSByZWZsb3cgYmVmb3JlIGNhbGxpbmcgYHNjcm9sbFRvYC5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGl0IHdpbGwgbm90IHBpY2t1cCB0aGUgY2hhbmdlIGluIHNjcm9sbEJlaGF2aW9yXG4gICAgICAgIC8vIE1vcmUgaW5mbyBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvaXNzdWVzLzQwNzE5I2lzc3VlY29tbWVudC0xMzM2MjQ4MDQyXG4gICAgICAgIGh0bWxFbGVtZW50LmdldENsaWVudFJlY3RzKCk7XG4gICAgfVxuICAgIGZuKCk7XG4gICAgaHRtbEVsZW1lbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSBleGlzdGluZztcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFuZGxlLXNtb290aC1zY3JvbGwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImhhbmRsZVNtb290aFNjcm9sbCIsImZuIiwib3B0aW9ucyIsIm9ubHlIYXNoQ2hhbmdlIiwiaHRtbEVsZW1lbnQiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImV4aXN0aW5nIiwic3R5bGUiLCJzY3JvbGxCZWhhdmlvciIsImRvbnRGb3JjZUxheW91dCIsImdldENsaWVudFJlY3RzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/route-regex.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/route-regex.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getRouteRegex: function() {\n        return getRouteRegex;\n    },\n    getNamedRouteRegex: function() {\n        return getNamedRouteRegex;\n    },\n    getNamedMiddlewareRegex: function() {\n        return getNamedMiddlewareRegex;\n    }\n});\nconst _interceptionroutes = __webpack_require__(/*! ../../../../server/future/helpers/interception-routes */ \"./node_modules/next/dist/server/future/helpers/interception-routes.js\");\nconst _escaperegexp = __webpack_require__(/*! ../../escape-regexp */ \"./node_modules/next/dist/shared/lib/escape-regexp.js\");\nconst _removetrailingslash = __webpack_require__(/*! ./remove-trailing-slash */ \"./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nconst NEXT_QUERY_PARAM_PREFIX = \"nxtP\";\nconst NEXT_INTERCEPTION_MARKER_PREFIX = \"nxtI\";\n/**\n * Parses a given parameter from a route to a data structure that can be used\n * to generate the parametrized route. Examples:\n *   - `[...slug]` -> `{ key: 'slug', repeat: true, optional: true }`\n *   - `...slug` -> `{ key: 'slug', repeat: true, optional: false }`\n *   - `[foo]` -> `{ key: 'foo', repeat: false, optional: true }`\n *   - `bar` -> `{ key: 'bar', repeat: false, optional: false }`\n */ function parseParameter(param) {\n    const optional = param.startsWith(\"[\") && param.endsWith(\"]\");\n    if (optional) {\n        param = param.slice(1, -1);\n    }\n    const repeat = param.startsWith(\"...\");\n    if (repeat) {\n        param = param.slice(3);\n    }\n    return {\n        key: param,\n        repeat,\n        optional\n    };\n}\nfunction getParametrizedRoute(route) {\n    const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n    const groups = {};\n    let groupIndex = 1;\n    return {\n        parameterizedRoute: segments.map((segment)=>{\n            const markerMatch = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m));\n            const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n            ;\n            if (markerMatch && paramMatches) {\n                const { key, optional, repeat } = parseParameter(paramMatches[1]);\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat,\n                    optional\n                };\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(markerMatch) + \"([^/]+?)\";\n            } else if (paramMatches) {\n                const { key, repeat, optional } = parseParameter(paramMatches[1]);\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat,\n                    optional\n                };\n                return repeat ? optional ? \"(?:/(.+?))?\" : \"/(.+?)\" : \"/([^/]+?)\";\n            } else {\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n            }\n        }).join(\"\"),\n        groups\n    };\n}\nfunction getRouteRegex(normalizedRoute) {\n    const { parameterizedRoute, groups } = getParametrizedRoute(normalizedRoute);\n    return {\n        re: new RegExp(\"^\" + parameterizedRoute + \"(?:/)?$\"),\n        groups: groups\n    };\n}\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */ function buildGetSafeRouteKey() {\n    let i = 0;\n    return ()=>{\n        let routeKey = \"\";\n        let j = ++i;\n        while(j > 0){\n            routeKey += String.fromCharCode(97 + (j - 1) % 26);\n            j = Math.floor((j - 1) / 26);\n        }\n        return routeKey;\n    };\n}\nfunction getSafeKeyFromSegment(param) {\n    let { getSafeRouteKey, segment, routeKeys, keyPrefix } = param;\n    const { key, optional, repeat } = parseParameter(segment);\n    // replace any non-word characters since they can break\n    // the named regex\n    let cleanedKey = key.replace(/\\W/g, \"\");\n    if (keyPrefix) {\n        cleanedKey = \"\" + keyPrefix + cleanedKey;\n    }\n    let invalidKey = false;\n    // check if the key is still invalid and fallback to using a known\n    // safe key\n    if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n        invalidKey = true;\n    }\n    if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n        invalidKey = true;\n    }\n    if (invalidKey) {\n        cleanedKey = getSafeRouteKey();\n    }\n    if (keyPrefix) {\n        routeKeys[cleanedKey] = \"\" + keyPrefix + key;\n    } else {\n        routeKeys[cleanedKey] = \"\" + key;\n    }\n    return repeat ? optional ? \"(?:/(?<\" + cleanedKey + \">.+?))?\" : \"/(?<\" + cleanedKey + \">.+?)\" : \"/(?<\" + cleanedKey + \">[^/]+?)\";\n}\nfunction getNamedParametrizedRoute(route, prefixRouteKeys) {\n    const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n    const getSafeRouteKey = buildGetSafeRouteKey();\n    const routeKeys = {};\n    return {\n        namedParameterizedRoute: segments.map((segment)=>{\n            const hasInterceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>segment.startsWith(m));\n            const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n            ;\n            if (hasInterceptionMarker && paramMatches) {\n                return getSafeKeyFromSegment({\n                    getSafeRouteKey,\n                    segment: paramMatches[1],\n                    routeKeys,\n                    keyPrefix: prefixRouteKeys ? NEXT_INTERCEPTION_MARKER_PREFIX : undefined\n                });\n            } else if (paramMatches) {\n                return getSafeKeyFromSegment({\n                    getSafeRouteKey,\n                    segment: paramMatches[1],\n                    routeKeys,\n                    keyPrefix: prefixRouteKeys ? NEXT_QUERY_PARAM_PREFIX : undefined\n                });\n            } else {\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n            }\n        }).join(\"\"),\n        routeKeys\n    };\n}\nfunction getNamedRouteRegex(normalizedRoute, prefixRouteKey) {\n    const result = getNamedParametrizedRoute(normalizedRoute, prefixRouteKey);\n    return {\n        ...getRouteRegex(normalizedRoute),\n        namedRegex: \"^\" + result.namedParameterizedRoute + \"(?:/)?$\",\n        routeKeys: result.routeKeys\n    };\n}\nfunction getNamedMiddlewareRegex(normalizedRoute, options) {\n    const { parameterizedRoute } = getParametrizedRoute(normalizedRoute);\n    const { catchAll = true } = options;\n    if (parameterizedRoute === \"/\") {\n        let catchAllRegex = catchAll ? \".*\" : \"\";\n        return {\n            namedRegex: \"^/\" + catchAllRegex + \"$\"\n        };\n    }\n    const { namedParameterizedRoute } = getNamedParametrizedRoute(normalizedRoute, false);\n    let catchAllGroupedRegex = catchAll ? \"(?:(/.*)?)\" : \"\";\n    return {\n        namedRegex: \"^\" + namedParameterizedRoute + catchAllGroupedRegex + \"$\"\n    };\n} //# sourceMappingURL=route-regex.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3JvdXRlLXJlZ2V4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGLEtBQU1DLENBQUFBLENBSU47QUFDQSxTQUFTSSxRQUFRQyxNQUFNLEVBQUVDLEdBQUc7SUFDeEIsSUFBSSxJQUFJQyxRQUFRRCxJQUFJVixPQUFPQyxjQUFjLENBQUNRLFFBQVFFLE1BQU07UUFDcERDLFlBQVk7UUFDWkMsS0FBS0gsR0FBRyxDQUFDQyxLQUFLO0lBQ2xCO0FBQ0o7QUFDQUgsUUFBUU4sU0FBUztJQUNiRyxlQUFlO1FBQ1gsT0FBT0E7SUFDWDtJQUNBQyxvQkFBb0I7UUFDaEIsT0FBT0E7SUFDWDtJQUNBQyx5QkFBeUI7UUFDckIsT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTU8sc0JBQXNCQyxtQkFBT0EsQ0FBQyxvSUFBdUQ7QUFDM0YsTUFBTUMsZ0JBQWdCRCxtQkFBT0EsQ0FBQyxpRkFBcUI7QUFDbkQsTUFBTUUsdUJBQXVCRixtQkFBT0EsQ0FBQywwR0FBeUI7QUFDOUQsTUFBTUcsMEJBQTBCO0FBQ2hDLE1BQU1DLGtDQUFrQztBQUN4Qzs7Ozs7OztDQU9DLEdBQUcsU0FBU0MsZUFBZUMsS0FBSztJQUM3QixNQUFNQyxXQUFXRCxNQUFNRSxVQUFVLENBQUMsUUFBUUYsTUFBTUcsUUFBUSxDQUFDO0lBQ3pELElBQUlGLFVBQVU7UUFDVkQsUUFBUUEsTUFBTUksS0FBSyxDQUFDLEdBQUcsQ0FBQztJQUM1QjtJQUNBLE1BQU1DLFNBQVNMLE1BQU1FLFVBQVUsQ0FBQztJQUNoQyxJQUFJRyxRQUFRO1FBQ1JMLFFBQVFBLE1BQU1JLEtBQUssQ0FBQztJQUN4QjtJQUNBLE9BQU87UUFDSEUsS0FBS047UUFDTEs7UUFDQUo7SUFDSjtBQUNKO0FBQ0EsU0FBU00scUJBQXFCQyxLQUFLO0lBQy9CLE1BQU1DLFdBQVcsQ0FBQyxH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QVdlLE9BQU9mLFNBQVM7SUFDL0I7QUFDSjtBQUNBLFNBQVNyRCx3QkFBd0J3QyxlQUFlLEVBQUU4QixPQUFPO0lBQ3JELE1BQU0sRUFBRTFDLGtCQUFrQixFQUFHLEdBQUdQLHFCQUFxQm1CO0lBQ3JELE1BQU0sRUFBRStCLFdBQVUsSUFBSSxFQUFHLEdBQUdEO0lBQzVCLElBQUkxQyx1QkFBdUIsS0FBSztRQUM1QixJQUFJNEMsZ0JBQWdCRCxXQUFXLE9BQU87UUFDdEMsT0FBTztZQUNIRixZQUFZLE9BQU9HLGdCQUFnQjtRQUN2QztJQUNKO0lBQ0EsTUFBTSxFQUFFVCx1QkFBdUIsRUFBRyxHQUFHRiwwQkFBMEJyQixpQkFBaUI7SUFDaEYsSUFBSWlDLHVCQUF1QkYsV0FBVyxlQUFlO0lBQ3JELE9BQU87UUFDSEYsWUFBWSxNQUFNTiwwQkFBMEJVLHVCQUF1QjtJQUN2RTtBQUNKLEVBRUEsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtcmVnZXguanM/ZWFjMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdldFJvdXRlUmVnZXg6IG51bGwsXG4gICAgZ2V0TmFtZWRSb3V0ZVJlZ2V4OiBudWxsLFxuICAgIGdldE5hbWVkTWlkZGxld2FyZVJlZ2V4OiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIGdldFJvdXRlUmVnZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0Um91dGVSZWdleDtcbiAgICB9LFxuICAgIGdldE5hbWVkUm91dGVSZWdleDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXROYW1lZFJvdXRlUmVnZXg7XG4gICAgfSxcbiAgICBnZXROYW1lZE1pZGRsZXdhcmVSZWdleDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXROYW1lZE1pZGRsZXdhcmVSZWdleDtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcmNlcHRpb25yb3V0ZXMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vc2VydmVyL2Z1dHVyZS9oZWxwZXJzL2ludGVyY2VwdGlvbi1yb3V0ZXNcIik7XG5jb25zdCBfZXNjYXBlcmVnZXhwID0gcmVxdWlyZShcIi4uLy4uL2VzY2FwZS1yZWdleHBcIik7XG5jb25zdCBfcmVtb3ZldHJhaWxpbmdzbGFzaCA9IHJlcXVpcmUoXCIuL3JlbW92ZS10cmFpbGluZy1zbGFzaFwiKTtcbmNvbnN0IE5FWFRfUVVFUllfUEFSQU1fUFJFRklYID0gXCJueHRQXCI7XG5jb25zdCBORVhUX0lOVEVSQ0VQVElPTl9NQVJLRVJfUFJFRklYID0gXCJueHRJXCI7XG4vKipcbiAqIFBhcnNlcyBhIGdpdmVuIHBhcmFtZXRlciBmcm9tIGEgcm91dGUgdG8gYSBkYXRhIHN0cnVjdHVyZSB0aGF0IGNhbiBiZSB1c2VkXG4gKiB0byBnZW5lcmF0ZSB0aGUgcGFyYW1ldHJpemVkIHJvdXRlLiBFeGFtcGxlczpcbiAqICAgLSBgWy4uLnNsdWddYCAtPiBgeyBrZXk6ICdzbHVnJywgcmVwZWF0OiB0cnVlLCBvcHRpb25hbDogdHJ1ZSB9YFxuICogICAtIGAuLi5zbHVnYCAtPiBgeyBrZXk6ICdzbHVnJywgcmVwZWF0OiB0cnVlLCBvcHRpb25hbDogZmFsc2UgfWBcbiAqICAgLSBgW2Zvb11gIC0+IGB7IGtleTogJ2ZvbycsIHJlcGVhdDogZmFsc2UsIG9wdGlvbmFsOiB0cnVlIH1gXG4gKiAgIC0gYGJhcmAgLT4gYHsga2V5OiAnYmFyJywgcmVwZWF0OiBmYWxzZSwgb3B0aW9uYWw6IGZhbHNlIH1gXG4gKi8gZnVuY3Rpb24gcGFyc2VQYXJhbWV0ZXIocGFyYW0pIHtcbiAgICBjb25zdCBvcHRpb25hbCA9IHBhcmFtLnN0YXJ0c1dpdGgoXCJbXCIpICYmIHBhcmFtLmVuZHNXaXRoKFwiXVwiKTtcbiAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgICAgcGFyYW0gPSBwYXJhbS5zbGljZSgxLCAtMSk7XG4gICAgfVxuICAgIGNvbnN0IHJlcGVhdCA9IHBhcmFtLnN0YXJ0c1dpdGgoXCIuLi5cIik7XG4gICAgaWYgKHJlcGVhdCkge1xuICAgICAgICBwYXJhbSA9IHBhcmFtLnNsaWNlKDMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBrZXk6IHBhcmFtLFxuICAgICAgICByZXBlYXQsXG4gICAgICAgIG9wdGlvbmFsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhcmFtZXRyaXplZFJvdXRlKHJvdXRlKSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocm91dGUpLnNsaWNlKDEpLnNwbGl0KFwiL1wiKTtcbiAgICBjb25zdCBncm91cHMgPSB7fTtcbiAgICBsZXQgZ3JvdXBJbmRleCA9IDE7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGFyYW1ldGVyaXplZFJvdXRlOiBzZWdtZW50cy5tYXAoKHNlZ21lbnQpPT57XG4gICAgICAgICAgICBjb25zdCBtYXJrZXJNYXRjaCA9IF9pbnRlcmNlcHRpb25yb3V0ZXMuSU5URVJDRVBUSU9OX1JPVVRFX01BUktFUlMuZmluZCgobSk9PnNlZ21lbnQuc3RhcnRzV2l0aChtKSk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbU1hdGNoZXMgPSBzZWdtZW50Lm1hdGNoKC9cXFsoKD86XFxbLipcXF0pfC4rKVxcXS8pIC8vIENoZWNrIGZvciBwYXJhbWV0ZXJzXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBpZiAobWFya2VyTWF0Y2ggJiYgcGFyYW1NYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBrZXkgLCBvcHRpb25hbCAsIHJlcGVhdCAgfSA9IHBhcnNlUGFyYW1ldGVyKHBhcmFtTWF0Y2hlc1sxXSk7XG4gICAgICAgICAgICAgICAgZ3JvdXBzW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHBvczogZ3JvdXBJbmRleCsrLFxuICAgICAgICAgICAgICAgICAgICByZXBlYXQsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIvXCIgKyAoMCwgX2VzY2FwZXJlZ2V4cC5lc2NhcGVTdHJpbmdSZWdleHApKG1hcmtlck1hdGNoKSArIFwiKFteL10rPylcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW1NYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBrZXkgLCByZXBlYXQgLCBvcHRpb25hbCAgfSA9IHBhcnNlUGFyYW1ldGVyKHBhcmFtTWF0Y2hlc1sxXSk7XG4gICAgICAgICAgICAgICAgZ3JvdXBzW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHBvczogZ3JvdXBJbmRleCsrLFxuICAgICAgICAgICAgICAgICAgICByZXBlYXQsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVwZWF0ID8gb3B0aW9uYWwgPyBcIig/Oi8oLis/KSk/XCIgOiBcIi8oLis/KVwiIDogXCIvKFteL10rPylcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiL1wiICsgKDAsIF9lc2NhcGVyZWdleHAuZXNjYXBlU3RyaW5nUmVnZXhwKShzZWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuam9pbihcIlwiKSxcbiAgICAgICAgZ3JvdXBzXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFJvdXRlUmVnZXgobm9ybWFsaXplZFJvdXRlKSB7XG4gICAgY29uc3QgeyBwYXJhbWV0ZXJpemVkUm91dGUgLCBncm91cHMgIH0gPSBnZXRQYXJhbWV0cml6ZWRSb3V0ZShub3JtYWxpemVkUm91dGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlOiBuZXcgUmVnRXhwKFwiXlwiICsgcGFyYW1ldGVyaXplZFJvdXRlICsgXCIoPzovKT8kXCIpLFxuICAgICAgICBncm91cHM6IGdyb3Vwc1xuICAgIH07XG59XG4vKipcbiAqIEJ1aWxkcyBhIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGEgbWluaW1hbCByb3V0ZUtleSB1c2luZyBvbmx5IGEteiBhbmQgbWluaW1hbFxuICogbnVtYmVyIG9mIGNoYXJhY3RlcnMuXG4gKi8gZnVuY3Rpb24gYnVpbGRHZXRTYWZlUm91dGVLZXkoKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIHJldHVybiAoKT0+e1xuICAgICAgICBsZXQgcm91dGVLZXkgPSBcIlwiO1xuICAgICAgICBsZXQgaiA9ICsraTtcbiAgICAgICAgd2hpbGUoaiA+IDApe1xuICAgICAgICAgICAgcm91dGVLZXkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSg5NyArIChqIC0gMSkgJSAyNik7XG4gICAgICAgICAgICBqID0gTWF0aC5mbG9vcigoaiAtIDEpIC8gMjYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3V0ZUtleTtcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0U2FmZUtleUZyb21TZWdtZW50KHBhcmFtKSB7XG4gICAgbGV0IHsgZ2V0U2FmZVJvdXRlS2V5ICwgc2VnbWVudCAsIHJvdXRlS2V5cyAsIGtleVByZWZpeCAgfSA9IHBhcmFtO1xuICAgIGNvbnN0IHsga2V5ICwgb3B0aW9uYWwgLCByZXBlYXQgIH0gPSBwYXJzZVBhcmFtZXRlcihzZWdtZW50KTtcbiAgICAvLyByZXBsYWNlIGFueSBub24td29yZCBjaGFyYWN0ZXJzIHNpbmNlIHRoZXkgY2FuIGJyZWFrXG4gICAgLy8gdGhlIG5hbWVkIHJlZ2V4XG4gICAgbGV0IGNsZWFuZWRLZXkgPSBrZXkucmVwbGFjZSgvXFxXL2csIFwiXCIpO1xuICAgIGlmIChrZXlQcmVmaXgpIHtcbiAgICAgICAgY2xlYW5lZEtleSA9IFwiXCIgKyBrZXlQcmVmaXggKyBjbGVhbmVkS2V5O1xuICAgIH1cbiAgICBsZXQgaW52YWxpZEtleSA9IGZhbHNlO1xuICAgIC8vIGNoZWNrIGlmIHRoZSBrZXkgaXMgc3RpbGwgaW52YWxpZCBhbmQgZmFsbGJhY2sgdG8gdXNpbmcgYSBrbm93blxuICAgIC8vIHNhZmUga2V5XG4gICAgaWYgKGNsZWFuZWRLZXkubGVuZ3RoID09PSAwIHx8IGNsZWFuZWRLZXkubGVuZ3RoID4gMzApIHtcbiAgICAgICAgaW52YWxpZEtleSA9IHRydWU7XG4gICAgfVxuICAgIGlmICghaXNOYU4ocGFyc2VJbnQoY2xlYW5lZEtleS5zbGljZSgwLCAxKSkpKSB7XG4gICAgICAgIGludmFsaWRLZXkgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaW52YWxpZEtleSkge1xuICAgICAgICBjbGVhbmVkS2V5ID0gZ2V0U2FmZVJvdXRlS2V5KCk7XG4gICAgfVxuICAgIGlmIChrZXlQcmVmaXgpIHtcbiAgICAgICAgcm91dGVLZXlzW2NsZWFuZWRLZXldID0gXCJcIiArIGtleVByZWZpeCArIGtleTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb3V0ZUtleXNbY2xlYW5lZEtleV0gPSBcIlwiICsga2V5O1xuICAgIH1cbiAgICByZXR1cm4gcmVwZWF0ID8gb3B0aW9uYWwgPyBcIig/Oi8oPzxcIiArIGNsZWFuZWRLZXkgKyBcIj4uKz8pKT9cIiA6IFwiLyg/PFwiICsgY2xlYW5lZEtleSArIFwiPi4rPylcIiA6IFwiLyg/PFwiICsgY2xlYW5lZEtleSArIFwiPlteL10rPylcIjtcbn1cbmZ1bmN0aW9uIGdldE5hbWVkUGFyYW1ldHJpemVkUm91dGUocm91dGUsIHByZWZpeFJvdXRlS2V5cykge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHJvdXRlKS5zbGljZSgxKS5zcGxpdChcIi9cIik7XG4gICAgY29uc3QgZ2V0U2FmZVJvdXRlS2V5ID0gYnVpbGRHZXRTYWZlUm91dGVLZXkoKTtcbiAgICBjb25zdCByb3V0ZUtleXMgPSB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZTogc2VnbWVudHMubWFwKChzZWdtZW50KT0+e1xuICAgICAgICAgICAgY29uc3QgaGFzSW50ZXJjZXB0aW9uTWFya2VyID0gX2ludGVyY2VwdGlvbnJvdXRlcy5JTlRFUkNFUFRJT05fUk9VVEVfTUFSS0VSUy5zb21lKChtKT0+c2VnbWVudC5zdGFydHNXaXRoKG0pKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtTWF0Y2hlcyA9IHNlZ21lbnQubWF0Y2goL1xcWygoPzpcXFsuKlxcXSl8LispXFxdLykgLy8gQ2hlY2sgZm9yIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGlmIChoYXNJbnRlcmNlcHRpb25NYXJrZXIgJiYgcGFyYW1NYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFNhZmVLZXlGcm9tU2VnbWVudCh7XG4gICAgICAgICAgICAgICAgICAgIGdldFNhZmVSb3V0ZUtleSxcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudDogcGFyYW1NYXRjaGVzWzFdLFxuICAgICAgICAgICAgICAgICAgICByb3V0ZUtleXMsXG4gICAgICAgICAgICAgICAgICAgIGtleVByZWZpeDogcHJlZml4Um91dGVLZXlzID8gTkVYVF9JTlRFUkNFUFRJT05fTUFSS0VSX1BSRUZJWCA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbU1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0U2FmZUtleUZyb21TZWdtZW50KHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0U2FmZVJvdXRlS2V5LFxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50OiBwYXJhbU1hdGNoZXNbMV0sXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlS2V5cyxcbiAgICAgICAgICAgICAgICAgICAga2V5UHJlZml4OiBwcmVmaXhSb3V0ZUtleXMgPyBORVhUX1FVRVJZX1BBUkFNX1BSRUZJWCA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIvXCIgKyAoMCwgX2VzY2FwZXJlZ2V4cC5lc2NhcGVTdHJpbmdSZWdleHApKHNlZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5qb2luKFwiXCIpLFxuICAgICAgICByb3V0ZUtleXNcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0TmFtZWRSb3V0ZVJlZ2V4KG5vcm1hbGl6ZWRSb3V0ZSwgcHJlZml4Um91dGVLZXkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBnZXROYW1lZFBhcmFtZXRyaXplZFJvdXRlKG5vcm1hbGl6ZWRSb3V0ZSwgcHJlZml4Um91dGVLZXkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmdldFJvdXRlUmVnZXgobm9ybWFsaXplZFJvdXRlKSxcbiAgICAgICAgbmFtZWRSZWdleDogXCJeXCIgKyByZXN1bHQubmFtZWRQYXJhbWV0ZXJpemVkUm91dGUgKyBcIig/Oi8pPyRcIixcbiAgICAgICAgcm91dGVLZXlzOiByZXN1bHQucm91dGVLZXlzXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldE5hbWVkTWlkZGxld2FyZVJlZ2V4KG5vcm1hbGl6ZWRSb3V0ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgcGFyYW1ldGVyaXplZFJvdXRlICB9ID0gZ2V0UGFyYW1ldHJpemVkUm91dGUobm9ybWFsaXplZFJvdXRlKTtcbiAgICBjb25zdCB7IGNhdGNoQWxsID10cnVlICB9ID0gb3B0aW9ucztcbiAgICBpZiAocGFyYW1ldGVyaXplZFJvdXRlID09PSBcIi9cIikge1xuICAgICAgICBsZXQgY2F0Y2hBbGxSZWdleCA9IGNhdGNoQWxsID8gXCIuKlwiIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWVkUmVnZXg6IFwiXi9cIiArIGNhdGNoQWxsUmVnZXggKyBcIiRcIlxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB7IG5hbWVkUGFyYW1ldGVyaXplZFJvdXRlICB9ID0gZ2V0TmFtZWRQYXJhbWV0cml6ZWRSb3V0ZShub3JtYWxpemVkUm91dGUsIGZhbHNlKTtcbiAgICBsZXQgY2F0Y2hBbGxHcm91cGVkUmVnZXggPSBjYXRjaEFsbCA/IFwiKD86KC8uKik/KVwiIDogXCJcIjtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lZFJlZ2V4OiBcIl5cIiArIG5hbWVkUGFyYW1ldGVyaXplZFJvdXRlICsgY2F0Y2hBbGxHcm91cGVkUmVnZXggKyBcIiRcIlxuICAgIH07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlLXJlZ2V4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsImdldFJvdXRlUmVnZXgiLCJnZXROYW1lZFJvdXRlUmVnZXgiLCJnZXROYW1lZE1pZGRsZXdhcmVSZWdleCIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIl9pbnRlcmNlcHRpb25yb3V0ZXMiLCJyZXF1aXJlIiwiX2VzY2FwZXJlZ2V4cCIsIl9yZW1vdmV0cmFpbGluZ3NsYXNoIiwiTkVYVF9RVUVSWV9QQVJBTV9QUkVGSVgiLCJORVhUX0lOVEVSQ0VQVElPTl9NQVJLRVJfUFJFRklYIiwicGFyc2VQYXJhbWV0ZXIiLCJwYXJhbSIsIm9wdGlvbmFsIiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwic2xpY2UiLCJyZXBlYXQiLCJrZXkiLCJnZXRQYXJhbWV0cml6ZWRSb3V0ZSIsInJvdXRlIiwic2VnbWVudHMiLCJyZW1vdmVUcmFpbGluZ1NsYXNoIiwic3BsaXQiLCJncm91cHMiLCJncm91cEluZGV4IiwicGFyYW1ldGVyaXplZFJvdXRlIiwibWFwIiwic2VnbWVudCIsIm1hcmtlck1hdGNoIiwiSU5URVJDRVBUSU9OX1JPVVRFX01BUktFUlMiLCJmaW5kIiwibSIsInBhcmFtTWF0Y2hlcyIsIm1hdGNoIiwicG9zIiwiZXNjYXBlU3RyaW5nUmVnZXhwIiwiam9pbiIsIm5vcm1hbGl6ZWRSb3V0ZSIsInJlIiwiUmVnRXhwIiwiYnVpbGRHZXRTYWZlUm91dGVLZXkiLCJpIiwicm91dGVLZXkiLCJqIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiTWF0aCIsImZsb29yIiwiZ2V0U2FmZUtleUZyb21TZWdtZW50IiwiZ2V0U2FmZVJvdXRlS2V5Iiwicm91dGVLZXlzIiwia2V5UHJlZml4IiwiY2xlYW5lZEtleSIsInJlcGxhY2UiLCJpbnZhbGlkS2V5IiwibGVuZ3RoIiwiaXNOYU4iLCJwYXJzZUludCIsImdldE5hbWVkUGFyYW1ldHJpemVkUm91dGUiLCJwcmVmaXhSb3V0ZUtleXMiLCJuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZSIsImhhc0ludGVyY2VwdGlvbk1hcmtlciIsInNvbWUiLCJ1bmRlZmluZWQiLCJwcmVmaXhSb3V0ZUtleSIsInJlc3VsdCIsIm5hbWVkUmVnZXgiLCJvcHRpb25zIiwiY2F0Y2hBbGwiLCJjYXRjaEFsbFJlZ2V4IiwiY2F0Y2hBbGxHcm91cGVkUmVnZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/route-regex.js\n"));

/***/ })

});